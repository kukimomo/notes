# 算法

## 时间复杂度

时间复杂度就是一个算法程序在实现结果的时候,需要付出的代价的最高阶项.

​	一个操作如果和样本的数据量没有关系,每次都是固定时间完成的操作,那么这个操作就是常数操作.比如我们从数组中取值:int a = array[1];这样就是一种常数操作.而我们从链表中去拿东西的时候就不是常数操作,因为它并不是一个连续的内存空间,要遍历找到我们想要的才能拿到.它的操作时间是与数据量有关的.平时的加减乘除,位运算等都是常数操作.

​		在我们的选择排序中,它会假定第一个是最小的,然后遍历后面的进行比较,假设我们我们有一个N个元素的数组,那么它会进行N+N-1+N-2+N-3+....+1次比较,进行相同次数的遍历,以及进行N次数据的交换,那么我们就可以得到,它最终会付出的代价(也就是总共的常数操作次数)将是 a*N的平方+b\*N+c,这里a,b,c都是常数,那么这个算法的时间复杂度将是N的平方,也就是保留最高次项.我们使用O(读作大O)来表示复杂度.那么选择排序的时间复杂度就是O(N²).那么为什么我们会忽略低阶项呢?是因为这个时间复杂度它是根据最高阶项作为上限的,现象以下,如果我们要对100亿个数据进行选择排序,是不是它的低阶项和系数对于N²来说就显得微不足道了呢.

* 算法优劣的比较

  算法优劣就体现在算法的复杂度上,包括空间复杂度和时间复杂度.这里就先说说时间复杂度,当然时间复杂度就是越低阶越好,是常数就更好.如果当两个算法的时间复杂度指标是一样的话,就得看常数项了,但是常数项是非常难以计算精确的.此时最好就是使用在不同数据样本下的实际运行时间来比较了,也就是用常数项时间来进行比较.

## 关于异或

我们可以使用异或操作来进行两个数据的交换,比如a = 1;b = 2;通过a ^= b;b ^= a; a ^= b;这样就可以交换过来,但是我们要注意一个点,就是这样操作的时候,a与b的地址必须不能是同一个,如果是同一个那么那块的地址将会被清零.

对于异或来讲,我们可以认为是相同为假不同为真,除此之外,我们还可以认为它是**一个无进位相加运算**.

这有个关于异或的面试题:

* 在一个整型的数组int[] arr中,有一个数据是出现了奇数次的,其他的都是出现了偶数次的,那么我们要如何找到这个奇数次的数据呢?要求时间复杂度为O(N),额外空间复杂度为O(1).那么如果是两个数据出现了奇数次呢?

  对于这个问题,我们可以只需要一个额外的整型变量,只需要将它和这个整型数组的所有数据都异或一遍,遍历结束后,这个整型变量的值就是我们要找的数据.

  对于第二问,我们可以设我们要找的数据是a,b,其他都是偶数次,也准备一个额外的整型变量,如果我们将它与数组中所有的数据异或后,它的结果就是a^b,而且a!=b,那么这个整型变量肯定不是0,那么这个整型变量的某一位上肯定不是0,那在那个位上,a和b肯定是不一样的,只有这种情况才能使得那个位不为0.此时我们再准备一个整型变量,让它去异或上那个位上不为0的数据,异或完成后,我们将会得到a或者b.那么再与前面那个整型变量异或一次,就可以得到我们要找的那两个数据了.

* 一些关于位运算的骚操作

  * 一个数与上自己的取反+1就可以得到最右边的1,并且其他位都是0.



## 关于二分查找的一些应用

* 查找一个有序数组中是否存在一个数

  这是最经典的二分查找用法

* 查找有序数组中比一个数还小的最左边的位置

  这个也可以使用二分查找来查询数据所在位置.

* 查询局部最小,就比如对于一个数组的0位置的数来说,如果它比1位置的数小,那么这个0位置的数就是局部最小,对于N-1位置,如果N-1位置比N-2位置小,那么N-1位置的数据就是局部最小.对于i位置的数来说,它需要比i-1位置的数小,比i+1位置的数小,它才是局部最小.

  对于这个问题也是可以使用二分查找的,即使数组不是有序的.我们可以直接查中间位置是否比M-1和M+1位置要小,是就直接返回.如果它不是局部最小,那么它左边或者右边肯定存在局部最小.只要二分下去就能肯定能找到一个局部最小的数据.

对于二分查找来说,并不一定是要求数据有序的,对于数据的特定状况和特定的问题时,即使数据是非有序的,也是可以使用二分的方法的.

而且我们平时找中点是这样 : (left + right) /2,当数组长度很长很长的时候,比如是Integer.MAX_VALUE,那么就会导致数据溢出,导致中点是一个负值.所以我们可以这么写来规避数据溢出: left + (right - left) / 2

## 对数器

对数器 : 我们有一个想要测试的方法a,然后有一个我们不考虑时间复杂度的解决方法b,我们平时测试代码都是通过线上OG,也就是使用别人的测试用例.但是我们也不能什么时候都用线上OG来测啊,因此,我们就可以使用对数器来进行测试.我们可以使用一个随机样本生成器,产生的数据在方法a与方法b中都进行运行一次,我们可以测试它们一定次数,当两个方法在某次测试中出现了不同的结果,那么要不就是方法a有问题要么就是方法b有问题或者是它们俩都有问题.然后我们通过人为干预和修改这个随机样本生成的数据长度和对代码的修改,测试到两个方法一直都是对的.那你的方法就肯定是对的了.这就是对数器.

对数器的作用就是判断我们解决问题的方法是否正确.



## 递归行为的剖析和递归行为的时间复杂度分析

一个简单的递归案例:求一个数组中的最大值

```Java
public int process(int[] arr,int left,int right){//母问题规模为N=left + right
    if(left == right){//除递归外的行为
        return arr[right];
    }
    int mid = left + ((right - left) >> 1);//除递归外的行为
    int leftmax = process(arr,left,mid);//子问题的规模为N/2,下面那个也是N/2,说明子问题是等量的,如果是左侧1/3调一次递归,右侧2/3调递归,那么就不是等量递归,就不符合master公式
    int rightmax = process(arr,mid,right);//调用了两次子问题
    return Math.max(leftmax,rightmax);//除递归外的行为
    //总的递归外行为复杂度为O(1).
    //所以这个递归符合master公式.所以可以直接得到时间复杂度.
}
```

我们把上面的步骤拆开来,可以得到一个二叉树,所以呢我们可以知道,递归其实就是对一个二叉树的后序遍历.并且是在方法栈中对于这个二叉树的压栈与出栈进行遍历完成的.

对于递归来讲,有一个master公式 :  T(N) = a*T(N/b) + O(N的d次幂).它的意思是,有一个规模为N的母问题,T(N/b)就是子问题的规模,a就是子问题的调用次数.最后那个是除了子问题调用之外的时间复杂度是多少.我们可以通过master公式来估计一个递归的时间复杂度.

对于master公式中的a,b,d三个参数,如果它们满足以下情况,它们的时间复杂度就有对应的值:

* 当log(b为底,a) < d的时候,递归复杂度为O(N的d次幂)
* 当log(b为底,a) = d的时候,递归复杂度为O(N的d次幂*logN)
* 当log(b为底,a) > d的时候,递归复杂度为O(N的log(b为底,a)次幂)

## 简单排序算法的时间复杂度分析

简单排序算法(冒泡,选择,插入)具体实现在上一个笔记中有.

* 对于冒泡来说,它要进行一次全遍历和一次N-1次内遍历,那么就是O(N²).
* 对于选择来说,它要进行一次N-1次遍历和N-1次内遍历,那么也就是O(N²)
* 对于插入排序来说,它的时间复杂度是与数据情况是有关的,因为它相当于是在一个已经有序的部分里去插入新的数据,如果这个要插入的数据一直比已经有序的部分的最后那个大,就可以直接放进去,甚至不需要进行遍历,那么它的复杂度就是O(N),而一般的时候都需要进行N次外遍历和N-1次内遍历,所以是O(N²).

## 时间复杂度为O(NlogN)的排序

* 归并排序

  以分治思想,将一组数据尽可能的拆分为等份的两份,直到每一个子组中的数据个数只剩一个,然后让两组都排序好,然后合并排序好的子组(通过双指针比较),最终合并出来的就是排序结果.归并排序为啥是O(NlogN)呢?

  我们可以在之前的归并排序的代码中看到,递归调用了两次,a = 2,并且递归的分量都是2,所以b = 2,merge方法的复杂度因为它是把排序好的放回原来的,所以很明显是O(N)的,所以得出d = 1,很明显,归并排序符合master公式,并且满足log(b,a) = d,因此归并排序的复杂度就是O(NlogN).
  
* 关于归并排序的扩展

  对于归并来讲,除了排序以外,我们还经常用于处理小和问题以及逆序对问题.

  * 小和问题 : 在一个数组中,每一个数左边比当前数小的数累加起来,叫做这个数组的小和.

    例子 : 求出数组[1,3,4,2,5]这个数组的小和.

    解: 1左边比1小的,没有,3左边比3小的有一个1,4左边比4小的有1和3,2左边比2小的有一个1,5左边比5小的有1,2,3,4,则这个数组的小和为: 1+1+3+1+1+3+4+2 = 16.

    对于这个问题,我们可以想当然的使用暴力解法,也就是遍历数组的时候,看看在所在位置前面有多少个比当前位置小的,然后加起来.那么这样的算法复杂度将是O(N²)的,有没有复杂度更小的呢?

    我们可以这么想,在遍历的时候,看看右边有多少个比当前位置的数大的,那么就有多少个当前数的和.这样也是可以计算出小和的,那么怎么找右边比当前数大的个数呢?就可以使用归并了.具体过程(以这个1,3,4,2,5为例子:

    [1,3,4,2,5]最终会被归并拆成这么多 : ->左边 : [1],[3],[4], 右边:[2],[5],开始进行归并 : 对左边 : 先是[1] [3]进行归并,左边1小,放入辅助数组,此时产生一个**小和(1个1)**,然后3放入辅助数组成[1,3],然后与[4]进行归并,左边1小,放入辅助数组,再次产生**一个小和1**,然后移动指针,发现左边3也小,放入辅助数组,并产生一个**小和(1个3)**,左边到头,右边放入辅助数组成[1,3,4].左边归并完成,进行右边归并,[2],[5]归并,左边2比较小,放入辅助数组,产生一个**小和(1个2)**,左边到头,右边放入成[2,5],[1,3,4]与[2,5]进行归并,同上面操作,产生的小和就是**2个1,1个3,1个4的小和.**这里为啥是2个1嘞,因为开始归并的时候右边多了两个新数据,而且因为1比右侧第一个数小,并且右侧有两个数,所以会产生2个1,而3右边只有54比它大,所以只有1个3.在这整个过程中,我们可以不重复并且不遗漏的找到了每一个数的小和.在使用归并来计算数组小和的时候,在数据相同时,必须先拷贝右侧的数据,不然后面的右侧比左侧大的个数将是错误的.

    小和问题只需要在进行归并的时候,在merge(左右边都排号后求总的小和)里加一点点操作(统计小和数)即可.
  
  * 逆序对问题 :  在一个数组中,左边的数如果比右边的大,则这两个数构成一个逆序对,请打印这个数组中 的所有逆序对.
  
    这个问题就是求右边有多少个比左边当前的数小,跟求小和是一个道理的.
  
* 快速排序

  快速排序类似于归并,它们都是用分治的思想,不过快速排序是根据某一个数据来进行划分两组并对这两组进行有序化,最后合并成总的.

  * 关于快速排序的问题

    * 给定一个数组arr,和一个数num,请把小于num的数放在数组的左边,大于num的数放在数组的右边,要求额外空间复杂度为O(1),时间复杂度为O(N).如果要求等于num的数放在数组中间呢?(荷兰国旗问题)

      解法 : 
      
      * 对于第一个问题,比较好实现,数组的划分题目并没有说要排序,所以只需要划分好两个部分即可.
      
        思路: 可以准备一个变量,作为小于等于num的那个边界,然后我们遍历数组,遍历的时候,只需要比较当前数与num,如果当前数比num小于或者等于,那么久把它跟小于等于num的边界的下一个数交换,并且这个边界++;如果当前数比num大,那么就直接下一个,直到遇到比num小或者等于.遍历完成后,我们就完成了分组,并且分组按小于等于num区域的那个边界来分.并且时间复杂度为O(N),额外空间复杂度为O(1).
      
      * 对于第二个问题,就用两个变量表示小于num区域的边界,另一个变量表示大于num区域的边界,然后我们也只需要遍历数组,如果当前数比num小,那么久与小于区域的下一个数交换,小于区域++,然后继续遍历;如果当前数等于num,那么啥也不做,继续遍历;如果当前数大于num,就把当前数与大于区域的边界的前一个做交换,然后大于区域--,此时遍历的位置不变,再进行一次比较,然后继续遍历.直到遍历到大于边界即可.
      
    * 快速排序的操作是咋样的呢?
    
      * 快排Ver1.0 : 以数组的最后一个为基准,它前面的数分为两块 : 一块都小于它,一块都大于它,然后它与大于它的那块的第一个数交换,然后在这个小于它和这个大于它的区域里面重复这个动作,最终就排好了.
      * 快排Ver2.0 : 以数组的最后一个为基准,它前面的数分为三块 : 一块都小于它,一块都等于它,一块都大于它,然后最后这个数与大于它的那块的第一个数交换,在大于它和小于它的区域里重复这个操作,最终就排好了.这种方法比第一种块一点,因为它一次排好了一堆等于基准数的数据.
      * 但是这两个版本在最坏的情况下时间复杂度都是O(N²),因为这两个版本的划分值打的很偏,如果划分值能够是在中间的话,这样就是最好的情况,也就是O(NlogN),也就是划分值它会影响前面两个版本快排的复杂度.
      * 快排Ver3.0 :  随机选一个数,然后把它放到最后一个位置,然后再进行快排前两个版本的操作,那么这个时候好坏复杂度的情况就是一个概率事件,每种情况出现的情况都是1/N,那么总共的期望复杂度就是O(NlogN).
      * 快速排序的额外空间复杂度是O(logN)的,在最差情况下是O(N),而在优化情况下,因为也是一个概率,所以它的空间的最终的期望也是O(logN)
  
  ## 桶排序
  
  

讲桶排之前先回顾以下堆

堆是一棵完全二叉树,一般用数组来表示,它的一个节点的右子节点位置是2*i+1,它的节点的左子节点的位置是2\*i + 2,一个节点的父节点位置是(i-1)/2,而堆是一个特殊的完全二叉树,它的父节点总是比它的子树节点都要大/小,对应了大根堆和小根堆.对于堆来说,它的元素操作的时间复杂度就是O(logN)的.

堆排序的话,因为没有递归,也没有用什么额外的数组,所以它的排序时间复杂度是O(NlogN)的,额外的空间复杂度为O(1)的.

而优先队列是用堆实现的,那就意味着优先队列并不是队列,而是一个堆.

关于堆的题:

* 已知一个几乎有序的数组,几乎有序是指:如果把数组排序好的话,每个元素移动的距离可以不超过k,并且k相对于数组来说比较小.请选择一个合适的排序算法针对这个数据进行排序.
  * 解法 : 这个k的意思就是当我们排好序之后这个数据与它实际在的正确的位置的距离不超过k.我们可以准备一个小根堆,然后把要排序的数据的前k+1个数放到小根堆里面去,然后每一次新加一个数到小根堆里去以及从小根堆里弹出一个数到原数组中去.

**桶排序**

关于桶排序,它思想下的排序:

* 计数排序
* 基数排序

桶排序思想下的排序都是不基于比较的排序,我们前面的排序,冒泡,选择,插入,归并,快排,堆排都是要比较元素的.它们都是基于比较的排序.

时间复杂度为O(N),额外空间复杂度为O(M)

桶排序的应用范围有限,需要样本的数据状况满足桶的划分.

 **计数排序**

这个排序就是我们针对要排序的对象的数据准备一个数据表,比如说员工年龄,这个员工年龄肯定是在18-45之间的吧,所以我们准备一个长度为45-18的数组,它的下标就表示18~45,然后遍历原数组,遇到一个相应的值就在这个数组的下标里面的值++一下,最后还原一下,就可以得到排序结果了.

**基数排序**

先举个例子,[17,13,25,100,72]怎么排序嘞,首先我们找出里面位数最多的那个,也就是100,它有三位,所以其他不足三位的数要进行补足,在最高位补一个0.然后我们根据这些数字有哪几种来准备一些容器(可以是队列,数组等,一般用队列),这里有0,1,2,3,5,7六种数字,所以就准备6个桶,以这些数字为标号,然后从个位开始,按照各位的数字,把原数组的东西装进对应的桶里,然后按从左到右(从0桶到7桶依次),再从桶里把数据倒出来排成一种顺序,按这个顺序放回数组里,然后再看十位和百位,按照上面的操作继续.最后以此倒出来的时候,数据就有序了.

基数排序是基于进制的,所以它也是有局限性的.

```Java
//基数排序
public static void radixSort(int[] arr){
    if(arr == null || arr.length < 2){
        return;
    }
    radixSort(arr,0,arr.length-1,maxbit(arr));
}
public static int maxbit(int[] arr){//找到最大值的位数
    int max = Integer.MIN_VALUE;
    for(int i = 0;i < arr.length; i++){
        max = Math.max(max,arr[i]);
    }
    int res = 0;
    while(max != 0){
        res++;
        max /= 10;
    }
    return res;
}
//L : 排序的左边界
//R : 排序的右边界
//digit : 数组中最大值的位数
public static void radixSort(int[] arr,int L,int R,int digit){
    final int radix = 10;
    int i = 0,j = 0;
    //有多少个要排序的数就准备多少空间(相当于桶)
    int[] bucket = new int[R-L+1];//辅助数组
    for(int d = 1;d <= digit; d++){
        //有几位就进出几次(一共要入桶出桶的次数)
        //count[0] 当前位(d位)是0的数字有几个
        //count[1] 当前位(d位)是(0和1)的数字有多少个
        //count[2] 当前位(d位)是(0,1,2)的数字有多少个
        //count[i] 当前位(d位)是(0,1,2,....,i)的数字有多少个
        int[] count = new int[radix];//count[0..9],相当于词频表,用词频的方式来代替桶
        for(i = L;i <= R ;i++){//统计某一位上的数字个数
            j = getDigit(arr[i],d);
            count[j]++;
        }
        for(i = 1; i < radix;i++){
            count[i] = count[i] + count[i-1];//某一位数小于等于那一位数的数字个数有多少个
        }
        for(i = R;i >= L;i--){ //从原数组右边开始出桶,出桶的位置为(这个数的那一位数小于等于那一位数的数字个数)-1,并把出桶的数字放到辅助数组中对应的位置,(这个数的那一位数小于等于那一位数的数字个数)--.
            //也就是说,通过这个计数数组count,从右往左这么去放数字,就相当于完成了一遍入桶与出桶操作.
            //从右往左遍历的原因是这么操作可以更像出桶的操作
            j = getDigit(arr[i],d);
            bucket[count[j] -1] = arr[i];
            count[j]--;
        }
        for(i = L,j = 0;i <= R; i++,j++){//把辅助数组的数字放回原数组.
            arr[i] = bucket[j];
        }
    }
}
public static int getDigit(int x,int d){
    return ((x/((int)Math.pow(10,d-1)))%10);
}
```

## 排序算法的稳定性与总结

* 排序算法的稳定性

  稳定性是指当进行排序的数中有相同数据的时候,它们的顺序不会因为排序而改变顺序,那么这个排序算法就是稳定的,否则就是不稳定的

* 稳定的排序算法

  * 冒泡排序(时间复杂:O(N²),额外空间O(1))
  * 插入排序(O(N²),O(1))[但是它的常数极低]
  * 归并排序(在归并的时候先拷贝左边的才会稳定,所以小和问题在利用归并的时候会丧失稳定性)(O(NlogN),O(N))[归并排序中使用内部缓存法可以将额外空间复杂度降低到O(1)]
  * 桶排序

* 不稳定的排序算法

  * 选择排序(时间复杂:O(N²),额外空间O(1))
  * 快速排序(O(NlogN),O(logN))[经过很难的操作,快速排序可以做到稳定性,但是会导致额外空间增大到O(N)]
  * 堆排序(O(NlogN),O(1))

到目前为止,我们没有发现时间复杂度为O(NlogN),额外空间复杂度为O(1),并且是稳定的基于比较的排序算法.

对于一般情况,我们都用快速排序,因为它的时间复杂度指标经过实验,它的常数项是最低的.如果要保证稳定的话就可以使用归并排序.如果空间有限就可以选择堆排序.

**对于排序的一个大坑面试题:**奇数放在数组左边,偶数放在数组右边,要求原始的相对次序不变,如何进行排序?

​		对于这个题,就是面试官在搞你.这个问题和快速排序的划分问题一样,就是Ver1.0的那个快速排序的问题一样,如果我们能在保证划分小于区域与大于区域的时候还能保证稳定性,那么肯定也能做到奇数放左边偶数放右边还能保持稳定性.但是这个操作是一个及其复杂的过程,是一个论文中的算法,当遇到这种问题,就反手说我不会,求教即可.

**实际工程中对排序的优化**

这个面试的时候也有可能会问.一般我们从两个角度去考虑这个问题

*  针对实际工程中的排序样本量,利用各自排序算法的优势来进行综合排序.

  比如在进行快速排序的时候,分出来的区域样本量较少,这个时候可以直接用插入排序,能够比只用一种排序还要高效

* 基于稳定性的考虑

  我们在对于数组,基本数据类型的排序一般是不考虑稳定性的,这时候就哪种算法快就用啥.而那些我们自定义类型的东西,我们就必须要考虑稳定性.

  对于Java库中提供的Arrays.sort()这个东西来讲,它就是这么考虑的.当我们传入排序的东西是基本的那些数据类型到时候,它会用快速排序,而对于自定义类型的东西会去用归并排序.

不管是在Java语言中,还是在C/C++语言中那些标准库中的相关排序方法,排序函数的底层,它们的代码量都非常的庞大,几千上万行的.为啥嘞,就是基于上面两个方面的考虑,语言的设计者们恨不得把每种排序算法的高效之处都压榨到干,也就是为了能够使语言的效率更高.



## 链表与哈希

在链表之前,先了解一波哈希表

**哈希表**

* 哈希表在使用层面可以认为是一种集合结构,

* 如果只有key,没有value,那么就可以使用Java中的HashSet结构(C++中的UnOrderedSet)
* 如果key,value都有,就可以用Java中的HashMap结构(C++中的UnOrderedMap)
* 有没有value就是Set和Map的唯一区别,底层的实际结构也是这样的
* 使用哈希表进行增删改查(put,remove,put,get)操作的时候,可以认为时间复杂度为O(1),但是常数时间较大.
* 放入哈希表中的东西,如果是基本类型,内部按值传递,内存占用就是这个数据的大小(Java里面,下面一条也是,C++里面有指针这玩意)
* 放入哈希表中的东西,如果不是基本类型,那就按应用传递,内存占用是这个东西内存地址的大小(一般就是8字节大小,C++里的对象指针也就是这样的)
* 有关哈希表的原理将在后面讲到

**有序表** 

* 有序表与哈希表的区别是,有序表把key按照顺序组织起来,而哈希表完全不组织
* Java里的有序表就是TreeSet,C++里的是OrderedSet,还有TreeMap,C++还有OrderedMap
* 红黑树,AVL(自平衡二叉搜索树)树,Size-Balance-Tree(节点大小平衡树)和跳表都属于有序表,只是底层具体实现不一样
* 不管是什么底层具体实现,只要是有序表,都具有以下固定的基本功能和固定的时间复杂度:
  * put() : 将key,value对插入表中,或者更新key对应的value
  * get() : 根据给定的key,查询value并返回
  * remove() : 移除给定的key记录
  * containsKey() : 查询是否存在给定key的记录
  * firstKey() : 放回所有k,v对中最左边(最小)的那个
  * lastKey() : 这个就是找最右(最大)的那个
  * floorKey() : 如果表中存在给定的key,就放回这个key,不然就放回所有key的排序结果中,最接近给定key的前一个
  * ceilingKey() : 这个就是如果没有找到给定的key就找最接近给定key的后一个
  * 这些操作的时间复杂度都是O(logN),N为有序表的记录数

**链表**

链表分为单链表和双链表,单链表就是只有一个指向方向的next域,而双链表它有两个指向,一个指向前面,一个指向后面.

对于链表来讲,在笔试和面试的时候要求是不一样的

* 在笔试时,不用考虑空间复杂度,直接考虑时间复杂度低的方法
* 在面试时,也是把时间复杂度放在第一位.但尽量找到空间最省的方法

针对这类问题的技巧

* 使用辅助数据结构

* 快慢指针(在判断链表有环的问题十分有用,一般就是快指针走两步,慢指针走一步)

  对于快慢指针,在实际情况下有很多定制需求,是非常灵活的,必须要自己灵活定制.

经典的链表问题:

* 反转链表

  * 反转单向链表
  * 反转双向链表

  这个问题也就是换向问题,很简单.

* 打印两个有序链表的公共部分

  解决方法就是像归并排序的合并操作,就是两个指针,分别指向两个链表头,谁小,谁下一个,发现两个相等,输出,然后同时移动,重复这些操作即可

* 判断链表是否是一个回文结构(回文结构就是正着遍历和反着遍历是一样的,就是它有对称轴)

  对于这个问题,我们可以使用及其经典的数据结构:栈,来解决.把链表遍历一遍,放入栈中,然后再遍历一遍,同时弹栈,全部一样的时候就是回文.那么有没有更省空间的状况呢?

  有的,就是我们只把前一半的链表装进栈里,然后从中点开始遍历,同时弹栈,到栈弹空为止,都一样就是回文,这种方法的话,可以使用双指针来操作,快指针走到底的时候,慢指针位置的东西就把前一半都进栈了,并且它在中点,此时遍历慢指针,同时弹栈,芜湖~.那么有没有空间复杂度为O(1)的嘞?也有的

  当快指针遍历完成后,从慢指针的位置开始,把后面的节点都打反,也就是让慢指针所处位置指向null,然后后半部分指向倒转过来,比如 1->2->3->2->1变成这样:1->2->3<-2<-1,然后这个3指向null,然后再从头和尾从中间遍历,遍历的时候比对对应位置,有一个指到空结束,过程中如果比对都相等,那么就是回文,如果有一个不等就不是.放回结果前,将原链表变回原样.这样就可以不使用额外的空间了.

  ```Java
  public static boolean isPalindrome(Node head){
      if(head == null || head.next == null){
          return true;
      }
      Node n1 = head;
      Node n2 = head;
      while(n2.next != null && n2.next.next != null){
          //快慢指针遍历完链表,让n1指向中点
          n1 = n1.next;
          n2 = n2.next.next;
      }
      n2 = n1.next; //n2现在是中点的下一个
      n1.next = null;//中点的next置为null
      Node n3 = null;//辅助变量
      while(n2 != null){
          n3 = n2.next; //辅助指向n2的下一个
          n2.next = n1;//n2的下一个指向n1
          //上面两步完成两个节点的反转
          n1 = n2; //向后位移一个
          n2 = n3; //同上
      }
      n3 = n1; //尾指针
      n2 = head;//头指针
      boolean res = true;
      while(n1 != null && n2 != null){
          //头尾指针相向而行,同时进行比较,有一个不一样就不是回文串
          if(n1.value != n2.value){
              res = false;
              break;
          }
          n1 = n1.next;
          n2 = n2.next;
      }
      //弄完后要把改造的链表变回原来的样子
      n1 = n3.next;
      n3.next = null;
      while(n1 != null ){
          n2 = n1.next;
          n1.next = n3;
          n3 = n1;
          n1 = n2;
      }
      return res;
  }
  ```

  

* 将单向链表按某值划分为左边小,中间相等,右边大的形式
  * 升级 : 在实现上述要求的时候增加以下内容
    * 调整所有小于/等于/大于给定值的节点之间的相对顺序和调整前一样(保持稳定)
    * 时间复杂度为O(N),空间复杂度为O(1)
    
  * 解法:
  
    在笔试的时候,我们可以直接用一个数组,遍历一遍链表把节点放进这个数组,然后在数组里进行快排就完事了,排完后再把节点串起来就行了.
  
    在面试的时候,就不能用额外的数据结构了.我们整6个变量:小于给定值的头尾指针,等于给定值的头尾指针,大于给定值的头尾指针.然后我们遍历原链表,同时每一次比较节点元素与给定值,如果小于给定值,并且此时小于给定值的头和尾指针都是空的话,那就让这俩都指向这个节点,其他同理,如果再找到第二个比给定数小的值,就改变尾指针的指向,并且头指针是指向尾指针的,如果还找到了,那就继续让头指针的next等于这个新的小于给定数的值,然后让这个值成为尾指针.遍历结束后,把小的尾指针的next指向等于的头指针,等于的尾指针指向大于的头指针,就概述了.不但是在最后合并的时候,需要注意有没有空边界.这也是链表相关的题的共性,对于链表都需要我们好好考虑边界的,链表这东西很容易就会产生空指针异常.
  
    ```Java
    public static Node listPartition(Node head,int pivot){
        Node sh = null;
        Node st = null;
        Node eh = null;
        Node et = null;
        Node bh = null;
        Node bt = null;
        //6个边界引用
        Node next = null;
        while(head != null){
            //开始遍历
            next = head.next;
            head.next = null;
            if(head.value < pivot){
                if(sh == null){
                    sh = head;
                    st = head;
                }else{
                    st.next = head;
                    st = head;
                }
            }else if(head.value == pivot){
                if(eh == null){
                    eh = head;
                    eh = head;
                }else{
                    et.next = head;
                    et = head;
                }
            }else{
                if(bh == null){
                    bh = head;
                    bt = head;
                }else{
                    bt.next = head;
                    bt = head;
                }
            }
            head = next;
        }
        //遍历完成后就得到三个分好区的链表了,查看三个区域的状态并进行拼接.
        if(st != null){
            st.next = eh;
            et = et == null ? st : et;
        }
        if(et != null){
            et.next = bh;
        }
        return sh != null ? sh:(eh != null ? eh : bh);
    }
    ```
  
* 复制含有随机指针节点的链表

  一种特殊的单链表节点描述如下:

  ```Java
  class Node{
      int value;
      Node next;
      Node rand;
      Node(int val){
          value = val;
      }
  }
  ```

  rand指针是单链表节点结构中新增的指针,rand可能指向链表中的任意一个节点,也可能指向null,给定一个由该Node节点类型组成的无环链表的头节点head,请完成这个链表的复制.要求时间复杂度O(N),空间复杂度O(1).

  * 解法

    在笔试的时候,可以直接用一个哈希表(用Map) 解决,这个map的key是老节点,value是新节点,老节点就是原链表里的节点,新节点是复制出来的新的节点.然后遍历链表,同时查询map里的对应键,然后设置对应新节点的next和rand指向.

    在面试的时候嘞,就不能用map了,此时我们可以这样 : 对原链表进行遍历,复制的新节点直接跟在老节点的后面,也就是老节点的next = 复制出来的新节点,完成一次遍历后,每一个老节点后面都会带着复制出来的它的新节点,然后进行一对一对的遍历,通过老节点的rand指向节点的下一个找到新节点的rand的指向.最后间老节点和新节点分离,就得到了这个复制出来的新链表.

    ```Java
    public static Node copyListWithRand(Node head){
        if(head == null){
            return null;
        }
        Node cur = head;//老节点
        Node next = null;
        while(cur != null){//进行新节点的复制
            next = cur.next;
            cur.next = new Node(cur.value);
            cur.next.next = next;
            cur = next;
        }
        cur = head;
        Node curCopy = null;
        while(cur != null){//进行新节点的rand的设置
            next = cur.next.next;
            curCopy = cur.next;
            curCopy.rand = cur.rand != null ? cur.rand.next : null;
            cur = next;
        }
        Node res = head.next;
        cur = head;
        while(cur != null){//把原链表和复制出来的新链表分离
            next = cur.next.next;
            curCopy =  cur.next;
            cur.next = next;
            curCopy.next = next!=null ? next.next:null;
            cur = next;
        }
        return res;
    }
    ```

* 两个单链表相交的一类问题

  给定两个可能有环也可能无环的单链表的头节点head1和head2,如果两个链表相交,请找到这个相交的第一个节点,如果不相交,就放回null,如果两个链表长度和为N,要求时间复杂度为O(N),空间复杂度为O(1).

  * 解法

    题目给定的链表是可能有环的,所以我们得先判断链表有没有环(用Set或者快慢指针).

    ```Java
    //快慢指针找到入环的第一个节点
    //如果快指针走到null了说明没有环,但是如果链表存在环,那么快慢指针一定会在环内相遇.
    //当快慢指针相遇后,快指针回到头节点,速度降为慢指针的速度,开始走,直到他们俩再次相遇,此时相遇的位置就是入环节点.
    public static Node getLoopNode(Node head){
        if(head ==null || head.next == null || head.next.next == null){
            return null;
        }
        Node n1 = head.next;
        Node n2 = head.next.next;
        while(n1 != n2){
            if(n2.next == null || n2.next.next ==null){
                return null;
            }
            n2 = n2.next.next;
            n1 = n1.next;
        }
        n2 = head;
        while(n1 != n2){
            n1 = n1.next;
            n2 = n2.next;
        }
        return n1;
    }
    
    ```

    对于原题,有以下情况

    * 两个链表都无环

      在这个情况下,我们可以遍历两个链表,并获取两个链表的长度,然后判断两个链表的尾节点是否一致,如果不是,那么这俩链表必不可能相交.如果是一个,那么从长的链表开始,先走一个长的数量-短的数量到达那个遍历开始的起始点,然后从短的链表与这个起始点开始,一直往下走,两个点必然会再相交处相遇.

    * 两个链表都有环

      这里分为三种情况

      * 不相交

        让其中一个入环节点继续遍历,遍历回到自己这个点如果遇不到另一个入环节点,那么就是不相交的.

      * 不在环上相交

        这个情况下入环节点是同一个的.然后以这个入环节点为结尾,按无环相交情况来找相交节点就行

      * 在环上相交

        让其中一个入环节点继续遍历,遍历回到自己这个点的过程中如果遇到另一个入环节点,那么就是在环上相交.此时有两个相交节点.也就是对应的两个入环节点.可以按需放回其中一个

    * 不存在两个链表其中一个无环还相交的情况,只要有公共部分,不管这个相交部分是不是在环上,链表最终都是有环的,所以一个有环一个无环的情况下必是不相交的

## 二叉树

二叉树是一种经典的数据结构,它以高效的查询而被广泛引用,由它引申的2-3树,红黑树,B树等结构,都是以更高效的查询为目标而出现的.

**二叉树节点结构**

二叉树的节点包含本体的键值对以及左子节点和右子节点

```Java
class Node<T>{
    T value;
    Node left;
    Node right;
}
```

**二叉树的遍历**

* 递归遍历

  在递归的时候,每个节点都会来三次

  * 前序遍历

    对于每一个子树都先遍历出根节点,再到左子节点,再到右子节点.

    在递归序里就是在第一次到达这个节点的时候就开始操作,第二次到达和第三次到达的时候不干事

  * 中序遍历

    对于每一个子树都先遍历出左子节点,再到根节点,再到右子节点

    在递归序里就是在第二次次到达这个节点的时候就开始操作,第一次到达和第三次到达的时候不干事

  * 后序遍历

    对于每一个子树都先遍历出左子节点,再到右子节点,再到根节点

    在递归序里就是在第三次到达这个节点的时候就开始操作,第一次到达和第二次到达的时候不干事

* 非递归遍历

  任何递归都可以变成非递归过程

  * 前序遍历

    准备一个栈,把根节点丢进去,然后每次从栈中弹出一个节点记为cur,然后对cur进行操作(打印),把cur的右子节点和左子节点压入栈中(如果有的话).重复上述操作

  * 中序遍历

    树的左树进栈,在依次弹出节点的过程中,对弹出节点的右树重复这个操作.

  * 后序遍历

    在前序遍历的时候,先压左再压右到栈中,再准备一个栈,然后在cur从第一个栈弹出的时候,就把它压入新的栈,完成后这个新的栈里出栈的顺序就是后序遍历

**直观的打印一个二叉树**

我们可以自己整一个打印二叉树的方法(用来辅助我们对二叉树的操作):

```Java
public static void printTree(Node head){
    
}
```





**二叉树的宽度有限遍历(也就是经常会让我们算树的宽度问题)**

树的前序遍历就是树的深度优先遍历.

树的宽度优先遍历,我们可以用一个队列来操作,具体操作是这样的 : 准备一个队列,然后让根节点进入队列,然后让头节点出队列,同时让它的左右子节点顺序进入队列,然后左右节点顺序出队列的同时它们各自的左右节点进入,以此往复直到最后啥都没有为止.

```Java
public static void w(Node head){
    if(head == null){
        return;
    }
    Queue<Node> queue = new LinkedList<Node>();
    queue.add(head);
    while(!queue.isEmpty){
        Node cur = queue.poll();
        System.out.println(cur);
        if(cur.left != null){
            queue.add(cur.left);
        }
        if(cur.right != null){
            queue.add(cur.right);
        }
    }
}
```

那么如何求树的最大宽度嘞?

我们可以准备一张表(Map),这个表就是管我们遍历的节点是在哪一层的.我们可以用三个变量分别记录当前层数,当前层数的节点数量,最大节点数量.在上面遍历的时候加上一些操作即可

```Java
public static int getMaxW(Node head){
    if(head == null){
        return;
    }
    Queue<Node> queue = new LinkedList<Node>();
    queue.add(head);
    Map<Node,Integer> levelMap = new HashMap<>();//记录当前节点所在层数
    levelMap.put(head,1);//把头节点扔进去,它在第一层
    int curLevel = 1;//默认当前在根节点也就是第一层
    int curLevelNodes = 0;//默认当前层数节点还没有,要弹出才算
    int max = Integer.MIN_VALUE;//默认最大宽度,也可以是0
    while(!queue.isEmpty){
        Node cur = queue.poll();
        System.out.println(cur);
        int curNodeLevel = levelMap.get(cur);//获取当前弹出节点所在层数
        if(curNodeLevel == curLevel){
            //如果当前节点所在层数等于当前层数
            curLevelNodes++;//当前层数的节点数量++
        }else{
            max = Math.max(max,curLevelNodes);//如果当前节点所在层数不等于当前层数,说明此时已经遍历到下一层了,此时需要判断上一层的数量与当前最大数量谁大
            curLevel++;//当前层数++
            curLevelNodes = 1;//进入下一层初始化当前层数的节点数量
        }
        if(cur.left != null){
            queue.add(cur.left);
            levelMap.put(cur.left,curNodeLevle+1);//在加入的同时要添加该节点所在的层数信息
        }
        if(cur.right != null){
            queue.add(cur.right);
            levelMap.put(cur.right,curNodeLevle+1);
        }
    }
    return max;
}
//我们是否可以下降额外空间呢,如果不用这个Map的话,会比较复杂.
//如果不使用Map,我们要用几个变量来记录信息:当前层最后一个节点curend,下一层最后一个节点,nextend,当前层的节点个数curLevelNodes,最大宽度max.
//刚开始让curend = head,然后让head进队列,它出来的时候,先让它的左孩子进队列,看nextend是否是空,如果是的话就让nextend=head的左孩子,然后还有右节点的话就右节点进栈,让nextend = head的右孩子,反正这个nextend就是等于下一层最后一个进队的那个节点.然后head出队列,当前层节点数++,它出队列的时候看看当前层的最后一个节点是不是这个出队列的节点,如果是,那就让当前层的最后一个节点也就是curend等于nextend,并且max=Math.max(max,curLevelNodes),然后nextend为空,curLevelNodes=0,再然后按上面的方法更新nextend,以此反复直到队列为空
```

**二叉树相关的概念和判断**

* 如何判断一棵树是否是搜索二叉树

  搜索二叉树就是这样的: 对于树的每一个子树,它的左子节点都比当前节点小,右子节点都比当前节点大.满足这个条件的话这个树就是一个搜索二叉树.

  判断方法 : 对这个树进行中序遍历,如果得到的一个顺序是有序的,那这个树就是一个搜索二叉树,如果其中有地方不是有序的,或者整个树本来是升序,里面有个降序的段,那么这个树就不是搜索二叉树.

  ```Java
  static int preValue = Integer.MIN_VALUE;
  public static boolean isBST(Node head){
      if(head == null){
          return true;
      }
      boolean isLeftBST = isBST(head.left);//检查左树是不是搜索二叉树
      if(!isLeft){ //如果左树不是了那整个树就不是搜索二叉树
          return false;
      }
      if(head.value <= preValue){//当前遍历到的值跟这个preValue比较,如果是升序的,那这一个地方起码是有序的,如果不是那这个地方不是有序的,那就不是搜索二叉树
          //这个地方的比较也就是中序遍历出的左右节点去跟它们的父节点去比较.得满足右边大于它父节点才行.
          return false;
      }else{
          preValue = head.value;//如果当前地方是有序的,就更新这个preValue
      }
      return isBST(head.right);//左树全部是搜索二叉树了,看右树是不是搜索二叉树
  }
  //同样的,对于搜索二叉树,要满足这几个条件 : 左右子树都是搜索二叉树,左子树的最大值不能大于当前节点值,右子树的最小值不能小于当前节点值.满足这些条件这棵树才是搜索二叉树(二叉查找树).
  class ReturnType{
      public boolean isBST;
      public int min;
      public int max;
      public ReturnType(boolean isb,int min,int max){
          isBST = isb;
          min = min;
          max = max;
      }
  }
  
  public ReturnType process(Node x){
      if(x == null){
          return null;
      }
      ReturnType leftD = process(x.left);//递归获取左子树信息
      ReturnType rightD = process(x.right);//递归获取右子树信息
      
      boolean isB = true;
      int min = x.value;
      int max = x.value;
      if(leftD != null){//如果左边的信息不是空的,就更新当前树最大和最小值
          min = Math.min(min,leftD.min);
          max = Math.max(max,leftD.max);
      }
      
      if(rightD != null){//如果右边的信息不是空的,就更新当前树最大和最小值
          min = Math.min(min,rightD.min);
          max = Math.max(max,rightD.max);
      }
      
      if(leftD != null && (!leftD.isBST || leftD.max >= x.value){
          //如果左边不是空,并且左边的信息不满足左边是二叉搜素树的情况,那么这棵树就不是二叉搜索树,右边同理.如果满足了全部条件,那么这个树就是一个二叉搜索树.
          isB = false;
      }
      if(rightD != null && (!rightD.isBST || rightD.min <= x.value){
          isB = false;
      }
      return new ReturnType(isB,min,max);
  }
  ```

  

* 如何判断一棵树是否是完全二叉树

  完全二叉树就是除了最后一层之外是一个满二叉树.而且最后一层必须是从左到右是满的,就是左子节点要有,右子节点可以没有.如果左子节点没有,那这个树就不是完全二叉树.

  判断方式 : 对这个树进行宽度遍历.对于每个节点,如果存在有右子节点但却没有左节点的情况,直接就不是完全二叉树.然后就是在不违反前一个条件的情况,如果遇到了第一个存在有左右子节点不全的节点,那接下来遇到的节点必须是叶子节点,如果存在不是叶子节点的情况,那就不是完全二叉树.

  ```java
  public static boolean isCBT(Node head){
      if(head == null){
          return true;
      }
      Queue<Node> queue = new LinkedList<>();
      boolean leaf = false;//是否遇到了左右孩子不双全的节点
      Node left = null;
      Node right = null;
      queue.add(head);
      while(!queue.isEmpty()){
      	head = queue.poll();
          left = head.left;
          right = head.right;
          
          if((leaf && (left!=null||right!=null))//遇到了左右孩子不双全的情况并且这个寄吧节点还不是叶子节点,寄
                       ||
                       (left==null&&right!=null)//有右节点却没有左节点,寄
             ){
              return false;
          }
          //----下面两个if是正常的宽度遍历操作
          if(left != null){
              queue.add(left);
          }
          if(right!=null){
              queue.add(right);
          }
          //----
          if(left == null || right == null){//遇到了寄吧的左右孩子不双全的节点
              leaf = true;
          }
      }
      return true;
  }
  ```

  

* 如何判断一棵树是否是满二叉树(有套路)

  满二叉树就是节点个数与最大深度的关系满足 : 节点个数 = 2*最大深度 - 1,只有满足这个条件的二叉树才是满二叉树,不然它肯定不是满二叉树.所以判断条件的第一种方法就是先求最大深度和节点个数.

  判断方法 : 用我们的套路来 : 看左右子树是不是满的,获取每个树的节点数量和最大深度,看节点数量是否满足上面的条件

  ```java
  class Info{
      public int height;
      public int nodes;
      public Info(int h,int n){
          height = h;
          nodes = n;
      }
  }
  public Info process(Node x){
      if(x == null){
          return new Info(0,0);
      }
      Info leftD = process(x.left);//递归获取左子树深度和节点数
      Info rightD = process(x.right);
      int height = Math.max(leftD.height,rightD.height) + 1;//本树的信息.
      int nodes = left.nodes + right.nodes + 1;
      
      return new Info(height,nodes);//获得这个树的深度和节点数
  }
  ```

  

* 如何判断一棵树是否是平衡二叉树(有套路)

  平衡二叉树就是对于任意一个子树来说,它左子树的高度与右子树的高度差都不超过1,满足这个条件的就是平衡二叉树.

  判断方法 : 当一个树满足1.左子树是平衡二叉树.2.右子树是平衡二叉树.3.左子树高度-右子树高度<=1.的时候,它才是平衡二叉树.我们需要左子树的信息有 : 是否是平衡二叉树,树的高度. 对于右子树也是同样的要求.然后去看是否满足上面那三个情况.

  ```Java
  class ReturnType{//因为我们需要子树是否是平衡二叉树和高度两个返回值,Java只能放回一个值,所以我们把它们包装起来,方便使用
      public boolean isBalanced;
      public int height;
      public ReturnType(boolean isB,int h){
          isBalanced = isB;
          height = h;
      }
  }
  public ReturnType process(Node x){//传入head节点即可知道整个树是不是平衡的
      //判断子树x是否是平衡二叉树以及树x的高度
      if(x == null){
          return new ReturnType(true,0);
      }
      
      ReturnType leftData = process(x.left);//递归获取左子树上的信息
      ReturnType leftData = process(x.right);//递归获取右子树上的信息
      
      height = Math.max(leftData.height,rightData.height) + 1; //获取最大高度加上自己所在的一层
      boolean isB = leftData.isBalanced && rightData.isBalanced && Math.abs(leftData.height - rightData.height) < 2;//我自己是不是平衡二叉树
      return new ReturnType(isB,height);//返回我的信息
  }
  ```

  

* 二叉树解题的套路

  当我们求解一个二叉树问题的时候,我们需要知道对于这个问题来说,有多少种可能性.以及树能够给我们的信息.

  ​		比如对于判断一颗树是否是平衡二叉树,就有这样的可能性 : 1.左子树是平衡二叉树.2.右子树是平衡二叉树.3.左子树高度-右子树高度<=1.在这三种都满足的情况下树才是平衡二叉树,而对于其他可能的情况,这个树就不是平衡二叉树.

  在列出的可能性中,找到能够满足题目需求的那些,然后通过树给我们的信息,在上面判断树是不是平衡二叉树的过程中,我们就需要从树的左右子树中获取信息.去将这些可能性验证出来即可.

  解树的时候我们都是可以按这样的套路来的 : 满足题目需要的条件(可能性),能够从子树中获取要求相同的信息.我们就可以使用递归来解决问题了.并且这个方式可以解决所有面试中的树型DP问题(即树型动态规划问题).
  
  对于二叉树问题来讲,并不是全部都能用这个套路.能使用这个套路的前提前面也说了,我们的问题必须是可以从左子树和右子树去获取信息就可以列出全部可能性,并以此解决全部的问题的.当这个套路没法去解决这个问题的时候,就意味着这个问题非常麻烦,并且这种题基本是没法优化的. 

**二叉树常见题**

* 给定两个二叉树的节点node1和node2,找到它们的最低公共祖先节点

  这个最低公共祖先就是指离他们俩最近的并且是公共节点的节点就是最低公共节点.

  解法 : 我们可以用一张表来记录每个节点的父节点.在遍历的时候记好.

  ```java
  public Node lca(Node head,Node o1,Node o2){
      HashMap<Node,Node> fatherM = new HashMap<>();
      fatherM.put(head,head);
      process(head,fatherM);
      
      HashSet<Node> set1 = new HashSet<>();//用一个Set来记录o1往上的一条链
      set1.add(o1);
      Node cur = o1;
      while(cur != fatherM.get(cur)){
          set1.add(cur);
          cur = fatherM.get(cur);
      }
      set1.add(head);
      //然后再从o2往上看,同时看看o2往上的东西有没有在Set里,如果有,那这个节点就是它们的公共最低祖先节点
      Node cur2 = o2;
      while(cur2 != fatherM.get(cur2)){
          if(set1.contrains(cur2)){
              return cur2;
          }
          cur2 = fatherM.get(cur2);
      }
      return null;
  }
  public void process(Node head,HashMap<Node,Node> fatherM){//通过遍历,把每个节点和它的父节点都记录在fatherM表中
      if(head == null){
          return;
      }
      fatherM.put(head.left,head);
      fatherM.put(head.right,head);
      process(head.left,fatherM);
      process(head.right,fatherM);
  }
  
  //还有一种比较抽象的写法:
  public Node la(Node head,Node o1,Node o2){
      if(head == null || head == o1 || head == o2){
          return head;//如果节点是空或者o1,o2其中一个是根节点,那根节点必是它们的最近公共祖先节点
      }
      Node left = la(head.left,o1,o2);
      Node right = la(head.right,o1,o2);
      if(left != null && right != null){
          return head;
      }
      return left != null ? left : right;
  }
  //这里就是使用了我们的二叉树解题套路:
  //我们可以列出所有可能 :
  /*
  1.o1是o2或者o2是o1的最低公共祖先
  	对于这个情况,如果头是o1,或者o2是头,那这个头就必是最低公共祖先.
  	如果不是头,那o1,o2就在子树上,如果o1与o2是互为公共最低祖先的,那其中一个子树肯定会返回空,并且另一个子树返回的必是o1或者o2
  2.o1和o2不互为最低公共祖先
  	当左边返回不为空和右边不为空就意味着,这个节点就是最初的汇聚点.
  */
  ```

  * 在二叉树中找到一个节点的后继节点

    具体如下 : 

    现有一棵二叉树节点类型如下 : 

    calss Node{

    ​	public int value;

    ​	public Node left;

    ​	public Node right;

    ​	public Node parent;

    ​	public Node(int val){

    ​		value = val;

    ​	}

    }

    该结构比普通二叉树多了一个指向父节点的parent指针,假设有一棵Node类型的节点组成的二叉树,树中每个节点的parent指针都正确的指向自己的父节点,头节点的parent指向null,值给一个在二叉树中的某个节点,请实现返回node的后继节点的函数.后继节点是指在中序遍历的时候,node的下一个节点叫node的后继节点.

    解法 : 如果没有这个指向父节点的指针,我们就需要对树进行一次中序遍历,然后得到一个序列,通过这个序列才能找到任意一个节点的后继节点.复杂度为O(N),当存在一个指向父节点的指针的时候,我们是否能够让复杂度降低到所需要找到节点的后继节点与它的后继节点的距离k的复杂度O(k)呢,也就是通过这个指针来优化我们的算法.

    ​		我们先观察一下一个节点的后继节点的分布情况:

    ​		1.节点有右树 : 此时右树的最左边的节点就是这个节点的后继节点

    ​		2.节点无右树 : 看它是不是它的父节点的左子节点,如果是那这个父节点就是它的后继节点.但是树中存在一个无后继节点的节点,也就是整棵树最右边那个节点.

    ```Java
    public Node getSNode(Node o){
        if(o == null){
            return o;
        }
        //当节点有右树
        if(o.right != null){
            //返回最左边的节点
            return getl(o.right);
        }else{
            //没有右子树的话,看它是不是的父节点的左子节点
            Node p = o.parent;
            while( p != null && p.left != o){
                o = p;
                p = o.parent;
            }
            return p;
        }
        
    }
    public Node getl(Node o){
        if(o == null){
            return o;
        }
        while(o.left != null){
            o = o.left;
        }
        return o;
    }
    ```

  * 二叉树的序列化与反序列化

    这里的序列化指把二叉树变成字符串的形式,反序列化指的是把字符串还原成二叉树.并且这个字符串只能生成一棵唯一的树,一棵树也只能生成唯一的一个字符串.

    解法 : 为了生成字符串,肯定是需要遍历所有的值的.所以对于树来说,就可以有前中后层(宽度)遍历四种方式进行序列化.所以我们只需要在前序遍历的时候加个字符串就可以了.反序列化的时候也是根据前序遍历的规律,先构建根,然后先后构建左右,

    ```Java
    //我们使用#来表示空,_来表示一个节点值的结束
    public String sbp(Node head){//前序遍历序列化
        if(head == null){
            return "#_";
        }
        String res = head.value + "_";
        res += sbp(head.left);
        res += sbp(head.right);
        return res;
    }
    public Node resbp(String tree){//反序列化
        String[] s = tree.split("_");//分割字符串,获取每个节点的值
        Queue<String> queue = new LinkedList<>();
        for(int i = 0;i != s.length;i++){
            queue.add(s[i]);
        }
        return reconpo(queue);//通过队列构建树
    }
    public Node reconpo(Queue<String> queue){
        String v = queue.poll();//弹出一个值
        if(v.equals("#")){//如果一出来值是null,那说明这个树寄了
            return null;
        }
        Node head = new Node(Integer.valueOf(v));//出来不是null,就构建根节点和左子树右子树
        head.left = reconpo(queue);
        head.right = reconpo(queue);
        return head;
    }
    ```

    

  * 判断一颗二叉树是不是另一颗二叉树的子树

  * 折纸问题

    一张长纸条,从中间对折,可以向着自己或者向外进行对折,请问对折n次厚,展开的纸条最上面的那条折痕朝向是什么?(朝向就是凹或者凸,面对你是凹下去的还是凸出来的).从上到下所有折痕的顺序是咋样的?

    

    问题分析 : 我们可以拿出一张纸条,自己这么折,假如我们拿一张纸条,然后朝向自己折,折四次,折的过程中,每折一次就展开看看边的朝向情况.我们会得到这样的结果:

    ------------------------------------边界----------------------------------------

    ------------------------------------4凸----------------------------------------

    ------------------------------------3凸----------------------------------------

    ------------------------------------4凹----------------------------------------

    ------------------------------------2凸----------------------------------------

    ------------------------------------4凸----------------------------------------

    ------------------------------------3凹----------------------------------------

    ------------------------------------4凹----------------------------------------

    ------------------------------------1凹----------------------------------------

    ------------------------------------4凸----------------------------------------

    ------------------------------------3凸----------------------------------------

    ------------------------------------4凹----------------------------------------

    ------------------------------------2凹----------------------------------------

    ------------------------------------4凸----------------------------------------

    ------------------------------------3凹----------------------------------------

    ------------------------------------4凸----------------------------------------

    ------------------------------------边界----------------------------------------

    我们会发现,每折一次,它都会在上一次的折痕两边产生对凹凸的折痕.它的结构是不是很像二叉树呢?没错,它可以写成二叉树结构的:

    ​																		       1凹

    ​																2凸          			2凹			

    ​														3凸      3凹	 	       3凸         3凹	

    ​											   4凸   4凹    4凸  4凹       4凸   4凹   4凸   4凹

​		如果我们把一个折痕的上面的新折痕作为这个折痕的左节点,那么我们对折n次后,最上面的那个折痕就是树的最左边的那个节点.而且左子树就是中间折痕的上面折痕.并且用中序遍历可以打印出所有折痕由上到下的顺序.

```java
public void printProcess(int i,int n,boolean down){
    //i表示节点的层数,N表示对折次数(也就是树的深度),这个down为true是为凹
	if(i>n){
        return;
    }
    printProcess(i+1,n,true);
    System.out.println(down ? "凹" : "凸");
    printProcess(i+1,n,false);
}

```

## 图相关

图是一种用途非常广泛的数据结构,地图,游戏里都是非常常用的.

**图的表达**

* 邻接表 : 记录每个节点的直接邻居

* 邻接矩阵 : 以二阶数组来记录图的布局,谁连着谁那个为止就用一个值来表示.或者用距离来表示(这种时候一般是边带权重的时候)

* 还有很多常用的图表示法,这里展示一个比较通用的:

  ```Java
  class Graph{
      public HashMap<Integer,Node> nodes;//点集
      public HashSet<Edge> edges;//边集
      public Graph(){
          nodes = new HashMap<>();
          edges = new HashSet<>();
      }
  }
  class Node<T>{//点
      public T value;
      public int in;//点的入度(指向自己的边数量)
      public int out;//点的出度(自己发射的边数量)
      public ArrayList<Node> nexts;//该点的直接邻居
      public ArrayList<Edge> edges;//该点发散的边
      public Node(T v){
          value = v;
          in = 0;
          out = 0;
          nexts = new ArrayList<>();
          edges = new ArrayList<>();
      }
  }
  class Edge{ 
      public int weight;//边的权重
      public Node from;//边的发散点
      public Node to;//边的指向
      //两条有向边互相指就是无向边了
      public Edge(int w,Node f,Node t){
          weight = w;
          from = f;
          to = t;
      }
          
      	
  }
  ```

**图的经典算法**

* 广度优先遍历

  思路 : 

  1. 利用队列实现
  2. 从原节点开始一次按照宽度进队列,然后弹出
  3. 每弹出一个节点,就把该节点所有没有进过队列的邻接点放入队列
  4. 直到队列变空

  ```Java
  //图的宽度优先遍历与二叉树的区别就是它可能右环,所以我们需要一种机制来避免陷入环中,也就是上面思路的第三点.
  public void bfs(Node node){
      if(node == null){
      	return;
      }
      Queue<Node> queue = new LinkedList<>();//准备队列
      HashSet<Node> set = new HashSet<>();//准备一个set,保证不会卡在环上
      queue.add(node);//加入开始节点
      set.add(node);//加入开始节点
      while(!queue.isEmpty){//如果队列不是空
          Node cur = queue.poll();//弹出一个节点
          Sysetm.out.println(cur.value);//遍历输出
          for(Node next : cur.nexts){//如果这个节点有直接邻居,遍历它,因为是广度优先(宽度优先),所以是遍历邻接表
              if(!set.contains(next)){//如果邻居没有进队列,表示还每遍历到它
                  set.add(next);//就加进set
                  queue.add(next);//加进对列
              }
          }
      }
  }
  ```

  

* 深度优先遍历

  思路:

  1. 利用栈实现
  2. 从原节点开始把节点按深度放入栈,然后弹出
  3. 每弹出一个节点,把该节点的下一个还没进栈的邻接点放入栈
  4. 直到栈为空

  ```Java
  public void dfs(Node node){
      if(node == null){
          return;
      }
      Stack<Node> stack = new Stack<>();
      HashSet<Node> set = new HashSet<>();
      stack.add(node);
      set.add(node);
      System.out.println(node.value);//先输出出发节点
      while(!stack.isEmpty){
          Node cur = stack.pop();//弹出
          for(Node next : cur.nexts){//遍历邻居节点
              if(!set.contains(next)){//邻居节点进栈了么?
                  //意思就是有深度就先不结束,先往深了走,其他路都不管,直到所有节点都遍历过一次
                  stack.push(cur);//重新把弹出了的压回去
                  stack.push(next);//没进的话给我进,上一行跟这一行可以保持遍历的路径.
                  set.add(next);//进了就打个标记
                  System.out.println(next.value);//遍历输出
                  break;//不看其他邻居了,因为是深度优先
              }
          }
      }
  }
  ```

* 拓扑排序

  拓扑排序很常用,最常见的地方就是编译顺序.就好比我们的Maven的依赖.这些依赖与我们的工程就形成了一个图.那么肯定是先编译这些依赖项才能把我们的工程给编译出来.在这个过程中,是不可以重复编译的.也就是不能产生循环依赖现象.所以拓扑排序的前提就是不能有环.拓扑排序就是把我们的图的节点按某个规则来进行排序,它是对于我们的顺序任务来进行排序的.

  思路 : 

  ```Java
  public List<Node> sortedTopo(Graph garph){
      //key : 某一个node
      //value : 剩余的入度↓
      HashMap<Node,Integer> inMap = new HashMap<>();
      //入度为0的点才可以进队列
      Queue<Node> zeroInQueue = new LinkedList<>();
      
      for(Node node : graph.nodes.values()){//遍历图中的点集
          inMap.put(node,node.in);//将每个点和它们对应的入度放进map,
          if(node.in == 0){//如果有节点入度是0的话直接让它进队列
              zeroInQueue.add(node);
          }
      }
      //拓扑排序的结果,依次加入result
      List<Node> result = new ArrayList<>();//放入排序好的节点
      while(!zeroInQueue.isEmpty){//遍历这个零入度节点表
          Node cur = zeroInQueue.poll();//从队列里出一个
          result.add(cur);//装进结果列表
          for(Node next : cur.nexts){//遍历 出来节点的直接邻居,因为节点出来了,所以出来节点的直接邻居节点的入度都少了1
              inMap.put(next,inMap.get(next)-1);//更新一下map里面节点的入度
              if(inMap.get(next) == 0){//如果有节点的入度是0了,就进队
                  zeroInQueue.add(next);
              }
          }
      }
      return result;
  }
  ```

* 无向图生成最小生成树的算法

  无向图的最小生成树是基于加权边的,最小生成树就是指生成的树的总权重最小并且不产生环的树.

  * kruskal算法

    思路:

    1. 将图中的边从小到大排序,原本的节点按没有连接的情况看.

    2. 然后遍历这些边,看看加入这条边后,节点有没有形成环,如果有环,那说明这条边不能要,就下一条边

    3. 把边遍历完了,也就得到了最小生成树

       ```Java
       public class MySets{
           //这个结构是咱的集合,就是记录那些个独立节点
           public HashMap<Node,List<Node>> setMap;//这个点对应的集合是谁
           public MySets(List<Node> nodes){
               //初始化的时候要把所有的节点整进来
               //刚开始每个节点都是一个独立的集合
               for(Node cur : nodes){
       			List<Node> set = new ArrayList<>();
                   set.add(cur);
                   setMap.put(set);
               }
           }
           
           public boolean isSameSet(Node from,Node to){
               //判断两个节点是否是一个集合的
               Node<Node> fromSet= setMap.get(from);
               Node<Node> toSet = setMap.get(to);
               return fromSet == toSet;
           }
           
           public void union(Node from,Node to){
               //把from所在的集合和to所在的集合合并成一个集合
               Node<Node> fromSet= setMap.get(from);
               Node<Node> toSet = setMap.get(to);
               //把to中的Node加到from对应的集合
               for(Node toNode : toSet){
                   fromSet.add(toNode);
                   setMap.put(toNode,fromSet);//每一个toNode,都对应的是fromSet集合,也就是合并了集合.
               }
           }
           
           public Set<Edge> kruskalMST(Graph graph){
               UnionFind unionFind = new UnionFind();//这玩意是并查集,也可以用上面的结构
               unionFind.makeSets(graph.nodes.values());
               PriorityQueue<Edge> queue = new PriorityQueue<>((o1,o2)->{
                   return o1.weight - o2.weight;
               });//用一个优先队列,按边权值从小到大排序,优先弹出小的
               for(Edge edge : graph.edges){
                   queue.add(edge);
               }
               Set<Edge> result = new HashSet<>();
               while(!queue.isEmpty){
                   Edge edge = queue.poll();//弹出小边
                   if(!unionFind.isSameSet(edge.from,edge.to)){//from和to是不是一个集合的
                       result.add(edge);//不是就加进去
                       unionFind.union(edge.from,edge.to);//合并集合
                   }
               }
               return result;
           }
       }
       ```
       
       
  
  * prim算法
  
    prim算法是以点来进行的,刚开始假设每一个点都是独立的,然后挑一个点作为最小生成树的点,从它开始挑边.
  
    ```Java
    public Set<Edge> primMST(Graph graph){
        PriorityQueue<Edge> queue = new PriorityQueue<>((o1,o2)->{
            return o1.weight - o2.weight;
        });//解锁的边进入最小优先队列
        HashSet<Node> set = new HashSet<>();//存放已经被加入的点.
        Set<Edge> result = new HashSet<>();//结果集
        for(Node node : graph.nodes.values()){//为啥随便挑一个点?因为可能存在森林这种情况,也就是如果我们的图不是连通的,那就会只能得到一小段的最小子树.
            //随便挑一个node开始挑边
            if(!set.contains(node)){
                set.add(node);
                for(Edge edge : node.edges){//看这个点有那些边,让它们加入优先队列
                    queue.add(edge);
                }
                while(!queue.isEmpty){
                    Edge edge = queue.poll();//弹出最小的那个边
                    Node toNode = edge.to;//获取那个边的to节点
                    if(!set.contains(toNode)){
                        //当这个to节点不在结果集里,说明这条边能处,加进结果集
                        set.add(toNode);//记录已经进来的边
                        result.add(edge);
                        for(Edge nextEdge : toNode.edges){
                            queue.add(nextEdge);//从加进来的这个新节点看边.
                        }
                    }
                }
            }
        }
        return result;
    }
    ```
  
* 图最短路径问题

  * Dijstra算法

    这个算法是常用的图最短路径算法.它的目的是找到指定起点到任意可达图节点的最短距离.

    但是这个算法不能在那种有累加和为负数的环的情况用,会导致在那个环上一直搁哪搞.

    思路 : 

    1. 刚开始初始化为自己到自己的距离为0,到其它可达点距离为正无穷或者一个非常大的值.比如有这样的一个图: A,B,C,D,E五个点,他们之间的边和权值:

       A B 3

       A C 15

       A D 9

       D C 7

       D E 16

       C E 14

       C B 2

       B E 200

       那么初始化就结果就是 : A离A0距离,A离其他都是无穷大

    2. 然后每次找到离这个点最近的点,也就是它自己(因为离自己0距离嘛),然后由这个点出发,看看由它出发的边,能不能让它与其他点的距离变小.比如从A开始嘛,有三条边,发现了一个A到B为3的边,发现现在的距离比当前的距离小,更新A到B的距离和边,然后又发现了A到C为15的边,比现在的小,更新A到C....用完了A点,就将它锁定.然后在其他的记录里选一个最小的,当前就是B点,因为它离A最小,然后从它找边,发现一个B到C,B到E,B到A,然后我们看这些边的情况,我们会发现B到A这个边,从A到B再到A的距离是3+3=6,有比当前更小么?没有,所以不更新,然后看B到C,从A到B到C是2+3=5,有比当前记录更小么?有,A到C是15,A到B到C是5,小,更新!B到E是200,A到E当前是无穷大,A到B到E是203,更新!B的记录处理完了,锁上;再继续要一个最小的C,按上面的方式来操作直到全部的点都锁上,我们就能找到A到达任意一个节点的最短距离是多少了.

    在上面的过程中,那个找比当前已存在路径更短的办法,叫做松弛.

    ```Java
    //从head节点到所有可达节点的最小距离
    //key表示从head到key点
    //value表示从head到key点的最小距离
    //如果在表中,没有value的记录,那么就意味着head出发到这个点的距离是无穷的,它们互不可达
    public HashMap<Node,Integer> dijkstral(Node head){
        HashMap<Node,Integer> distanceMap = new HashMap<>();//结果集
        distanceMap.put(head,0);//先把起点放进去
        
        HashSet<Node> selectedNodes = new HashSet<>();//记录已经计算得了最短距离的节点.
        Node minNode = getMinDistanceAndUnselectedNode(distanceMap,selectedNodes);//刚开始只有头,所以会把头得到,因为头离头是0距离.
        while(minNode != null){
            int distance = distanceMap.get(minNode);//获得当前距离开始节点最小的节点的距离
            for(Edge edge : minNode.edges){//从这个节点开始向外看它所有的边
                Node toNode = edge.to;//挑一条边和它对应的指向节点
                if(!distanceMap.containsKey(toNode)) {//如果这个节点在表里面是没记录的,那就意味着从开始点到这个点是正无穷的,并且现在有一条更短的路能到达这个节点,更新一波
                    //更新的时候要从开始节点到路过的节点的距离再加上这边的距离.
                    distanceMap.put(toNode,distance + edge.weight);
                }
                distanceMap.put(edge.to,Math.min(distanceMap.get(toNode),distance+edge.weight));//如果节点是存在的,那么就选择之前的距离和现在获得的距离更小的更新.
            }
            selectedNodes.add(minNode);//minNode已经检查完了,锁上
            minNode = getMinDistanceAndUnselectedNode(distanceMap,selectedNodes);//再从剩下的表里面去挑距离最短的,更新minNode进行下一次操作.
        }
        return distanceMap;
    }
    
    public Node getMinDistanceAndUnselectedNode(HashMap<Node,Integer> map,HashSet<Node> set){
    	//这个就是用来计算从起点到当前最小距离节点到需要到达的节点并且是没有被计算过的点的距离
        Node minNode = null;//离的最小的点
        int minDistance = Integer.MAX_VALUE;//记录最小距离
        for(Entry<Node,Integer> entry : map.entrySet()){//遍历map里的东西
            Node node = entry.getKey();//获取节点
            if(!set.contains(node) && distance < minDistance){//看看得到的节点的距离是不是在已经算好了并且是不是距离比当前的最小距离还要小.
                minNode = node;//是的话就更新一下记录
                minDistance = distance;
            }
        }
        return minNode;
        
    }
    ```

    对于我们当前的方法,是基于遍历的.原因就在于我们用的是语言给我们提供的工具类:优先队列类.在系统中的实现里,如果之前已经存在于其中的值发生了剧烈变化(从比较大的值变成了一个比较小的值),这个时候系统的实现里它是不会给我们重新把这个堆结构给搞成一个正确格式的.如果需要的话,它会进行全局遍历,跟全遍历没有啥区别,导致代价很高.它没有实现数据的自动上浮和下沉,所以我们是可以通过自己实现的堆结构去优化上面的迪杰斯特拉算法的.

    

    

    ## 前缀树与贪心

    **前缀树**

    啥是前缀树?先看个题目:

    一个字符串类型的数组arr1,另一个字符串类型的数组arr2.arr2中有那些字符,是arr1中出现的?请打印出来.arr2中有哪些字符,是作为arr1中某个字符串前缀出现的?请打印出来.arr2中有哪些字符是作为arr1中某个字符串迁回出现的?此外,请输出arr2中出现次数最大的前缀.

    那么啥是前缀树嘞?

    `前缀树`是`N叉树`的一种特殊形式。通常来说，一个前缀树是用来`存储字符串`的。前缀树的每一个节点代表一个`字符串`（`前缀`）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的`原始字符串`，以及`通往该子节点路径上所有的字符`组成的。它的一个具体例子是这样的:

    ![前缀树的一种形式](D:\Java学习笔记\picture\前缀树的一种形式.png)

在上图示例中，我们在节点中标记的值是该节点对应表示的字符串。例如，我们从根节点开始，选择第二条路径 'b'，然后选择它的第一个子节点 'a'，接下来继续选择子节点 'd'，我们最终会到达叶节点 "bad"。节点的值是由从根节点开始，与其经过的路径中的字符按顺序形成的。

值得注意的是，根节点表示`空字符串`。

前缀树的一个重要的特性是，节点所有的后代都与该节点相关的字符串有着共同的前缀。这就是`前缀树`名称的由来。

我们再来看这个例子。例如，以节点 "b" 为根的子树中的节点表示的字符串，都具有共同的前缀 "b"。反之亦然，具有公共前缀 "b" 的字符串，全部位于以 "b" 为根的子树中，并且具有不同前缀的字符串来自不同的分支。

前缀树有着广泛的应用，例如自动补全，拼写检查等等。

前缀树总的来说它还是一颗树,不过是一个N叉树.除了上图那个表示法,这还有一种经典表示法:

```Java
class TrieNode{
    public int pass;//表示这个节点经过了几次
    public int end;//表示是否结尾和结尾次数,一般0表示没结尾,1表示结尾了一次
    public TrieNode[] nexts;
    
    public TrieNode(){
        pass = 0;
        end = 0;
        next = new TrieNode[26];//以字符串都是英文小写为例子,表示有没有通向a-z的路
        //next[0]就表示a,如果里面有东西那就是有走向a的路,如果没有东西就是没有通向a的路.
        //如果想要更多类型的,可以用哈希表(Map) : HashMap<Char,Node> nexts
    }
}
class Trie{
    //构建一颗前缀树
    private TrieNode root;//根节点
    
    public Trie(){
        root = new TrieNode();
    }
    
    //向前缀树插入一个字符串
    public void insert(String word){
        if(word == null){
            return;
        }
        char[] chs = word.toCharArray();
        TrieNode node = root;//从根节点出发
        node.pass++;//经过了根节点,所以根节点的pass++
        int index = 0;
        for(int i = 0;i < chs.length;i++){//遍历字符
            index = chs[i] - 'a';//当前字符-'a'表示应该去走哪条路.也就是应经过nexts[几].
            if(node.nexts[index] == null){//如果这个地方没有东西,说明这个方向没有节点.
                node.nexts[index] = new TrieNode();//没有节点就在这个地方新键一个
            }
            node = node.nexts[index];//node移动到这个新创建的地方.
            node.pass++;//这个节点也经过了一次,pass++,也就是沿途的node的pass++
        }
        node.end++;//加完之后结尾1次,end++.
    }
    
    //在前缀树里面删一个字符串
    public void delete(String word){
        if(search(word) != 0){
            //确定树中确实加入果了word,才能把它删了.
            
            char[] chs = word.toCharArray();
            TrieNode node = root;//从头开始
            node.pass--;//根要--
            int index = 0;
            for(int i = 0;i<chs.length;i++){
                index = chs[i] - 'a';
                if(--node.nexts[index].pass == 0){//沿途的pass--
                    //如果--后到0了,那说明这个字符串和它的后序都没用了.全部都要删掉.
                    node.nexts[index] = null;//删,这一步如果是C++,要把后面的节点都遍历一遍进行对象析构或者free掉. 
                    return;
                }
                node = node.nexts[index];//如果对应字符位置经过次数--后不是0,就下一个
            }
            node.end--;//删完之后最后到达的那个结尾点的end--,表示这里少结尾了一个字符串(也就是删掉了.
        }
    }
    
    //从前缀树里查看某个字符串出现了几次
    public int search(String word){
        if(word == null){
            return 0;
        }
        char[] chs = word.toCharArray();
        TrieNode node = root;
        int index = 0;
        for(int i=0;i<chs.length;i++){
            index = nexts[index] - 'a';
            if(node.nexts[index] == null){//查的时候,查到它下面了,但是那个位置没有节点,这意味着我们没有在这个前缀树里加过这个字符串,就意味着要查的这个字符串没加进这个前缀树过.
                return 0;
            }
            node = node.nexts[index];
        }
        return node.end;//加入几次最后那个字符的end就是几次
    }
    
    //从前缀树种找出有几个是以指定字符串作为前缀的字符串
    public int prefixNumber(String pre){
        if(pre == null){
            return 0;
        }
        char[] chs = pre.toCharArray();
        TrieNode node = root;
        int index = 0;
        for(int i = 0;i<chs.length;i++){
            index = node.nexts[index]-'a';
            if(node.nexts[index] == null){//chs还没遍历完,要查的位置上就空了,说明没有以这个前缀开头的字符串.
                return 0;
            }
            node = node.nexts[index];
        }
        return node.pass;
    }
}
```

我们刚开始提出的那个题就可以直接以前缀树的结构来解决.



**贪心算法**

贪心是啥呢,就是贪.在某一个标准下,优先考虑最满足标准的样本,最后从考虑最不满足标准的样本,最终得到结果的方法,就称为贪心.

也就是说,我们对于一个问题,先从找到某种意义上的局部最优解,将这些局部最优解拼凑成整体的最优.类似于分治思想.

贪心在业务上也是非常常用的.

贪心的经典题目:

* 一些项目要占用一个会议室进行宣讲.会议室不能同时容纳两个项目的宣讲,给你每一个项目开始的1时间和结束的时间(可能给你一个数组,里面是一个个具体的项目),由你来安排宣讲的日程,要求会议室能够进行的宣讲场次最多.求出这个宣讲场次最多的值.

  对于这个问题,我们会得到一些贪心策略,比如:

  * 时间最早开始的会议优先
  * 时长最短的会议优先
  * 会议结束时间早的优先
  * .....

  对于以上的贪心策略,我们可以通过举反例的方式来排除无法获得最优解的策略,比如上面列出的三条,时间最早的不一定是最短的,要是这个会议是贯穿一整天的,那肯定得不到最优解,所以第一条策略不行;第二条也是,如果时长最短的有好几个,但是存在重叠时间,就导致只能选一个,但是这些短的其实可以选多个,所以第二个也不行;第三却是可以的,所以这里来讲第三个策略就是能得到最优解的策略.

  第三个贪心策略的代码实现:

  ```Java
  class Program{
      //会议类,包含开始时间和结束时间
      public int start;
      public int end;
      public Program(int s,int e){
          start = s;
          end = e;
      }
  }
  
  public int bestArrange(Program[] progarms,int timePoint){//timePoint就是会议室可以开始分配的时间点
      Arrays.sort(progarms,(p1,p2)->{return p1.end - p2.end});//按会议结束时间从小到大排序
      int result = 0;
      for(int i = 0;i<programs.length,i++){
          if(timePoint <= programs[i].start){//当前会议开始时间在会议室能够分配的时间段
              result++;
              timePoint = programs[i].end;//以会议最快结束的时间为结束,进行下一次选择.
          }
      }
      return result;
  }
  ```

  在上面的例子可以看到,使用贪心思想去解决问题,最重要的就是要找到合适的贪心策略.贪心策略在实际使用的时候,对于一个题来讲,策略是有很多的,而我们要选取最合适的那个.我们要如何去选择呢?这也是有套路的.

  * 实现一个不依靠贪心策略的解法X,一般用暴力解法.
  * 然后把自己想的贪心策略,与解法X配合对数器进行验证,通过验证就可以得到正确的贪心策略.
  * 在实际开发和笔试的时候不需要去纠结贪心策的数学证明.
  * 数学证明非常复杂,首先需要证明我们的贪心策略的比较策略是否是可行的(该策略是否有传递性),在证明过程中需要把一些平时的操作转换成数学模型,有时候是非常麻烦的.需要数学功底非常强大才行.然后还要需要证明整个贪心策略的正确.

  贪心策略在实现的时候经常用的技巧:

  * 根据某个标准建立一个比较器来排序
  * 根据某个标准建立一个比较器来组成堆

  在贪心算法里,排序和堆是用的最多的,它俩总是能实现很骚的操作.它俩算是最常用的贪心技巧

* 一块金条切成两半,是需要花费长度和长度数值一样的钱的,如长度为20的金条,不管切成长度多大的金条,都需要花费20的钱.现有一群人想分整块金条,怎么分最省钱?

  比如给定数组[10,20,30],表示一共三个人,并且整块金条长度为10+20+30=60,且需要分成10,20,30三个部分.如果先把60分成10和50,再由50分出20和30,一共需要110块钱,而把60先拆成30和30,再由30拆成10,和20,就只需要90块钱.

  要求输入一共数组,能够输出代价最小的代价值.

  解法 : 这题就是经典的哈夫曼编码的实现,我们把数组都扔进一共小根堆(最小优先队列),然后一次弹出两个数,对这个两个数累加,然后把累加结果放回小根堆.依次这么做,直到小根堆里只剩一个.剩下的这一个数,就是总代价.这里的贪心策略就是有局部到整体,从最后一次需要的最小代价往上和,和到最后就是总的最小代价.

  ```Java
  public int leesMoney(int[] arr){
      Queue<Integer> pq = new PriorityQueue<>();
      for(int i = 0;i < arr.length;i++){
          pq.add(add[i]);
      }
      int sum = 0;
      int cur = 0;
      while(pq.size() > 1){
          cur = pq.poll() + pq.poll();
          sum += cur;
          pq.add(cur);
      }
      return sum;
  }
  ```

* 输入一整数数组costs和profies,一正数k和m,含义:costs[i]表示i号项目的花费,profites[i]表示i号项目扣除花费后还能挣到的钱,也就是i号项目的利润.k表示只能串行做k个项目,m表示初始资金.要求 : 输入以上四个数据,你每做完一共项目,可以马上获得收益,可以马上支持你做下一个项目.请输出你能够获得的最大收入.

  解法 : 刚开始把所有的项目按照花费加入一个小根堆,然后将当前可用做的项目弹出到一个按利润的一共大根堆.然后从这个大根堆弹出一个能做的项目,更新初始资金,然后再去小根堆弹出能够做的项目到大根堆里,然后继续挑直到次数到达m即可,最后的初始资金就是可以获得的最大收入.这个题目的贪心就是先贪成本最小再贪利润.

  ```Java
  class Xm{
      public int cos;
      public int pro;
      public Xm(int c,int p){
          cos = c;
          pro = p;
      }
  }
  public int findMaximizedCapital(int costs[],int[] profies,int k,int w){
      Queue<Xm> minCost = new PriorityQueue<>((x1,x2)->{return x1.cos-x2.cos});
      Queue<Xm> maxProfit = new PriorityQueue<>((x1,x2)>{return x2.pro - x2.pro});
      for(int i = 0;i<costs.length;i++){
          minCost.add(new Xm(cos[i],pro[i]));
      }w
      for(int i = 0;i < k;i++){
          while(!minCost.isEmpty() && minCost.peek().c <= w){
              maxProfit.add(minCost.poll());//从小根堆里拿出所有当前能做的项目
          }
          if(maxProfit.isEmpty){
              return w;//如果大根堆已经空了,当前的钱就是已经赚的最多的了.也就是能做的项目还没有k个这么多,或者我们的钱不够做k轮前的某一个项目,只能直接卷钱跑路.
          }
          w += maxProfit.poll().p;
      }
      return k;
  }
  ```

* 一共数据流中,随时可用取得的中位数.也就是说,可以不断给数字,然后程序可以返回给你中位数.这个数字是扔进一个数组或者集合里面去的.

  解法 : 用堆,一个大根堆,一个小根堆,用户给数字,判断这个数字是否小于等于大根堆的对顶,如果是,那么当前数组进入大根堆,如果不是,这个数字就进小根堆.然后判断大根堆和小根堆的大小,如果它们的大小差距超过了1,如果是大根堆的数量大于小根堆数量,就弹出大根堆的堆顶进到小根堆.如果是小根堆大小大于大根堆,就弹出小根堆的堆顶进大根堆.此时数量大的那个堆的堆顶就是中位数,如果两个堆的大小一致,那中位数就是两个堆的堆顶相加除以2.

  这个题目并不属于贪心算法.是堆的一种骚操作问题.

* N皇后问题

  N皇后问题是非常经典的一个问题.它是指在N*N的棋盘上放上N个皇后,要求任何两个皇后之间不同行,不同列.也不能在一条斜线上.给定一个整数n,求n皇后的摆法有多少种.

  思路 : 暴力递归.总的思路如图:

  ![N皇后问题](D:\Java学习笔记\picture\N皇后问题.jpg)

  就是每一行定一个位置,然后继续往下看,一个位置一个位置尝试.

  ```Java
  public int num1(int n){
      if(n == 1){
          return 0;
      }
      int[] recore = new int[n];//recore[i]的值表示i行的皇后放在第几列
      return process(0,recore,n);
  }
  //i表示目前皇后所在的行数
  //record[0..i-1]表示之前的行,放过皇后的位置;record[0..i-1]的皇后,任意两个皇后都不共行/列/斜线
  //n是总行数
  public int process(int i,int[] record,int n){
      if(i == n){//当前行来到了终止了的行(最后一行的下一行),最后一行肯定只有一种摆法
          return 1;
      }
      int res = 0;
      for(int j = 0;j < n;j++){
          //尝试列数
          if(isValid(record,i,j)){
              //当前第i行的皇后,放在j列,会不会和之前(0...i-1)的皇后共行共列或者共斜线.
              //如果是,就无效
              //如果不是,就有效
  		   record[i] = j;//加入当前的皇后放在第i行第j列
              res += process(i+1,record,n);
          }
      }
      return res;
  }
  public boolean isValid(int[] record,int i,int j){
      //record[0..i-1]要看,record[i]是无效的,不用看
      for(int k = 0;k < i;k++){
          //之前的某个在k行的皇后
          if(j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)){
              return false;
          }
      }
      return true;
  }
  ```

  以上的方法解决N皇后问题的复杂度常数项较大,我们可以通过位运算来对它进行常数项上的极致优化.但是它的复杂度指标是没法优化了的.
  
  N皇后问题的用途是为了评估大规模集群的计算能力的.



## 暴力递归

暴力递归就是对于一个问题的全部情况的尝试.

* 把问题转换为规模缩小了的同类问题的子问题
* 有明确的不需要继续进行递归的条件(base case)
* 有但得到了子问题的结果之后的决策过程
* 不记录每一个子问题的解,尝试才是最重要的.

暴力递归是一个必须掌握的操作,因为我们必须要学会怎么去尝试问题的所有情况.这是动态规划的基础.

我们上面的八皇后问题,说是回溯,其实就是在做暴力递归剪枝.很多奇怪的名词都是用暴力递归剪枝的方法的.

**递归三要素**

* 明确函数的目的

  这个过程是非常重要的,必须要明确我们的函数到底是为了做什么而写出来的.在使用递归的过程中，你也要准确的定义这个函数到底要干什么，记住是准确定义，举个例子，数学中常用的f（x），但是在不同的场合它所表达的意义也不同，比如在平面几何中，一般代表纵坐标，给定一个确定x，必然会有一个确定的纵坐标，这其实就是一个准确的定义，同样在实际问题，同样需要准确的定义：比如在反转链表中我可以定义：f（n）将有n个节点的链表反转，那么f（n-1）为将有n-1个节点的链表反转。

  ```C
  struct list{
      int id;
      struct list* next;
  }
  struct list* revelist(struct list* head){
      struct list* phead;//设为反转后的头指针
      //中间过程代码...
      
      return phead;
  }
  ```

  

* 寻找递归结束条件

  在什么时候结束迭代过程?这是编写迭代程序必须考虑的问题。不能让迭代过程无休止地重复执行下去。迭代过程的控制通常可分为两种情况：一种是所需的迭代次数是个确定的值，可以计算出来；另一种是所需的迭代次数无法确定。对于前一种情况，可以构建一个固定次数的循环来实现对迭代过程的控制；对于后一种情况，需要进一步分析出用来结束迭代过程的条件”
  在递归中我们也加入一个调节用以结束递归过程，而且可以采用迭代过程控制的思想，那么反转链表过程中，我们无法确定递归的次数，那么我们仔细分析，发现当头节点所指向的下一个结点为NULL时递归结束,同时需要保护当传入参数时为NULL时直接返回

  ```C
  struct list{
      int id;
      struct list* next;
  }
  struct list* revelist(struct list* head){
      if(head == NULL || head->next == NULL){//递归结束条件
          return head;
      }
      struct list* phead;//设为反转后的头指针
      //中间过程代码...
      
      return phead;
  }
  ```

  

* 寻找函数的等价关系式

  我们可以借用迭代关系中的方法，“所谓迭代关系式，指如何从变量的前一个值推出其下一个值的公式（或关系）。迭代关系式的建立是解决迭代问题的关键，通常可以使用递推或倒推的方法来完成”递归关系式也同样如此；

  分析：如果我们要将有10个节点的链表反转，那么我们只需要将9个节点反转，再将第二个节点第一个节点反转；而想要将9个节点反转，只要将9个节点中剩余的8个节点反转，再将9个节点中的第一个节点和第二个节点反转即可；而要反转8个节点，只需要将剩余的7个节点反转，再将9个节点中的第一个节点和第二个节点反转即可；以此类推，直到结束调节；

  因此，可以得到递推关系：

  想要反转n个节点的链表，只需将剩余的n-1个节点反转，然后将第二个节点和第一个节点反转即可

  ```C
  struct list{
      int id;
      struct list* next;
  }
  struct list* revelist(struct list* head){
      if(head == NULL || head->next == NULL){//递归结束条件
          return head;
      }
      struct list* phead,curlist;//设为反转后的头指针和一个辅助变量
      //中间过程代码...
      phead = revelist(head->next);//反转头节点以外的节点(也就是先反转n-1个节点)
      curlist = head->next;//反转头节点
      curlist->next = head;
      head->next = NULL;
      
      return phead;
  }
  ```

  

* 汉诺塔问题

  就是有三根杆子,然后最左边的杆子上有N个圆盘,这些圆盘由小到大从上到下排着.现在我们需要把这些圆盘按原来的顺序移动到最右边的杆子上,移动过程中,大圆盘不可以放在小圆盘上.求N层汉诺塔移动到右边的最小步数.

  问题分析 : 如果我们先不看杆子,那这个问题就是 : 把1-N个圆盘从from位置移动到to位置. 过程就 : 1.先把1-N-1移动到other(也就是中间那个杆子上);2.然后把第N个放到to上;3.最后把1~N-1圆盘放到to圆盘上;就结束了.

  ```Java
  public void func(int i,String start,String end,String other){
      if(i == 1){
          System.out.println("Move 1 from " + start + " to " + end);
      }else{
          func(i-1,start,other,end);//把1-N-1的圆盘的最大圆盘也就是底从start移动到other上去.
          System.out.println("Move " + i + " from " + start + " to " + end);
          func(i-1,orther,end,start);//把1~N-1的圆盘的最大的圆盘也就是底从other移动到to.
      }
  }
  ```

  在进行递归分析的时候,我们千万不要去思考全局情况到底是什么样的,而是应该专注于局部的递归.因为全局的规模很大,我们不可能想清楚的,只会影响我们的判断.

* 输出字符串的全部子串

  比如字符串 abc ,它的全部子串的获取方式就是这样的 : 从第一个字符开始,每一个字符都有要和不要两个选择,全部穷举就可以得到它的所有子串.

  ```Java
  public void process(char[] str,int i,List<Character> res){//当前来到i位置,对于这个位置的字符由要和不要两条路.
      if(i == str.length){
          printList(res);//打印之前的结果
          return;
  	}
      List<Character> resKeep = copyList(res);//保留当前位置字符的集合
      resKeep.add(str[i]);//要当前字符
      process(str,i+1,resKeep);//当前位置字符是要的路
      List<Character> resNoInclued = copyList(res);//不保留当前位置字符的集合
      process(str,i+1,resNodeInclude);//当前位置字符不要的路
  }
  ```

* 打印一个字符串的全部排列

  就是打印一个构成字符串的字符的全排列.

  ```Java
  public void process(char[] chs,int i,ArrayList<String> res){
      if(i == chs.length){
          res.add(String.valueOf(chs));
      }
      boolean[] visit = new boolean[26];//加入字符只有一种类型的(大写/小写)的
      for(int j = i;j < chs.length;j++){
          if(!visit[chs[j] - 'a']){//这个if就是做剪枝的,也就是我们没有试过某个字母的时候才来进行尝试.试过了就把它标记为已记录过,这个if就是做分支限界的.
              visit[chs[j] - 'a'] = true;
              swap(chs,i,j);//交换str[i]和str[j]位置的字符
          	process(chs,i+1,res);//这里只是计算i后面的字符换过来后由多少种情况
         		swap(chs,i,j);//还原交换前的状态.
          }
      }
  }
  ```

* 给定一个整型数组arr,代表数值不同的纸牌排成一条线,玩家A和玩家B依次拿走每张纸牌.规定玩家A先拿,玩家B后拿,当每个玩家每次只能拿走最左或者最右边的牌.玩家A和玩家B都贼寄吧精明.请返回最后获胜者的分数.

  比如: 给一个arr[1,2,100,4];开始的时候,A只能拿1或4,如果开始时A拿了1,则排列变为[2,100,4],此时B可以拿走2或者4,然后继续轮到A....;如果一开始A拿的是4,那么B就可以拿100了.A作为一个聪明人刚开始肯定不会拿4,因为拿4后B将拿走100,然后赢下,所以A如果先拿了1,那么接下来就是A赢,并返回100.如果给的arr是[1,100,2],那么对A来说,不管拿什么,B拿都是100,都会输.

  前面的题我们都是从i开始从左往右依次尝试.这是一种非常常用的试法.而这题不太一样.
  
  思路 : 我们可以在一个范围内去尝试 : int f(arr,l,r) :表示在arr的l到r处进行尝试,结束条件就是当l==r的时候,只能选一张牌.拿走左侧的最大分数就是a[l] + s(arr,l+1,r);也就是先手得到的最大分数与后手获得的最大分数.这就分为两个情况,因为刚开始是可以选左侧或者右侧的,所以我们可以都试一遍,最后就是比较f(arr,l,r) + s(arr,l+1,r)和f(arr,l,r) + s(arr,l,r-1);哪个大.而这个后手函数,它也有两个情况,如果r==l,我还是后手,就只能啥都拿不到,返回0;如果不是的话,对方会先手,先手肯定要拿了最大的,所以只会留给我分数最低的情况,所以就后手的结果应该是f(arr,l+1,r)与f(arr,l,r-1)这两个之间剩下的最小的.
  
  ```Java
  public int f(int[] arr,int l,int r){
      if(l == r){
          return arr[l];
      }
      return Math.max(arr[l] + f(arr,l+1,r),arr[r] + f(arr,l,r-1));
  }
  public int s(int[] arr,int l,int r){
      if(l == r){
          return 0;
      }
      return Matn.min(f(arr,1+l,r),f(arr,l,r-1));
  }
  public int whowin(int[] arr){
      if(arr == null || arr.length == 0){
          return 0;
      }
      return Math.max(f(arr,0,arr.length-1),s(arr,0,arr.length-1));
      //f就是先手的玩家A,s就是后手的玩家B.
  }
  ```
  
* 给你一个栈,请你逆序输出这个栈.不可以使用额外数据结构.

  思路 : 为了逆序栈,我们肯定要想办法把栈底给它特么的弄出来.为了把这个栈底给弹出来,我们必须先把栈底前面的东西都弹出来才行.然后再把栈底压回栈.整个过程就是这样.

  在弹出栈底的最后一步,肯定就是栈底弹出来,然后栈变成空.这个栈空就是递归结束条件.

  ```Java
  public int f(Stack<Integer> stack){
      int result = stack.poll();//弹出栈底(假设是最后一步)
      if(stack.isEmpty){//栈底弹完了,栈空,停
          return result;
      }else{
          int last = f(stack);//如果不是栈底,就把栈底前面的先弹出来.找到栈底
          stack.push(result);//把不是栈底的东东压回去
          return last;
      } 
  }
  public int reverse(Stack<Integer> stack){
      if(stack == null){
          return;
  	}
      int i = f(stack);//获取当前栈的栈底
      reverse(stack);//对剩下的栈做逆序
      stack.push(i);//把栈底放回栈里面
  }
  ```

* 规定数字1和A对应,2和B对应,3和C对应...26和Z对应.那么一个数字字符串比如111,可以转换为AAA,或者AK,KA.给定一个只有数字字符组成的字符串str,放回有多少转化结果.

  思路 : 对于一个数字字符串,从0到i-1的位置假设我们已经做好了尝试和决定,从i开始我们可以进行决策.举个例子 : 对于字符串 1121来说,比如0-1位置我们已经决策完毕了.现在从2位置开始对后序的字符进行决策,对于位置2的数字2来说,从它开始可以选择让2直接去对应一个B,也可以让位置2和位置3的21变成U.而且对于i位置来说,如果i位置的字符是1或者2,它可以跟i+1去进行组合决策,而如果i位置的数字是3-9就只能做一个决策,也就当前位置直接进行转换单个字符.如果i位置是0,那这个字符是没法转换的.

  ```Java
  public int process(char[] str,int i){
      //i指0~i-1位置已经做好决定了
      //从i位置开始找后序的决策结果
      if(i == str.length){
          return 1;//i是最后一个位置,那就只有一种决策
      }
      if(str[i] == '0'){
          return 0;//如果之前做的决策后,i位置是0,说明前面的决策无效了
      }
      if(str[i] =='1'){
          int res = process(str,i+1);//i自己作为单独的部分后序有多少种方法
          if(i + 1 < str.length){
              res += process(str,i+2);//i和i+1共同作为单独的部分,后序有多少种方法
          }
          return res;
      }
      if(str[i] = '2'){
          int res = process(str,i + 1)//i自己作为单独的部分后序有多少种方法
          if(i + 1 < str.length && (str[i + 1] >= '0' && str[i+1] <= '6')){
              res += process(str,i+2);//i和i+1共同作为单独的部分,后序有多少种方法
          }
          return res;
      }
      return process(str,i+1);//如果i部分不是1和2,那就是3-9,这样的话这个位置只有一种决策.
  }
  ```

* 给定两个长度都为N的数组weight和values,weight[i]和values[i]分别表示i号物品的重量和价值.给定一个整数bag,表示一个能够载重bag的袋子,你装的物品不能超过这个重量.返回你能装下最多的价值.

  思路 : 从左往右一个一个货物要或不要试,停止条件就是重量到达bag.

  ```Java
  public int process(int[] weights,int[] values,int bag,int i,int alreadyweight){
      if(alreadyweight > bag){
          return 0;//如果再加货的重量加上之前的已经超重了,就不能再选了.
      }
      if(i == weights.length){
          return 0;//没货加了,也没得选了.
      }
      return Math.max(process(weights,values,bag,i+1,alreadyweight),//不选当前货
       values[i] + process(weights,values,bag,i+1,alreadyweight + weights[i]));//选择当前货
  }
  ```

## 哈希函数和哈希表

**哈希函数**

* 输入域无穷,输出域有穷.

比如经典的MD5和SHA1算法,它们就是经典的哈希算法.前者的返回值范围是0-2的64次方-1的范围,后者返回值的范围是0-2的128次方-1.它们一般都是返回一个16长度的字符串,这个字符串有前面范围那么多的可能性.

* 相同的输入,输出一定是相同的.

也就是说哈希函数是不存在随机成分的.

* 有可能会导致哈希冲突,也就是不同的输入产生了相同的结果.虽然哈希冲突出现的概率极低,但它是存在的.
* 离散性

对于哈希函数有一个很重要的性质 : 对于n个数,对于这些数取相同的模的哈希是均匀的.

有个题 : 请在给定1G空间的限制下,找出长度为40亿数组中出现次数最多的数.

对于这个题我们可以用map来记录每个数出现的次数,但是限制了空间,所以我们没法用map来解决这个问题.此时就可以使用哈希函数来解决该问题.对于数组中的每个数,为每个数都进行一次哈希,得到对应的哈希值,然后对哈希值取个100模.模完后这个哈希值肯定是一个0-99的数,对于这些对应的数,它们所含有的数量是均匀的.也就分成了100个小的文件.然后为每一个数组用哈希表来统计.

**哈希表**

哈希表的实现就跟上面那个题类似.就是通过哈希函数对键进行哈希和模操作,然后把这个键和它对应的值放在一个数组里面放上对应的位置.而数组的长度根据前面加入键的链的长度进行扩容.





## 经典算法

### 字符串匹配算法

#### KMP



#### BM



### 字符串的最长回文子串

#### Manacher



## 解题技巧

#### 滑动窗口



#### 单调栈
