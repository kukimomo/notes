# C++基础

### 函数

* 函数的声明

  函数可以声明多次,但是只能有一次定义.

  * 函数可以在一个cpp里面声明和定义
  * 函数也可以在头文件里声明,在cpp文件里面定义.
  * 要使用函数的时候只需要去包含这个头文件就可以使用这个函数了.
  
* 函数的默认参数

  * 函数的形参列表的形参是可以有默认值的
  * 语法:返回值类型 函数名 (参数 = 默认值,.....){}
  * 注意事项
    * 如果某位置有了默认参数,那么从这个位置往后的参数都必须指定默认值
    * 如果函数分位置声明和定义的话,那么函数声明有默认参数的话,那这个函数的定义就不能再写默认参数了.或者反之,即默认参数是不可以重定义的.

* 函数占位参数

  * 函数的形参列表可以有占位参数,用来做占位,调用函数的时候必须填补该占位参数
  * 语法: 返回值类型 函数名 (数据类型,数据类型 参数名){},比如 void function(int,int a,int b){},就是可以不用写参数名称
  * 占位参数可以有默认参数,直接后面=多少就可以了.
  * 占位参数主要用在重载运算符上.

* 函数的重载

  * 多个函数名可以相同

  * 函数重载的条件

    * 同一个作用域下(在一个文件下/同一个类里面)
    * 函数名称相同
    * 函数**参数类型不同**或者**参数个数不同**或者**顺序不同**
    * 函数返回值不作为函数重载的条件

  * 注意事项

    * 引用作为函数重载的条件

      void func(int& a)与void func(const int& a)是算重载的,并且传入一个变量的话它会调用void func(int& a)函数.如果传入一个字面量它会调用void func(const int& a),

    * 函数重载在函数有默认参数的时候

      void func(int a ,int b = 10)与void func(int a)是不算重载的,会报错,因为调用如果只传入一个参数,就会导致两个函数都能调用,就会导致爆炸.

### 指针

指针的基本概念

* 程序可以通过指针来间接访问内存
* 内存编号是从0开始的一堆16进制数值
* 指针变量存储的是一个地址,也就是指针变量就是一个地址

指针的声明和定义

* 指针的声明:   数据类型 *指针变量名
* 指针的定义:   数据类型 *指针变量名 = 某个地址;
* 对于变量 : &变量名 就可以获取一个变量对应的地址值.指针变量的值就是地址值

指针的使用

* 解引用
  * *指针变量名 :表示对指针解引用,找到指针指向的内存中存储的实际数据.

指针所占的内存

* 在32位的环境下,不管什么类型的指针,所占内存都是4个byte,64位就占8位.

空指针和野指针

* 空指针

  *  空指针: 数据类型 * 指针变量 = NULL;或者nullptr

  * 指针变量指向内存中编号为0的空间,那这个指针变量就是空指针
  * 用途: 初始化指针变量
  * 空指针指向的内存是不可以访问的(0-255之间的内存编号是系统的,我们无法操作)

* 野指针
  * 指针变量指向非法的内存空间,那这个指针变量就是个野指针
  * 非法的内存空间指的是不是我们申请的内存.不是我们申请的内存空间我们是无法进行访问的.
  * 在程序中,野指针是需要避免的,它会导致我们的程序崩溃

const指针

* const修饰指针----常量指针
  * const 数据类型 * 指针变量名; 这个就是给常量指针了.
  * 特点
    * 常量指针的指向可以修改,就是它保存的地址可以换
    * 指针指向的值不可以更改,就是它地址对应的东西不可以变
* const修饰常量----指针常量
  * 数据类型 * const 指针变量名;这个就是指针常量了
  * 特点
    * 指针常量的指向不可以修改,就是它保存的地址是不可以变的
    * 指针指向的值是可以改的,就是它地址对应的东西是可以变的
* const即修饰指针又修饰常量
  * const 数据类型 * const 指针变量名; 
  * 特点
    * 这种指针的指向和它指向的内容全都不能改.

指针与数组

* 利用指针是可以访问数组中的元素的

  ```C++
  int main(){
      int arr[10] = {1,2,3,4,5,6,7,8,9,0};
      int* p = arr;//数组名就是数组的第一个元素的地址
      for(int i = 0; i < arr.lenth;i++){
          std::sout<<*p<<std::endl;//解指针
          p++;//地址向后偏移4个字节
      }
      //最后输出1234567890
  }
  ```

指针与函数

* 当指针作为函数的参数的时候

  当函数参数是值传递时,实际参数是不会被改变的.

  而当指针作为函数的参数的时候,就是传入实参的地址了,此时修改对应的值,就会导致对应实参的变化. 

案例:写一个函数,用来对输入的数组进行冒泡升序排序.

```C++
void swapNum(int* a,int* b){
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

void arrMaopao(int* arr, int len){
    int* p = arr;
    for (int i = 0; i < len - 1; i++){
        for (int j = 0 ; j < len - i ; j++){
            if (*p < *(p + j)){
                swapNum(p,p+j);
            }
        }
        p++;
    }
}
```

### 结构体

结构体属于用户自定义的数据类型,允许用户存储不同的数据类型

定义

* 语法: sturct 结构体名 {结构体成员列表};

使用

* struct 结构体名 变量名;
* struct 结构体名 变量名 = {成员1值,成员2值}
* 定义结构体的时候顺便创建一个结构体变量: 定义的时候:struct 结构体名 {}结构体变量名;
* 使用结构体中的成员: 结构体名.属性名
* 给结构体中的成员赋值: 结构体名.属性名 = 属性值;
* 上面那些struct可以省略,但是留着我们可以知道这个类型是一个结构体而不是一个类



**结构体数组**

就是一个数组里面的数据类型可以是结构体,

定义

* struct 结构体名 数组名[数组长度] = {{结构体成员值...},{},{}....};

使用

* 就是跟普通数组一样的使用方法



**结构体指针**

作用: 通过指针访问结构体内的成员

使用操作符->可以通过结构体指针访问结构体内的成员

定义

* struct 结构体名称 *指针变量名;
* struct 结构体名称 *指针变量名 = &某个结构体变量;

使用

* 指针变量名 -> 结构体成员名;



**结构体嵌套**

结构体中的成员可以是另一个结构体

使用

* 结构体.包含的结构体.包含的结构体的成员
* 结构体.结构体成员



**结构体作为函数参数**

将结构体作为参数向函数中传递

* 值传递

  函数返回类型 函数名(结构体类型名 结构体变量名,参数列表....){}

* 地址传递

  函数返回类型 函数名(结构体类型名 *结构体变量名,参数列表....){}



**结构体中的const**

const在结构体里也是防止误操作的.

结构体中const的使用场景

* 如果在函数中通过值传递来进行结构体成员的一些操作,但是这个函数要被使用很多次,就会复制很多份形参,浪费内存,我们可以改成地址传递,就能节省很多内存了,但是地址传递又存在隐患,就是在函数里修改东西的话也会导致实参改变,原来我们是不想改的.我们就可以在函数形参列表的结构体指针变量类型前面加上const,就能够防止你修改这个传入形参的值: 函数定义...(const 结构体类型名 *结构体变量名,形参列表.....){}

## 核心

### 内存分区模型

* 代码区

  存放函数体的二进制代码,由操作系统进行管理

* 全局区

  存放全局变量与静态变量还有常量

* 栈区

  由编译器自动分配释放,存放运行的线程,里面都是栈帧,栈帧里面有局部变量等

* 堆区

  由我们进行手动分配和释放,如果不手动释放,程序结束时由操作系统回收.

* 数据分区的意义:每个区域的生命周期都不一样,能够灵活分配

在程序编译后,生成了一个exe可执行程序,未执行该程序前分为两个区域

* 代码区:
  * 存放CPU执行的机器指令
  * 特点
    * 代码区是共享的,共享的目的是对于被频繁执行的程序,只需要在内存中有一份代码即可
    * 代码区是只读的,只读的目的是为了防止程序意外的修改了程序指令
* 全局区
  * 存放全局变量和静态变量以及常量区
  * 该区域的数据在程序结束后由操作系统释放
  * 局部变量,const局部变量也不在全局区

当exe程序运行后

* 栈区:
  * 由编译器自动分配释放,存放函数的参数值,局部变量等.
  * 不要返回局部变量的地址,栈开辟的数据会被编译器自动释放.
* 堆区:
  * 由我们进行内存分配与释放的,如果不手动释放,里面的东西会在程序结束时由操作系统进行回收
  * 主要通过new关键字进行申请空间.
  * 在一个方法里面new出的东西,用一个指针类型变量来接受它,这个指针变量仍然是在栈上的,但是new出来的东西是可以返回来的,它一直都指向堆区我们分配的那块内存,直到我们手动把它delete了

**new关键字**

new关键字常用来进行开辟内存空间,它一般会返回一个开辟空间类型的地址,也就是指针

比如: new int(10),它会返回一个 int*类型的东西.

* 使用

  * 申请一块单类型的内存:  数据类型* 指针变量名 = new 数据类型;
  * 申请一块数组空间(连续空间): 数据类型 *指针变量名 = new int[数组长度];

  * 内存释放: delete 指针变量名;
  * 释放连续内存 : delete[] 指针变量名;

### 引用

引用的作用就是给变量取别名

* 使用

  * 要引用变量的数据类型& 别名 = 要引用的变量名;
  * 别名和原来的变量名操作的都是同一块内存.
  * 引用必须在声明时被初始化
  * 引用被初始化之后不可以被改变,引用之间可以互相赋值,但是不可以再去引用其他的变量名.
  * 引用必须引用一块合法的内存空间,比如int& a = 10这样是不行的,10是一个字面量,它不在内存里,如果变成const int& a = 10这样就可以,因为它会默认给你这个10一个变量,然后再让这个引用a指向这个变量,并且这个引用是不可以修改的.是只读的.
  
* 引用作为函数的参数

  * 函数传参时,可以利用引用让形参修饰实参,这可以简化指针修改实参.即不使用指针也可以完成地址传递.

* 引用作为函数返回值类型

  * 引用是可以作为函数返回值类型和返回值的,比如int& function(){static int a = 10;return a;}
  * **注意不要返回局部变量的引用**,这个效果跟返回局部变量的地址是一个效果的,数据会在第二次使用时消失.
  * **返回值是引用类型的函数的调用**可以作为左值存在,比如这样function() = 100;它的意思就是返回的变量 = 100;,如果有其他的引用是等于function()的话,那那个引用也是跟着=100的.

* 引用的本质

  * 引用在C++里的实现是一个指针常量,即const 数据类型 *指针变量名;比如:

    int a = 10; int& b = a;这个b其实就是 int* const b = &a;

  * C++推荐使用引用,因为语法更加的方便,虽然它的本质是个指针常量.

* 常量引用

  * 常量引用一般是在函数参数里使用来修饰形参的,用来防止误操作,比如:void function(const int& a){},这样这个函数的参数引用a就是一个只读状态,等效于const int* const a

### 运算符重载

对于内置的数据类型,也就是那些基本数据类型,编译器知道它们之间的运算符是做什么运算的,但是对于我们自定义的类型,比如自定义的类,它们实例之间通过这些基本运算符是用不了的,编译器不知道怎么用.

运算符重载是通过函数实现的.而且运算符重载的函数是可以进行重载的.

如果我们重写+然后实现逻辑却是-或者其他的不是增加操作的话,就是对运算符重载的滥用,这样的代码可读性很差,千万别滥用运算符重载

* 加号运算符重载

  * 我们如果想要给我们自己的类实现+的一些特定操作,就可以在你定义的那个实现+的逻辑的函数的函数名那,把函数名改成operator+,比如

    ```c++
    class A{
    public:
    	int a;
        int b;
        A aadd(A& a){
            A temp;
            temp.a = this->a + this.b;
            temp.b = this->a + this.b;
            return temp;
        }//这个成员函数实现我们的A实例的加法,把这个函数名字改成:
        A operator+(A& a){
            A temp;
            temp.a = this->a + this.b;
            temp.b = this->a + this.b;
            return temp;
        }//这样我们就可以直接让两个A的实例相+就可以实现里面的逻辑了
    }
    //我们还可以通过全局函数重载+号
    A operator+(A& a,A& b){
        	A temp;
            temp.a = a.a + b.b;
            temp.b = a.a + b.b;
            return temp;
    }
    int main(){
        A a(1,2);
        A b(4,5);
        A c = a + b;//这样是可以的.因为里面有+号运算符重载,它本质上就是调用了我们重载的那个函数
    }
    ```

    

* 左移运算符重载

  <<运算符重载可以输出自定义的数据类型.比如std::cout<<"";这里的<<运算符就是重载的.

  对与自己实现的逻辑的函数名,只要把函数名改成operator<<就可以了,注意我们一般不会使用成员函数来重载左移运算符,因为我们无法保证std::cout在左边.所以我们一般都是用全局函数来重载<<运算符.

  ```C++
  void operator<<(ostream& cout,A& a){
      cout<<"实现的逻辑....";
      cout<<"比如: "<< a.a;
      //如果要使用endl换行的话,就需要返回ostream对象.
  }
  //这样就可以在main函数里直接使用了.
  ```

  把这个左移运算符重载作为友元,就相当于Java里面那个toString()方法了.

* 自加运算符重载

  重载++运算符可以实现自己的整型数据.对于++运算符,它有前置和后置的区别

  ```C++
  class MyInteger{
  public:
      int a;
      int b;
      MyInteger(){
          a = 0;
          b = 0;
      }
      //前置
      MyInteger& operator++(){//如果不返回引用的话就会用拷贝构造函数返回一个新对象
          ++a;
          ++b;
          return *this;
      }
      //后置
      MyInteger operator++(int){//这个int就是一个占位参数,用来区分前置++和后置++重载.
          //后置就可以返回值了,因为这里要是返回引用那就是局部变量的引用,会导致非法操作.
          MyInteger temp = *this;
          a++;
          b++;
          return temp;
      }
  }
  
  
  ```

* 赋值运算符重载

  其实编译器会给类添加4个函数,除了默认构造函数和析构函数和拷贝构造函数,**还有一个赋值运算符operator=函数,是用来对属性进行值拷贝的.**重载赋值运算符也是用来给对象之间的赋值的.

  这个赋值运算符也是因为浅拷贝会导致重复释放同一内存中的问题,我们也需要对赋值运算符重载成深拷贝.

  ```C++
  class A{
      friend A::operator=(A& a);
  public:
      int* a;
      A(int a){
          this->a = new int(a);
      }
      A(){
          a = new int(18);
      }
      ~A(){
          if(a != NULL){
              delete a;
          	a = NULL;
          }
         
      }
      A& operator=(A& a){
          if(this->a != NULL){
              delete this->a;
              this->a = NULL;
              this->a = new int(a.a);
              return *this;
          }
          
      }
      
  }
  ```

  

* 关系运算符重载

  重载关系运算符可以让两个自定义类型对象进行比较操作

  ```C++
  //比如>,<,!=,==这些符号
  class A{
  private:
      int* a;
      int b;
  public:
      A(){
          this->a = new int(18);
          this->b = 100;
      }
      A(int a,int b){
          this->a = new int(a);
          this->b = b;
      }
      bool operator==(A& a){
          if(this->a == a.a && this->b == a.b){
              return true;
          }
         	return false;
      }
      bool operator>(A& a){
          //...
      }
  }
  ```

  

* 函数调用运算符重载

  函数调用运算符就是(),重载后使用的方式很像函数的调用,重载这个()也被称为仿函数.

  仿函数非常灵活,根据不同需要可以重载很多仿函数

  ```C++
  class A{
  public:
      void operator()(std::string s){
          std::cout<<s;
      }
  }
  ```

  * 匿名函数对象: 类名()(参数...),可以直接调用匿名对象的函数.只会使用这一次.

### 面向对象

面向对象的三大特性: 封装 继承 多态

C++认为万物皆对象,对象上有它的属性和行为.

* 封装

  * 将属性和行为作为一个整体,表现一个类型

  * 将属性和行为加以权限控制

  * 属性和行为的封装就是一个类

  * 语法: class 类名{成员属性....,成员函数....}

  * 成员属性和成员函数就是变量和函数,他们可以由访问权限修饰,访问权限有:public,private,protected.

    * public:类成员在类里面可以访问,类外面也可以访问到,子类可以访问到
    * protected:类里面可以访问,类外面不可以访问到,子类可以访问到
    * private:类里面可以访问,类外面不可以访问到,子类访问不到
    * 对于成员属性推荐设置为私有的,这样做有两个好处
      * 可以自己控制读写权限,即通过公开的成员函数来操作私有属性,一般就是Getter/Setter函数
      * 对于写权限(Setter函数),我们可以检测数据有效性

  * 声明一个对象: 类名 对象名; 这么声明要求类有无参构造函数.在C++里声明一个对象就意味着实例化了一个对象.

  * 结构体与类的区别

    C++中,结构体与类都是一种封装,他们非常相似,唯一的区别就是访问权限不同

    * struct默认权限为公共权限,我们不写访问权限的话,成员就默认是公开的
    * class默认权限为私有权限,即我们不写访问权限的时候,成员就默认是私有的
    
  * 对象的初始化和清理

    * 对象的初始化和清理是非常重要的安全问题,一个对象或者变量没有初始化,对它使用的后果就是未知的.用完一个对象或者变量,没有及时清理,也会造成一些安全问题.

    * C++中利用构造函数和析构函数来解决对象的初始化和清理,它们是编译器自动实现的,它默认是空的,如果我们手动实现的话编译器就会执行我们写的.

    * 构造函数:在创建对象时进行初始化,即声明一个对象的时候就会调用.当我们不写构造函数的时候,会有一个默认的无参数,空函数体的构造函数,但是我们只要写了构造函数,这个默认的就会消失.

      * 语法: 类名(){},构造函数是可以重载的

      * 构造函数的分类和调用

        * 按有无参数:有参构造,无参构造;按类型:普通构造函数和拷贝构造函数

          * 拷贝构造函数:参数只有一个,而且是一个本身对象的引用的的构造函数,它的具体写法

            类名 (const 类名 &对象名){}

            * 拷贝构造函数的作用: 就是将拷贝过来的对象中的属性拷贝到本对象上.
            * 注意
              * 默认构造函数（即无参构造函数）不一定存在，但是拷贝构造函数总是会存在。
              * 如果类的设计者不写复制构造函数，编译器就会自动生成复制构造函数。大多数情况下，其作用是实现从源对象到目标对象逐个字节的复制，即使得目标对象的每个成员变量都变得和源对象相等。编译器自动生成的复制构造函数称为“默认复制构造函数”。
              * 复制构造函数的参数可以是 const 引用，也可以是非 const 引用。 一般使用前者，这样既能以常量对象（初始化后值不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象。一个类中写两个复制构造函数，一个的参数是 const 引用，另一个的参数是非 const 引用，也是可以的。

          * 不是拷贝构造函数的就是普通构造函数

          * 拷贝函数的调用时机

            * 需要用一个已存在的本类对象来初始化一个新对象
            
            * 值传递的方式给函数参数传值
            
              比如一个函数:void fun(类名 对象名){},这时候我们传入一个对象的话,就会调用拷贝构造函数
            
            * 以值的方式返回局部对象
            
              比如一个函数: 类名 fun(){........;return 类对象},这样也会调用类的拷贝构造函数,并且将这个拷贝的对象返回.
            
          * ***深拷贝与浅拷贝***

            * 浅拷贝: 就是编译器默认给我们提供的值传递操作

            * 深拷贝: 在堆里申请空间,重新进行拷贝操作.

              当类里面的属性有指针这样的东西时,如果不将拷贝构造函数修改成深拷贝操作的话,由于它拷贝了一个值,所以拷贝过去的地址是一样的,这就意味着两个对象的这个指针都指向一块内存,如果有一个对象被释放了,在析构函数里进行了删除指针的话,会导致同一块地址被多次释放,导致非法操作内存.

              为了解决浅拷贝这种问题,我们可以自己写一个深拷贝,对于有指针或者类似东西的成员的类,就可以使用new关键字来开辟内存,把拷贝的数据放进这个新空间.

          * 构造函数的调用规则

            当一个类创建时,一个类里面至少要添加三个函数: 默认构造函数,默认析构函数,默认拷贝构造函数.当我们没有显式创建它们时,编译器会自动帮我们提供.

            * 如果我们自定义了有参构造函数,那编译器就不会提供无参构造,得我们自己写,当还是会提供默认的拷贝构造函数
            * 但是如果我们自定义了拷贝构造函数,编译器就不会提供其他的构造函数了
            * 默认的无参构造和析构函数它们都是空实现,而拷贝构造函数提供了值拷贝操作.

        * 调用方式

          * 括号法
            * 类名 对象名(参数值....),参数值不能没有,没有的话编译器会以为这是一个函数声明(在一个作用域中声明函数是可以的),会导致对象不会被创建.有参数就是有参构造,参数是同类对象就是调用拷贝构造函数,调用无参构造函数不可以写括号
          * 显示法
            * 类名 对象名 = 类名(参数值.....);等号右边是一个匿名对象,它会在这行执行完后就会被回收掉.
            * 注意事项: 不要使用拷贝构造函数来初始化一个匿名对象,这样编译器会认为这个是一个对象的声明,即 类名(本类的一个对象) 是等价于 类名 本类的一个对象名 的,这样会导致名称冲突.
          * 隐式转换法
            * 类名 对象名 = 参数值...; 这样等价于 类名 对象名 = 类名(参数值);参数值为本类的一个对象的话也就是调用拷贝构造函数.

    * 析构函数:对象在销毁前调用的函数,执行一些清理操作,当我们不写析构函数的时候,也会默认有一个空函数体的析构函数,当我们写了析构函数就会用我们的.

      * 语法: ~类名(){},析构函数不可以有参数,即不可以重载
      * 如果类里的成员有指针这样在堆区里的东西的话,就可以通过析构函数将它们释放掉.没用这种成员的话可以不用写,或者想进行一些什么操作的话也可以写.
      
    * 初始化列表

      除了通过构造函数的函数体里面进行属性初始化,还可以通过初始化列表进行属性初始化

      * 语法: 构造函数(): 成员属性名(属性值),成员属性名(属性值).....{},属性值可以是变量,比如一个类的构造函数是这样的: 类名(int a, int b) : 属性a(a),属性b(b) {};注意冒号是在构造函数的参数列表后的.

  * 类中的成员可以是另一个类的对象.如果我们创建一个包含其他对象的对象时,会先构造作为成员的类,然后才构造本类,在清理的时候会先清理本类,再去清理成员.

  * 静态成员

    静态成员就是由static关键字修饰的成员

    * 静态变量
      * 所有对象共享一份静态变量,可以通过对象名和类名来访问.
      * 静态成员变量也是有权限修饰的.
      * 在编译阶段就进行内存分配了
      * 在类内声明,类外初始化,在类外面这样: 静态成员的数据类型 类名::静态成员名 = 值;就可以进行初始化了.
    * 静态函数
      * 所有对象共享一个静态函数,静态函数可以通过变量名或类名调用
      * 静态函数也有权限修饰符
      * 静态成员函数只能访问静态成员变量.

  * 对象模型与this指针

    * 成员变量与成员函数是分开存储的.只有非静态的成员变量才属于类的对象上.

    * 非静态成员变量占用对象空间,静态成员变量不占对象空间,成员函数也不占用对象空间

    * 空对象占用1个字节,因为需要区分这些对象的位置,每个空对象占的空间地址都是不一样的.不是空的话就只用看非静态成员变量的空间.

    * 对于成员函数,每一个非静态成员函数,它只会诞生一份函数实例,也就是同类型的多个实例会公用一块代码,函数实例会通过this指针来区分调用的实例.

    * this指针是一个隐含在每一个非静态成员函数内的一种指针,它不需要定义,可以直接用.它的本质是一个指针常量,它的指向不可修改.

      * 用途

        * 当形参和成员变量同名时,可以用this指针来区分

        * 返回对象本身可以使用*this,返回类型是这个类型的引用

          比如 类名& 函数名(类名& 对象名){......;return *this;}

    * 空指针访问成员函数

      * 空指针是可以调用成员函数的,但需要注意有没有用到this指针,如果用到了

        比如

        ```C++
        class P{
            public:
            	int m;
            	void showP(){
                    cout<<"P"<<endl;
                }
            	void showM(){
                    cout<<m<<endl;
                }
        }
        int main(){
            P* p = NULL;
            p->showP();//这样是可以的
            p->showM();//这样是不可以的,因为是空指针,不指向对象,用到属性的话需要对象,这么搞程序会崩.
        }
        ```

        所以使用空指针调用成员函数的时候,最好判断一个this是否等于空指针.是的话就不执行,可以有效避免程序崩溃.

  * const在类里面

    * const修饰成员函数
      * 成员函数后加上const后这个函数就是常函数 : 返回值类型 函数名() const {};这个const其实就是把这个函数里面的this修饰成了const 类名* const this,也就是说,这个函数里的操作不可以更改该对象的东西.否则就会编译出错.
      * 常函数内不可以修改成员属性
      * 声明成员属性的时候加上mutable关键字,就可以在常函数中修改这个成员属性

  * const修饰对象

    * 声明对象的时候在前面加上const后这个对象就是常对象
    * 常对象不可以修改成员变量值,除非给成员值加上mutable.
    * 常对象只能调用常函数

  * 友元

    友元的目的是让一个函数或者类能够访问另一个类中的私有成员

    * 友元的关键字: friend

    * 友元的实现

      * 全局函数做友元

        在类里面的最上面(不用写在权限修饰符里)写上: friend 类外全局函数的声明;

        这样类外面那个全局函数就可以访问这个类对象的私有成员了.

      * 类做友元

        在类里面的最上面写上: friend class 类名 ;这样就可以声明谁是这个类的友元了.这样那个类就可以访问本类里面的私有成员了

      * 成员函数做友元

        在类里面的最上面写上: friend 某类里的成员函数返回值类型 某类名::某类里面的成员函数名();这样那个类的那个成员函数就可以访问这个类里面的私有成员了.

* 继承

  有些类之间有特殊的关系,有些类拥有另一些类的同样的特征,他们就是一种继承关系,继承可以减少重复的代码.

  * 继承语法

    * class 类名 : 继承方式(public/protected/private) 父类名{....},冒号后面的是继承方式

    * 继承方式

      * 公共继承

        public 父类名

        子类不可访问父类的私有属性,父类中公共的属性和保护的属性还是公共和保护的.

      * 保护继承

        protected 父类名

        子类不可访问父类的私有属性,父类中公共属性和保护属性在子类中变为保护权限

      * 私有继承

        private 父类名

        子类不可访问父类的私有属性,父类中公共属性和保护属性在子类中变为私有权限

  * 继承中的对象模型

    从父类继承过来的成员,哪些是属于子类实例中的?

    ```C++
    class Father{
    public:
        int a;
    protected:
        int b;
    private:
        int c;
    }
    class Son : public Father{
    private:
        int d;
    }
    int main(){
        std::cout<<sizeOf(Son)<<std::endl;
        //最后输出了16,说明Son中拥有4个成员
    }
    ```

    其实子类会获得父类的所有成员,不管是什么权限的都继承下去了.父类的私有成员在子类中是被编译器隐藏了,但它确确实实存在于子类中.

  * 继承中的构造与析构顺序

    创建一个子类对象时,会先执行父类的构造函数,然后才执行子类的构造函数,清理时会先清理子类的析构函数,然后才执行父类的析构函数

  * 继承中同名成员的处理

    当父类与子类中有同名的成员时,访问子类同名成员时可以直接访问,访问父类中的同名成员需要用作用域.

    ```C++
    class Father{
    public:
        int a;
        Father(){
            a = 100;
        }
        void b(){
            std::cout<<"father";
        }
    }
    class Son : public Father{
    public:
        int a;
        Son(){
            a = 200;
        }
        void b(){
            std::cout<<"son";
        }
    }
    int mian(){
        Son s;
        std::cout<<s.a;//这里输出子类的a,也就是200
        std::cout<<s.Father::a;//这里就会输出父类的a,也就是100
        s.b();//这里输出子类中的b(),也就是会输出son
        s.Father::b();//这里输出父类中的b(),也就是会输出father	
    }
    ```

    子类对象名 . 父类名::同名成员,这样就可以访问到从父类继承下来的同名属性和成员函数.

    即使父类中有重载的同名函数,子类的同名函数会隐藏掉父类中的所有同名函数,我们无法通过子类对象来直接调用它们,必须通过作用域来访问.

  * 继承中同名静态成员的处理

    静态成员和非静态成员出现同名情况时,跟非静态成员的处理是一样的,都是用作用域.如果想通过子类名来访问到父类中的同名静态成员,就只需要这样: 子类名::父类名::静态成员名;就可以访问到父类中的同名静态成员了.

    对于同名的静态成员函数处理方式跟同名静态成员一样

  * 多继承

    C++里存在多继承,即一个子类可以有多个父类.

    * 语法: class 子类 : 继承方式  父类1, 继承方式 父类2 .....
    * 实际开发不推荐使用多继承.

  * 菱形继承以及问题解决

    菱形继承就是两个子类继承了同一个父类,而且有一个子类又去继承这两个子类,这种继承被称为菱形继承或者钻石继承.

    * 菱形继承问题

      * 由于两个子类都继承了父类的成员,当子类的子类使用数据时,就会产生二义性.

        解决办法: 用作用域来区分.

      * 由于继承了两个子类,它们里面的父类成员是一样的,会产生两份数据,但这些数据我们只需要一份.

        解决办法:使用虚继承: class 类名 : virtual 继承方式 父类名.这样继承的父类就是一个虚基类,当多个子类虚继承一个父类,这些子类之间的数据就只有这一份,就像静态成员一样.

        原理: 虚继承继承下来的东西是一些vbptr,就是虚基类指针(virtual base pointer),它指向虚基类表(vbtable),虚基类表里包含有各个子类的属性的偏移量,通过这些偏移量就可以确定具体的属性了.

* 多态

  * 静态多态

    函数重载和运算符重载都属于静态多态,复用函数名这样的就是属于静态多态

  * 动态多态

    派生类和虚函数实现运行时多态

  * 静态多态与动态多态的区别

    * 静态多态的函数地址早已绑定,即在编译期就已经确定了函数的地址
    * 动态多态的函数地址晚绑定,就是在程序运行的时候才会确定函数地址

  * 动态多态的实现

    在C++里,父类对象的引用类型是可以直接由子类实例来赋值的.也就是父类型的变量可以指向子类的实例.子类与父类之间不需要进行类型强转.

    ```C++
    class Animal{
        public:
        	(virtual) void speak(){//加上virtual关键字,就可以进行函数地址动态绑定,实现动态多态
                std::cout<<"动物说话"<<std::endl;
            }
    }
    class Cat : public Animal{
        public:
        	void speak(){
                std::cout<<"猫叫"<<std::endl;
            }
    }
    void somethingspeak(Animal& animal){
        animal.speak;//这里调用的话只会输出动物说话,即使我们传入的参数是猫的实例,因为这里已经绑定了animal类里面的speak函数
        //想要动态实现的话,就需要把父类的那个方法变成虚函数,加上virtual关键字.
    }
    int main(){
        Cat cat;
        somethingspeak(cat);//输出动物说话
        
    }
    ```

    动态多态实现的条件

    * 有继承关系
    * 子类要重写父类的虚函数(子类里面重写的函数可以不用写virtual关键字

    动态多态的使用

    * 父类的指针或引用指向的是子类对象

  * 多态的原理

    ```C++
    //当我们类只有一个普通的成员函数时,它的大小(sizeof)就只有1,而我们加上virtual关键字后,它的大小就变成了4.这是因为加上了virtual关键字后,类里面就会有一个vfptr(虚函数指针),它指向一个虚函数表(vftable),虚函数表里面存放着很多虚函数的地址(存放方式: &Animal::speak).
    //子类继承了这个有虚函数的类时,会将虚函数指针以及虚函数表都继承下来,如果我们在子类里重写了父类的虚函数,那么子类会将继承下来的虚函数表里的虚函数地址给替换成子类的虚函数地址.也就是把(&Animal::speak)替换成(&Cat::speak),此时当父类的指针或引用指向子类对象的时候,就会发生多态
    ```

  * 多态的优点

    * 代码组织结构清晰
    * 代码可读性强
    * 利于前期开发与后期的扩展维护;

  * 纯虚函数与抽象类

    如果我们使用多态的话,父类中的虚函数的实现一般是没有啥用的,主要是供子类重写.所以我们可以将虚函数改成纯虚函数.

    * 纯虚函数语法: virtual 返回值类型 函数名(参数列表) = 0;
    * 当类里面有纯虚函数的话,这个类就是抽象类
    * 抽象类的特点
      * 无法实例对象
      * 子类必须重写抽象类中的纯虚函数,否则子类也是个抽象类.

  * 虚析构和纯虚析构

    当使用多态时,如果子类中有属性开辟到了堆区,那么父类指针在释放的时候没法调用到子类的析构函数.这时候就需要通过将父类中的析构函数改为虚析构函数或者纯虚析构函数.

    当父类的析构函数是虚析构函数时,它就会先去执行子类的析构函数.再回来执行自己的析构函数.

    * 虚析构函数和纯虚析构函数的共性
      * 可以解决父类指针释放子类对象
      * 都需要具体的函数实现
    * 虚析构函数和纯虚析构函数的区别
      * 如果是纯虚析构函数,那么这个类就是抽象类
    * 虚析构函数语法: virtual ~类名(){}
    * 纯虚析构函数语法: virtual ~类名() = 0;当父类中有在堆区的数据需要析构清理时,纯虚析构的实现就需要在类外边写上: 类名::~类名(){...},纯虚析构函数需要声明也需要实现.

### C++文件操作

程序运行时产生的数据都是临时数据,程序运行结束后就会被清理掉,我们就可以通过文件将这些数据持久化.

C++中提供了文件操作流的头文件: fstream.

文件类型分为两种:

* 文本文件 : 文件以ASCII码形式存储在计算机中,只存储字符数据
* 二进制文件: 文件以二进制形式存储在计算机中,可以存储任意类型数据.

文件操作的三个类:

* ofstream: 文件输出流 ,用于文件的写操作
* ifstream: 文件输入流, 用于文件的读操作
* fstream: 文件流, 用于文件的读写操作

具体操作

* 文本文件写操作的基本步骤

  * 包含文件流头文件

    #include<fstream>

  * 创建流对象

    ofstream ofs;

  * 打开文件

    ofs.open("文件路径",打开方式);

    * 打开方式

      * ios::in  为读文件而打开文件
      * ios::out 为写文件而打开文件
      * ios::ate 打开到文件末尾,跟追加方式一样
      * ios::app 以追加方式写文件
      * ios::trunc 如果文件存在就删除,然后再创建
      * ios::binary 二进制方式打开文件(进入二进制文件操作)

    * 注意: 文件打开方式可以配合使用,利用|操作符

      比如用二进制方式写文件: ios::binary | ios:: out

  * 写数据

    ofs<<"写入的数据";

  * 关闭文件

    ofs.close();

    ```C++
    #include<fstream>
    int mian(){
        ofstream oft;//要写文件就建一个输出流对象.
        oft.open("A.txt",ios::out);//不指定绝对路径的话默认路径是在项目下.
        oft << "asdouahdaoihdaisohdodhoass"<<endl;//写入文件并换行
        oft << "sadohadhausdhaisudiasudiashda" << endl;
        oft.close();//写完了就关闭流.
        
    }
    ```

* 文本文件读取操作的流程

  * 包含头文件

  * 创建输入流对象

    ifstream ift;

  * 打开文件并判断文件是否打开成功

    ift.open("文件路径",打开方式);

    有一个函数:ift.is_open()可以判断文件是否打开成功.

  * 读取数据

    有四种读取方式

    * 可以将文件数据读取到一个字符数组中

      ```C++
      char buf[1024] = {0};
      while(ift >> buf){
          //std::cout << buf << std::endl;
      }
      ```

    * ```C++
      char buf[1024] = {0};
      while(ifs.getline(buf,sizeof(buf))){
          //std::cout << buf << std::endl;
      }
      ```

    * 将文件数据放到字符串里面

      ```C++
      string buf;
      while(getline(ift,buf)){
          //std::cout << buf << std::endl;
      }
      ```

    * 将文件数据放到一个字符里,不推荐这么用,效率太低了

      ```C++
      char c;
      while((c = ift.get()) != EOF){
          //std::cout<<c;
      } 
      ```

      

  * 关闭文件

* 二进制文件写文件流程

  * 跟文本文件写操作差不多,但是打开方式要加上一个ios::binary.而且二进制文件写文件主要利用的是流对象调用成员函数write(),它的原型:ostream& write(const char* buffer,int len),buffer是指向内存中的一段存储空间,len是读写的字节数.

    ```C++
    //二进制文件写文件不仅可以写内置的数据类型,自定义的数据类型也可以写进去.
    #include<fstream>
    int main(){
        ofstream oft;
        oft.open("文件路径",ios::out|ios::binary);
        自定义的类型 对象名(初始化列表);
        oft.writr((const char*) &对象名,sizeof(自定义的类型));
        oft.close();
    }
    ```

* 二进制文件读文件流程

  * 跟二进制文件写操作差不多,只是用的是一个成员函数:read(),它的原型: read(const char* buffer, int len),buffer是数据的地址,len是数据的长度.

    ```C++
    #include<fstream>
    int main(){
        ofstream oft;
        oft.open("文件路径",ios::out|ios::binary);
        自定义的类型 对象名(初始化列表);
        oft.writr((const char*) &对象名,sizeof(自定义的类型));
        oft.close();
    }
    ```

## C++泛型与STL

泛型是C++的一种编程思想,它主要利用模板来进行实现.

### 模板

模板就是建立通用模板,提高代码的复用性.模板不可以直接使用,必须要自己加入内容,而且模板也不是万能的.

C++中提供两种模板机制:函数模板与类模板

* 函数模板

  建立一个通用函数,其函数返回值类型和形参类型可以不具体制定,用一个虚拟的类型来代替,

  * 语法: 

    ```C++
    template<typename T>  //: template关键字表示声明函数模板,typename表示后面的符号是一种数据类型,也可以写class, T是一个通用的数据类型,名称可以替换,通常为大写字母
    函数声明或定义 //这里写上函数声明或者定义就是定义了一个函数模板
    ```

    比如:

    ```C++
    template<typename T>
    void swapNum(T& a,T& b){
        T temp = a;
        a = b;
        b = temp;
    }
    //在调用函数的时候再指定具体类型
    ```

  * 使用函数模板

    * 自动类型推导

      直接将参数直接传入模板函数里面,这样可以直接识别类型

    * 显示指定类型

      直接手动告诉传入的参数是什么类型,在函数名后写上<参数类型>,就是直接指定参数类型了

  * 函数模板使用的注意实现

    * 自动类型推导必须推导出一致的数据类型T才可以使用,就是如果参数列表里有多个数据类型T的话,参数类型就都是T才行,如果传入参数类型不同的话就不行.
    * 模板必须要确定出T的数据类型,才可以使用

  * 普通函数与模板函数的区别

    * 普通函数调用时可以进行自动类型转换(隐式类型转换)
    * 函数模板调用时,使用自动类型推导的话不会发生隐式类型转换
    * 使用显示指定类型的方式调用函数模板就可以发生隐式类型转换

  * 普通函数与函数模板的调用规则

    * 普通函数与函数模板是可以发生重载的,函数模板之间也可以进行函数重载
    * 当函数模板与普通模板都有实现(有函数体实现)的时候,优先调用普通函数
    * 可以通过空模板参数列表来强制使用函数模板,即在函数名后面加一个<>
    * 如果函数模板可以产生更好的匹配,就优先调用函数模板

  * 模板的局限性

    * 有些情况传入的参数是不能随便操作的.为了解决这个问题,提供了模板的重载,可以为这些特定的类型提供具体化的模板.

      实现方法:

      ```C++
      //比如有一个我们自定义的类型P,如果要对它的对象进行比较,除了在它里面重载运算符,还可以重载模板函数
      template<> 返回值类型 函数名(具体类型(P) 参数1,...){具体实现}
      //这样定义一个模板后,只要我们的参数类型是P,就会优先走这个模板函数.
      ```

    * 利用具体化的模板函数,可以解决自定义类型的通用化

    * 学习模板并不是为了写模板,而且在STL能够运用内置的模板

* 类模板

  类模板就是一个通用的类,类中的成员的数据类型可以不具体指定,用一个虚拟的类型来代表.在创建对象的时候才会具体化数据类型.

  * 语法:

    ```C++
    template<typename T,...>
    class 类名{...}
    ```

  * 使用类模板创建对象的语法

    ```C++
    模板类名<类型列表> 对象名(初始化列表);
    ```

  * 类模板与函数模板的区别

    * 类模板没有自动类型推导

    * 类模板在模板参数列表中可以有默认参数

      ```C++
      template<typename T = int>//这样就是设定一个默认的类型
      class 类名{...}
      ```

  * 类模板中成员函数创建的时机

    * 普通类中的成员函数一开始就可以创建
    * 类薄板中的成员函数在调用时才创建

  * 类模板对象做函数参数

    * 类模板实例化出的对象作为函数参数的情况

    * 传入方式

      * 指定传入的类型,即显式对象的数据类型

        即在传入参数的时候,直接显示指定类型中的数据类型列表,

        比如这样:    返回值类型  函数名(类名<类型1,类型2....> 参数名1,...){}

      * 参数模板化,即对象中的参数变为模板进行传递

        比如这样:    

        template<class T1,class T2>

        返回值类型  函数名(类名<T1,T2....> 参数名1,...){}

        * 通过一个全局函数typeid(类型名).name()获取到一个类型的全名

      * 整个类型模板化,将这个对象的类型模板化进行传递

        比如这样:

        template<class T>

        返回值类型 函数名(T 参数名){}.

  * 类模板与继承

    当类模板被继承的时候要注意:

    * 子类继承的父类是一个类模板的时候,要指定父类中T的具体类型

      ```C++
      template<class T>
      class Base{
      public:
          T t;
      }
      
      class Son : public Base<int>{//必须指定T类型是啥
          
      }
      
      template<class X,class T>
      class Son1 : public Base<T>{//要不就把子类也声明成模板类,指明父类的类型T
          
      }
      ```

    * 如果不指定编译器就没法给子类分配内存

    * 如果想灵活指定父类中T的类型,子类也要声明为类模版

  * 类模板成员函数的类外实现

    ```C++
    //比如构造函数的类外实现
    template<class T1,class T2>
    类名<T1,T2>::构造函数名(参数列表){};
    
    //普通成员函数
    template<class T1,class T2>
    返回值类型 类名<T1,T2>::函数名(参数列表){};
    ```

  * 类模板分文件编写

    我们在用类模板的时候可以把类模板写在头文件里,但我们在其他cpp文件里去引用这个头文件的时候,编译器是没有创建类模板的具体实现的,导致实现类模板的cpp文件里的代码也无法执行,就会导致无法解析模板类.但我们可以包含实现类模板的cpp文件,就可以正确实现了类模板,但我们实际中很少这么包含源文件.所以我们可以将类模板的声明和实现都写一起,然后放在一个hpp文件里,这个hpp文件名是一个规范,一般类模板的东西都写在里面.

  * 类模板与友元

    * 全局函数的类内实现:直接在类里面声明友元就行

    * 全局函数类外实现:要提前让编译器知道全局函数的存在

      ```C++
      template<class T1,class T2>
      class P;
      
      template<class T1,class T2>
      void show01(P<T1,T2> p){
           std::cout<<p.a<<p.b<<std::endl;
      }
      //类外实现全局友元函数就必须在外面提请告诉编译器有这个类和有这个函数
      
      template<class T1,class T2>
      class P{
          //在类内声明友元
          friend void show01<>(P<T1,T2> p);//如果全局函数是类外实现,就需要让编译器提前知道这个函数的存在
          //类内全局函数友元实现
          friend void show(P<T1,T2> p){
              std::cout<<p.a<<p.b<<std::endl;
          }
          
      private:
          T1 a;
          T2 b;
      public:
          P(T1 a,T2 b){
              this->a = a;
              this->b = b;
          }
      }
      
      
      ```

### STL

长久以来,软件开发者都希望建立一种可以重复利用代码的东西,C++的泛型编程以及面向对象都是为了提高代码复用性,大多数情况下,数据结构和算法都未能有一套标准,导致产生很多的重复工作,为了建立数据结构和算法的一套标准,就诞生了STL

STL(standard template libray)标准模板库,它广义上分为容器(container),算法(algorithm),以及迭代器(iterator).容器和算法之间通过迭代器进行无缝连接,STL中几乎所有的代码都使用了模板类或模板函数.

* STL六大组件
  * 容器 : 各种数据结构 ,比如vector,list,deque,set,map等
  * 算法 : 各种常用算法,比如sort,find,copy,for_each等
  * 迭代器 : 容器与算法之间的胶合剂
  * 仿函数 : 行为类似函数,可作为算法的某种策略
  * 适配器(配接器) : 一种用来修饰容器或者仿函数或者迭代器接口的东西
  * 空间适配器 : 负责空间的配置与管理

* 容器

  STL容器是将运用最为广泛的一些数据结构表示出来,常用的数据结构有: 数组,链表,栈,树,队列,集合,映射表等等.容器又分为序列式容器和关联式容器:

  * 序列式容器:强调值的排序,序列式容器中的每个元素都有固定的位置
  * 关联式容器:二叉树结构,个元素之间没有严格的物理上的顺序关系

* 算法

  优先的步骤解决逻辑或数学上的问题,这门学科就是算法.算法也分为质变算法和非之变算法:

  * 质变算法: 在运算过程中会更改区间中元素的内容,比如拷贝,替换,删除等
  * 非质变算法: 在运算过程中不会更改区间中元素的内容,比如查找,计数,遍历,寻找极值等

* 迭代器

  提供一种方法,使之能够依序寻访某个容器所含的各个元素,而又无需暴露该容器的内部表示方式.每个容器都有自己专属的迭代器,迭代器的使用类似于指针.迭代器的种类:

  * 输入迭代器

    对数据的只读访问,支持++,==,!=运算,因为是只读的

  * 输出迭代器

    对数据的只写访问,支持++运算符

  * 前向迭代器

    读写操作,并会向前推进迭代器,支持++,==,!=运算

  * 双向迭代器

    读写操作,可以在两个方向上推进迭代器,支持++,--运算

  * 随机访问迭代器

    读写操作,可以跳跃性的访问任意位置的数据,功能最强的迭代器,支持各种运算.

  常用的容器中迭代器种类为双向迭代器和随机访问迭代器.

* 容器算法迭代器之间的关系

  ```C++
  //使用vector容器来表示
  //容器:vector
  //算法:for_each
  //迭代器:vector<T>::iterator
  #include <vector>
  #include <iostream>
  #include <algorithm>
  
  void showVector(int val){
      std::cout<<val<<std::endl;
  }
  
  int main(){
  
      std::vector<int> vector;
      vector.push_back(100);//向vector中插入数据
      vector.push_back(200);
      vector.push_back(300);
      vector.push_back(400);
      vector.push_back(500);
      vector.push_back(600);
      vector.push_back(700);
      vector.push_back(800);
      auto iteratorBegin = vector.begin();//起始迭代器
      //指向容器的第一个数据
      auto iteratorEnd = vector.end();//结尾迭代器
      //指向容器的最后一个数据的后一个数据
  
      //通过迭代器访问容器中的数据
      while(iteratorBegin != iteratorEnd){
          std::cout<<*iteratorBegin<<std::endl;
          iteratorBegin++;
      }
  
      //通过for循环访问容器中的数据
      for (auto it = vector.begin();it != vector.end();it++) {
          std::cout<<*it<<std::endl;
      }
  
      //通过for_each算法遍历容器中的数据,参数值是容器数据的首地址,尾地址,遍历具体的逻辑.
      std::for_each(iteratorBegin,iteratorEnd, showVector);
  
      return 0;
  }
  ```

  emm,这玩意有点多,另开一个笔记.

































































































