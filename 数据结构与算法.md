数据结构与算法

### 经典算法

1、字符串匹配：有一个字符串str1 = "abcdefabcdegabcdeh",和另一个字符串str2="deg",现在要判断str1是否含有str2，若存在就返回第一次出现的位置，若没出现就返回-1，要求用最快的速度来完成匹配。

解法：1.暴力解法：即一个一个字符匹配，这种方法虽然简单但是效率低

​			2.KMP算法，即部分匹配表算法

2、汉诺塔游戏：将多个塔从第一个柱子移动到第三个柱子，规定小圆盘上不能放大圆盘，在三根柱子间一次只能移动一个盘，问盘子数目不同时各有需要移动多少次。

3、八皇后问题：在8*8的国际象棋棋盘上摆放8个皇后，且任意两个皇后不能在同一行，同一列，同一斜线上，问有多少种摆法。

解法：回溯算法

4、马踏棋盘：在6*6的棋盘上放一个马，该棋子只能走日字，问该怎么走才能达到步数最多。

解法：图的深度优化遍历算法(DFS)+贪心算法优化

### 数据结构与算法的重要性

1.算法是程序的灵魂，一个好的程序可在进行海量数据计算时仍能保持高速计算。

2.程序会使用内存计算框架(诸如Spark)和缓存技术(诸如Redis)来优化程序，这些技术的核心又是啥呢？







### 排序算法

#### Comparable接口

该接口可以提供比较的规则，有这样的一个例子：

```java
//我们要比较类中的东西，就可以给这个类实现Comparable接口，然后用这个接口的方法来指定比较的规则，直接调用这个定义好的规则方法就可以实现排序了，
//我们定义一个学生类，让它实现这个接口，重写它的方法，并返回年龄相减的值
//然后再写一个排序规则方法，返回特定对象
//Student.class
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student implements Comparable<Student>{

    private String name;
    private int age;

    public int compareTo(Student o) {//这个Comparable提供的方法可以指定排序的规则
        return this.getAge()-o.getAge();//我们这里定义一个年龄相减
    }
}

//排序规则方法
//在这里我们定义一个Comparable的方法用来指定排序规则和结果
    public static Comparable getMax(Comparable c1,Comparable c2){
        int i = c1.compareTo(c2);
        //如果i小于0，则c1比c2小1，或者大于或者等于
        if(i>=0)
            return c1;
        else
            return c2;
    }
//main：
public static void main(String[] args) {
        Student student1 = new Student("A",2);
        Student student2 = new Student("B", 3);
        System.out.println(getMax(student1,student2));
    }
//执行后我们可以得到第二个对象的信息
```

#### 冒泡排序：

这有一个需求：将[5,6,7,9,3,1,4]这个数组里的数据排序为[1,3,4,5,6,7,9]

排序的原理：即

1.比较相邻的元素，如果前一个元素比后一个元素大，交换这两个元素的位置

2.对每一对相邻的元素做同样的操作，从开始一堆元素到结尾一对元素，最终最后位置的元素就是最大值

冒泡排序的API设计:

```
创建一个名为Bubble的类，其中有sort()，greater(),exch()三个成员方法，具体为：
public void sort(Comparable[] a)用于对数组内的元素进行排序
public static boolean greater(Comparable v,Comparable w)用于判断v是否大于w
public static void exch(Comparable[] a,int i,int j)用于交换a数组钟索引i和索引j处的值
```

```java
public class Bubble {
    //这是一个实现冒泡排序算法的类
    //该排序算法在需要排序的数量很大的时候效率会很低
    public void sort(Comparable[] a){
        //这个方法用来实现数组中元素的排序
        for (int i = 0; i < a.length; i++) {
            for(int j=0;j<i;j++){
                //比较元素及其后一个元素，如果前面大于后面就换位置
                if(greater(a[j],a[j+1])){
                    exch(a,i,j);
                }
            }
        }
    }
    public static boolean greater(Comparable v,Comparable w){
        //这个方法用来比较v和w的大小
        return v.compareTo(w)>=0;
    }
    public static void exch(Comparable[] a,int i,int j){
        //这个方法用于交换数组中索引值i与索引值为j的元素的值
        Comparable temp;
        temp = a[i];
        a[i]=a[j];
        a[j]=temp;

    }

}
```

#### 选择排序：

排序原理：

1.每一次遍历的过程中，都假定第一个索引处是最小值，和其它索引值依次比较，如果当前索引处值大于其它某个索引处值，则假定其它某个索引处为最小值，最后就能找到最小值所在的索引

2.交换第一个索引处和最小值所处的索引值

选择排序的API设计：

```
创建一个名为Selection的类，其中有Selection()，greater(),exch()三个成员方法，具体为：
public void Selection(Comparable[] a)用于对数组内的元素进行排序
public static boolean greater(Comparable v,Comparable w)用于判断v是否大于w
public static void exch(Comparable[] a,int i,int j)用于交换a数组钟索引i和索引j处的值
```

```
public class Selection {
    //这是一个实现选择排序算法的类
    public void Selection(Comparable[] a){
        //这个方法用来实现数组中元素的排序(选择排序)
        for (int i = 0; i < a.length-1; i++) {//这里的a.length-1，是因为我们排序只有当元素大于1个的时候才需要排序
            int minIndex = i;//假设第一个为最小值
            for(int j=i+1;j<a.length;j++){
                if(greater(a[minIndex],a[j])){
                    minIndex = j;//如果前一个还不是最小的，就交换索引值
                }
            }

        }
    }
    public static boolean greater(Comparable v,Comparable w){
        //这个方法用来比较v和w的大小
        return v.compareTo(w)>=0;
    }
    public static void exch(Comparable[] a,int i,int j){
        //这个方法用于交换数组中索引值i与索引值为j的元素的值
        Comparable temp;
        temp = a[i];
        a[i]=a[j];
        a[j]=temp;

    }

}
```

#### 插入排序：

排序原理：

1.把所有的元素分为两组，已排序和未排序的

2.找到未排序的组中的第一个元素，向已排序的组中进行插入

3.倒叙遍历已排序组中的元素，依次与待插入元素进行比较，知道找到一个元素小于等于待插入元素，那么就把这个待插入元素放到这个位置，其它元素向后移动移位1位

插入排序的API设计：

```
创建一个名为Intsertion的类，其中有intsertion()，greater(),exch()三个成员方法，具体为：
public void intsertion(Comparable[] a)用于对数组内的元素进行排序
public static boolean greater(Comparable v,Comparable w)用于判断v是否大于w
public static void exch(Comparable[] a,int i,int j)用于交换a数组钟索引i和索引j处的值
```

```
public class Intsertion {
    //这是一个实现插入排序算法的类
     public  void Insertion(Comparable[] a){
        //这个方法用来实现数组中元素的排序(插入排序)
        for (int i = 0; i < a.length; i++) {
            for(int j=i;j>0;j--){
                if(greater(a[j-1],a[j])){
                    exch(a,j-1,j);
                }else
                    break;
            }
        }
    }
    public static boolean greater(Comparable v,Comparable w){
        //这个方法用来比较v和w的大小
        return v.compareTo(w)>=0;
    }
    public static void exch(Comparable[] a,int i,int j){
        //这个方法用于交换数组中索引值i与索引值为j的元素的值
        Comparable temp;
        temp = a[i];
        a[i]=a[j];
        a[j]=temp;

    }

}
```

#### 高级排序

##### 希尔排序：

这是插入排序的一种，它是插入排序的一种升级

排序原理：

1.选定一个索引值的增长量，按照增长量作为数据分组的依据，对数据进行分组

2.对分好组的每一组数据进行插入排序

3.减小增长量，最小为1，重复第二步操作

索引值的增长量的规则：

```
int h=1;//初始增长量的值
while(h<数组长度/2){
	h=2h+1;
}//循环结束后即可确定h的最大值
增长量的减小规则为：
h=h/2;
```

希尔排序的API设计：

```
创建一个名为Shell的类，其中有shell()，greater(),exch()三个成员方法，具体为：
public void shell(Comparable[] a)用于对数组内的元素进行排序
public static boolean greater(Comparable v,Comparable w)用于判断v是否大于w
public static void exch(Comparable[] a,int i,int j)用于交换a数组钟索引i和索引j处的值
```

```
public class Shell {
       //希尔排序算法
    public void shell(Comparable[] a){
        //实现希尔排序
        //1.确定增长量
        int h = 1;
        while (h<a.length){
            h=h*h+1;
        }
        //2.希尔排序
        while (h>1){
            //1.找到待插入的元素
            for(int i=h;i<a.length;i++){
                //2.把待插入的元素插入有序组中
                for (int j=i;j>=h;j-=h){
                    //待插入的元素是a[j],比较a[j]与a[j-h]
                    if(greater(a[j],a[j-h])){
                        exch(a,j-h,j);
                    }else break;
                }
            }

        }
    }
    public static boolean greater(Comparable v,Comparable w){
        //这个方法用来比较v和w的大小
        return v.compareTo(w)>=0;
    }
    public static void exch(Comparable[] a,int i,int j){
        //这个方法用于交换数组中索引值i与索引值为j的元素的值
        Comparable temp;
        temp = a[i];
        a[i]=a[j];
        a[j]=temp;

    }

}
```

##### 归并排序：

递归：就是一个方法可以在它的内部调用方法本身，递归的作用是可以把一个大型的复杂的问题，层层转换为一个与原问题相似但规模小的问题来求解，递归秩序只需要少量程序就可以描述出解题过程所需要的多次重复计算，大大减少代码量

注意事项：递归不可以无限调用自己，必须要有边界条件让递归结束，因为每次递归调用会开辟新的栈内存，重新执行方法，不及时停止的话会导致栈内存溢出

递归一个例子：

```
//使用递归来求N的阶乘
public satic long factorial(int n){//如果递归次数过多会导致栈内存溢出
	if(n==1){//这个就是一个边界条件
		return 1;
	}
	return n*factorial(n-1);
}

```



归并排序(分治算法)：

排序原理：

1.尽可能的将一组数据拆分为两个元素数量相等的子组，并对每一个子组继续拆分，知道拆分后的每个子组的元素个数是1为止

2.将相邻的两个子组进行合并成一个有序的大组

3.重复步骤2，直到最终只有一个组为止

4.排序原理图解：

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218163120151-452283750.png)

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194508761-468169540.png)



归并排序的API设计：

```java
//创建一个Merge类，表示归并排序
//其中的成员方法
//1.public static void sort(Comparable[] a);对数组内元素进行排序
//2.public static void sort(Comparable[] a,int lo.int hi);对数组a中从索引lo到索引hi之间的元素进行排序
//3.public static void merge(Comparable a,int lo,int mid,int hi);从索引lo处到mid为一个子组，从索引mid+1处到hi处为另一个子组，把数组a中的这两个子组数据合并成一个有序大组(从索引lo到索引hi)
//4.private static boolean less(Comparable v,Comparable w)用于判断v是否大于w
//5.private static void exch(Comparable[] a,int i,int j)用于交换a数组钟索引i和索引j处的值
//6.private static Comparable[] assist;辅助数组
```

```java
public class GuiBingPaiXu {
    //实现归并排序算法

    private static Comparable[] assist;//辅助数组

    public static void sort(Comparable[] a){
        //对数组进行排序
        //初始化辅助数组
        assist = new Comparable[a.length];
        //定义lo，hi变量，用来记录数组的最小索引值与最大索引值
        int lo=0;
        int hi= a.length-1;
        //调用另一个sort方法，完成数组a的排序
        sort(a,lo,hi);
    }
    private static void sort(Comparable[] a,int lo,int hi){
        //对数组a从索引值lo到hi的元素进行排序
        //安全校验
        if(hi<=lo){
            return;
        }
        //对lo与hi间的数据进行分组
        int mid=lo+(hi-lo)/2;
        //对分的组进行排序
        sort(a,lo,mid);
        sort(a,mid+1,hi);
        //把两个组中的数据进行归并
        merge(a,lo,mid,hi);

    }
    private static void merge(Comparable[] a,int lo,int mid,int hi){
        //从索引lo处到mid为一个子组，从索引mid+1处到hi处为另一个子组，把数组a中的这两个子组数据合并成一个有序大组(从索引lo到索引hi)
        //定义三个指针，遍历，移动指针，比较对应的值，找出小的，放入辅助数组中
        int i=lo;
        int p1=lo;
        int p2=mid+1;
        while (p1<=mid && p2<=hi){
            if(greater(a[p1],a[p2])){
                assist[i++]=a[p1++];
            }else
                assist[i++]=a[p2++];
        }
        //遍历，如果有一个指针没走完，就将对应的值放到辅助数组中，只会继续跑没指完的指针
        while (p1<=mid){
            assist[i++]=a[p1++];
        }
        while (p2<=hi){
            assist[i++]=a[p2++];
        }
        //把辅助数组中的元素复制回原数组中
        for (int i1 = lo; i1 <= hi; i1++) {
            a[i1]=assist[i1];
        }
    }


    public static boolean greater(Comparable v,Comparable w){
        //这个方法用来比较v和w的大小
        return v.compareTo(w)<0;
    }
    public static void exch(Comparable[] a,int i,int j){
        //这个方法用于交换数组中索引值i与索引值为j的元素的值
        Comparable temp;
        temp = a[i];
        a[i]=a[j];
        a[j]=temp;

    }
}
```

##### 快速排序 

快速排序是对冒泡排序的一种优化，它的思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据要小，然后按此方法对着两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列

排序原理：

1.先设定一个分界值，可以直接将第一个数据作为分界值，通过该分界值将数据分为左右两部分，其中左边部分的所有数据比另外一部分的所有数据都要小，此时左边部分中的个元素都小于或等于分界值，而右边部分各个元素都大于或等于分界值

2.左边和右边的数据可以独立排序，对于分出来的这两组数据，可以在做步骤1的操作

3.重复上述步骤，可以看出，这是一个队规定义。通过递归将左侧的数据排序好后，再通过递归将右边的数据排序好，当两边都排序完后，整个过程就结束了

图解：

![快速排序](C:\Users\CHIYODAMOMO\Pictures\Saved Pictures\快速排序.PNG)

快速排序API设计：

```java
//创建一个Quick类，这个类就是快速排序算法的实现类，其中有这些东西：
//1.public static void sort(Comparable[] a)//用于对数据进行排序
//2. private static void sort(Comparable[] a,int lo,int hi)//对数据的索引从lo到hi之间的元素进行排序
//3. public static int partition(Comparable[] a,int lo,int hi)//对数据的索引lo到索引hi之间的数据进行分组，并返回分组界限对应的索引.
//4.public static boolean greater(Comparable v,Comparable w)//这个方法用来比较v是否小于w
//5.public static void exch(Comparable[] a,int i,int j) //这个方法用于交换数组中索引值i与索引值为j的元素的值
```

```java
public class KuaiSuPaiXu {
    //实现快速算法

    public static void sort(Comparable[] a){
        //用于对数据进行排序
        int lo=0;
        int hi=a.length-1;
        sort(a,lo,hi);
    }

    private static void sort(Comparable[] a,int lo,int hi){
        //对数据的索引从lo到hi之间的元素进行排序
        //安全校验
        if(hi <= lo){
            return;
        }
        //对索引lo到hi之间的数据进行分组
        //左子组右子组
        int partition = partition(a, lo, hi);//返回分界值所在的索引(分界值变换过位置后的位置)
        //让两组都有序
        sort(a,lo,partition-1);//排序左子组
        sort(a,partition+1,hi);//排序右子组
    }
    public static int partition(Comparable[] a,int lo,int hi){
        //对数据的索引lo到索引hi之间的数据进行分组，并返回分组界限对应的索引
        //分组的原理：
        /*1.找一个基准值，一般就是数据的第一个，然后用两个指针分别指向数据的头部和尾部，
          2.从尾部向头部寻找一个比基准值小的元素，找到就停止寻找，并记录指针的位置
          3.再从头部向尾部搜索一个比基准值大的元素，找到就停止寻找，并记录指针位置
          4.交换当前左边指针和右边指针对应的值
          5.重复以上步骤，直到排序结束
        * */
        //定义两个指针：
        int left=lo;//左指针(头指针)
        int right=hi+1;//右指针(尾指针)
        //确定分界值：源数据的第一个
        Comparable key = a[0];
        while(true){
            //先从尾到头扫描，找到比分界值小的元素然后停止
            while (greater(key,a[--right])){
                if(right==lo)
                    break;
            }
            //从头到尾扫描，找到比分解值大的元素然后停止
            while (greater(a[++left],key)){
                if(left==hi)
                    break;
            }
            //交换上面找到的元素(要检测两个指针是否相等，是的话就要结束扫描)
            if(left>=right){
                break;
            }else{
                exch(a,left,right);
            }
        }
        //交换分界值
        exch(a,lo,right);
        //返回分界值所在的索引
        return right;
    }





    public static boolean greater(Comparable v,Comparable w){
        //这个方法用来比较v是否小于w
        return v.compareTo(w)<0;
    }
    public static void exch(Comparable[] a,int i,int j) {
        //这个方法用于交换数组中索引值i与索引值为j的元素的值
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

#### 排序稳定性

稳定性是指一组数据中有若干元素，其中A元素与B元素相等，且A原来在B的前面，当使用某种排序算法排序数据时，的到的最终结果A还是在B前面，就说这个算法是稳定的。当数据只需要一次排序时，稳定性是没有意义的，如果需要多次排序 ，那么稳定性就比较重要了，比如要对一组商品进行排序，第一次按价格，第二次按销量，前者由低到高排序，后者由高到低排序，如果第二次使用了稳定的排序算法，那么就可以使得相同销量的对象依旧保持价格高低的顺序展现，只有销量不同的对象才需要重新排序，这样既保持了第一次排序的原有意义，还能减小系统开销

常见排序算法的稳定性：

冒泡排序是一个稳定的算法，选择排序是一个不稳定算法，插入排序是一个稳定算法，希尔排序是一个不稳定的算法，归并排序是一个稳定算法，快速排序是一个不稳定的算法









































## 数据结构

数据结构与算法的关系：

1、数据结构是一门研究组织数据方式的学科，有了编程也有了数据结构，学好可以编写出更加简洁，更有效率的代码

2、数据结构要多考虑现实问题，用程序来解决

3、程序=数据结构+算法

4、数据结构是算法的基础

在现实生活中，有许多问题都是需要用数据结构和算法来解决的，比如约瑟夫问题等

### 线性数据结构

1、这种数据结构是最为常用的，其特点是数据元素之间存在一对一的线性关系

2、线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表(数组)，顺序表中的存储元素是连续的，链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素结点中存放数据元素以及相邻元素的地址信息

3、线性数据结构常见的有：数组，队列，链表，栈



### 非线性数据结构

1、这种数据结构种的数据元素之间已经不是一对一的关系了，基本都是一对多

2、非线性数据结构有：二维数组，多维数组，广义表，树结构，图结构



### 常见的数据结构

#### 线性表

线性表是最基本最简单，也是最常用的一种数据结构，一个线性表是n个具有相同特性的数据元素的有限序列，它是一种线性结构。

前驱元素：若A元素在B元素的前面，则A是B的前驱元素

后继元素：若B元素在A元素的后面，则B是A的后继元素

头节点：即第一个数据元素，没有前驱的元素

尾节点；即最后一个数据元素，没有后继的元素

线性表的特征：数据元素之间由一种“一对一”的逻辑关系，除了头尾节点，其它节点有且仅有一个前驱元素和后继元素

线性表的分类：线性表中的数据存储方式是可以顺序存储，也可也是链式存储，因此也分为顺序表和链表

##### 顺序表

顺序表是在计算机内存中一数组形式保存的线性表，顺序存储是指用一组地址连续的存储单元，一次存储线性表中的各个元素，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系

顺序表的实现：



```java
public class ShunXuBiao<T> {//顺序表的实现
    //顺序表是一个能够存储任意类型数据的表，使用泛型定义泛型
    private T[] eles;//存储元素的数组
    private int N;//当前表的长度
    //构造方法：
    public ShunXuBiao(int capacity) {
        //创建容量为capacity的顺序表对象
        this.eles = (T[]) new Object[capacity];
        this.N = 0;
    }

    public void clear(){
        //清空表
        this.N = 0;
    }

    public boolean isEmpty(){
        //判断表是否为空
        return N==0;
    }
    public int length(){
        //获取表中元素的个数
        return N;
    }
    public T get(int i){
        //读取并返回表中第i个元素
        return eles[i];
    }
    public void insert(int i,T t){
        //在表的第i个元素前插入一个值为t的数据元素
        for(int index = N-1;index > i;index--){
            eles[index]=eles[index-1];
        }
        eles[i]=t;
        N++;
    }
    public void insert(T t){
        //向表中添加一个元素t
        eles[N++] = t;
    }
    public T remove(int i){
        //删除并返回表中的第i个数据元素
        T t = eles[i];
        for(int index=i;index<N-1;index--){
            eles[index]=eles[index+1];
        }
        this.N--;//元素个数-1
        return t;
    }
    public int indexOf(T t){
        //返回表中首次出现的指定的数据元素的位序号，如果不存在就返回-1
        for (int i = 0; i < N; i++) {
            if(eles[i].equals(t)){
                return i;
            }
        }
        return -1;
    }
}
```

顺序表的遍历

一半作为存储数据的容器，都需要向外提供遍历的方式，在java中，遍历集合的方式一般都是用foreach循环，让我们的顺序表实现这个循环，需要实现Iterable接口，并重写iterable方法，在外面这个顺序表的内部提供一个内部类，实现iterator接口，重写hasNext方法和next方法

```java
public Iterator iterator() {//对外提供的一个遍历循环
        //返回一个Iterator对象
        return new shunXubiao();
    }

    class shunXubiao implements Iterator{
    //内部类，提供Iterator对象
        private int cusor;
        public shunXubiao(){
            this.cusor=0;
        }
        @Override
        public boolean hasNext() {//该方法是判断一个元素后是否还有元素

            return cusor<N;
        }

        @Override
        public Object next() {//该方法是进行遍历的
            return eles[cusor++];
        }
    }
```

顺序表的容量可变

当我们在添加元素的时候是需要扩容的，在移出元素的时候需要缩减容量，以达到空间利用率最大化

```java
//表的容量可变实现：
    public void resize(int newsize){
        //定义一个临时数组，指向原数组
        T[] temp = eles;
        //创建新数组
        eles=(T[]) new Object[newsize];
        //把原数组的数据放到新数组中
        for (int i = 0; i < N; i++) {
            temp[i] = eles[i];
        }
    }
```

该方法在添加新元素或者移除元素的时候会用到

java中的ArrayList类也是一个顺序表，它使用数组实现，同样提供了增删改查的方法和扩容和减容的方法以及对外遍历的方法，实现的方式跟我们这个顺序表的方式很像，ArrayList因为具有很强的通用性，有时候并不能高效率的解决一些特定需求，这时我们就得自己实现这种表的结构



##### 链表(Linked List)

链表是有序列表，它在内存中的存储如下：

1、链表以节点的方式来存储

2、每个结点包含data域，next域，next域是指向下一个结点的地址

3、链表的各个结点不一定是连续存储

4、链表还分带头结点的链表和没有头节点的链表，根据实际需求确定使用的链表

图示：

内存中的实际结构：

![链表内存](C:\Users\CHIYODAMOMO\Pictures\Saved Pictures\链表内存.PNG)

链表的逻辑结构：

![链表逻辑结构](C:\Users\CHIYODAMOMO\Pictures\Saved Pictures\链表逻辑结构.PNG)

最后一个节点的next域是null，表示链表结束

头节点不存放具体数据，它的作用是表示单链表的头部，它的next域指向第一个包含数据的节点



单链表的应用实例：

使用带头的单向链表实现一个英雄排行榜管理：

1、完成对英雄的增删改查操作

2、第一种方法添加英雄时，可以直接添加到链表的尾部

3、第二种方法添加英雄时，根据排名将英雄添加到指定位置

创建链表的步骤：

1、创建一个head头节点，作为链表的表头

2、后面每添加一个节点，就直接加入到链表的最后

例子1.

```java
//单向链表的设计：
public class DanLianBiao<T> implements Iterable{//实现单链表
    //因为链表也是一个表，里面可能存储了任意类型的数据，所以我们需要使用泛型
    //对外提供遍历也需要实现Iterable接口
    private Node head;//记录头结点
    private int N;//记录链表长度

    public DanLianBiao() {
        //构造方法,这里初始化头结点
        this.head = new Node(null,null);
        this.N=0;
    }
    public void clear(){
        //清空链表
        head.next=null;
        this.N=0;
    }
    public boolean isEmpty(){
        //判断链表是否为空
        return N==0;
    }
    public int length(){
        //获取链表中元素的个数
        return N;
    }
    public T get(int i){
        //获取并返回链表中的第i个元素
        //通过从头结点遍历i次，就能找到该元素
        Node h = head.next;
        for(int index=0;index<=i-1;index++){
            h=h.next;
        }
        return (T) h.item;
    }
    public void insert(T t){
        //向链表中添加一个元素
        //向最后的位置添加，先遍历到最后
        Node h = head;
        while (h.next!=null){
            h=h.next;
        }
        //遍历到最后后建一个新节点来保存新数据
        Node newNode = new Node(t,null);
        h.next=newNode;
        N++;

    }
    public void insert(T t,int i){
        //向链表的第i个位置添加元素
        //找到i位置前的一个位置，遍历到该位置
        Node n = head;
        for(int index=0;index<=i-1;index++){
            n=n.next;
        }
        Node newNode = n.next;//创建一个结点，指向i位置
        Node newNode2 = new Node(t,newNode);
        n.next= newNode2;//原来i位置的前一个结点的next域指向新节点
        N++;
    }
    public T remove(int i){
        //删除并返回链表中第i个元素
        //找到i位置的前一个位置
        Node n =head;
        for(int index=0;index<i;index++){
            n=n.next;
        }
        Node m = n.next;
        Node x = m.next;
        n.next = x;
        N--;
        return (T) m.item;
    }
    public int indexOf(T t){
        //返回链表中首次出现指定的元素
        Node h = head;
        for(int i=0;h.next!=null;i++){
            h=h.next;
            if(h.item.equals(t))
                return i;
        }
        return -1;
    }
    private class Node<T>{
        //结点类
        T item;//存储数据
        Node next;//指向下一个结点，next域

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
    @Override
    public Iterator iterator() {
        return new Literator();
    }
    private class Literator implements Iterator{
        private Node n;

        public Literator() {
            this.n = head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n=n.next;
            return n.item;
        }
    }
}
```

例子2：

第一种方法添加英雄的代码实现：

```java
class HeroNode{
    public String name;
    public String nickname;
    public int no;
    public HeroNode next; //next域
    //构造方法
    public HeroNode(int hNo,String name,String nikename){
        this.hNo = hNo;
        this.name = name;
        this.nikename = nikename;
    }
    //为了方便显示还可以重写toString方法（在IDE里快速写）
}
//定义SingletLinkedList链表来管理我们的英雄
class SingletLinkedList{
    //初始化头节点
    private HeroNode head = new HeroNode(0,"","");
    //添加节点到单项链表中
    public HeroNode getHead(){
        return head;
    }
    //思路：
    //1、找到当前链表的最后节点
    //2、将最后的节点的next域指向新的节点
    public void add(HeroNode heroNode){
        //head节点不能动，我们需要一个辅助遍历temp
        HeroNode temp = head;
        //遍历链表，找最后一个节点
        while(true){
            if(temp.next==null){
                break;
            }else{
                temp = temp.next;
            }
        }//退出循环后，temp就会指向最后的节点
        temp.next = heroNode;
    }
    //显示链表
    public void list(){
        if(head.next==null){
            System.out.println("链表空");
            return;
        }else{
            HeroNode temp = head.next;
            while(true){
                if(temp==null){
                    break;
                }else{
                    System.out.println("节点信息:"+temp)
                    temp = temp.next;
                }
            }
        }
        
    }
}
//使用链表
public static void mian(String[] args){
    //测试链表
    //创建节点
    new HeroNode(1,"一号"，"哈批")
}

```

第二种按顺序添加英雄的代码实现：

```java
public void addlist(HeroNode heroNode){
            //头节点不能动，需要一个辅助指针来帮助我们寻找新变量要加进去的位置
            //单链表，我们找的temp是位于添加位置的第一个节点，否则插入不了
            HeroNode temp = head;
            boolean flag = false; //flag标志表示添加的编号是否存在，默认为不存在
            while (true){
                if(temp.next==null){
                    break;
                }
                if (temp.next.hNo>heroNode.hNo){
                    //位置找到，在temp后面插入
                    break;
                }else if (temp.next.hNo==heroNode.next.hNo){
                    flag = true;
                    break;
                }
                temp = temp.next;//后移，遍历链表
            }
            if (flag){
                //判断flag的值，如果是ture就不能添加了
                System.out.printf("已存在编号%d，不可加入\n",heroNode.hNo);
            }else {
                heroNode.next = temp.next;
                temp.next = heroNode;
            }
        }
```

修改节点:先要判断链表是否为空，若不为空就需按照要修改的节点，找到了节点就直接更新，找不到就输出没找到

```java
//链表修改节点信息(节点的next域和编号不可修改)
        public void updata(HeroNode newheroNode){
            //根据传入的信息来修改
            //先判断链表是否为空
            if (head.next==null){
                System.out.println("链表空");
                return;
            }
            //寻找要改的节点
            HeroNode temp = head.next;
            boolean flag = false;//表示是否找到该节点
            while (true){
                if (temp==null){
                    break;//链表遍历结束
                }
                if(temp.hNo==newheroNode.hNo){
                    //找到了要改的节点
                    flag = true;
                    break;
                }
                temp = temp.next;
            }
            if(flag){
                temp.name = newheroNode.name;
                temp.nikename = newheroNode.nikename;
            }else {
                //没找到对应编号的节点
                System.out.printf("没找到该节点：%d",newheroNode.hNo);
            }
        }
```

删除节点：

思路：找到待删除节点的前一个结点，然后让该结点的next域指向待删除结点的后一个结点,被删除的结点不会有其它的指向引用，会被当成垃圾删除

```java
public void removeLink(int no){
    //head节点不能动
    //需要一个辅助变量指向待删除节点的前一个节点
    //用temp.next.no和待删除节点的no比较
    HeroNode temp = head;
    boolean flag = false;//标志是否找到待删除节点
    while(true){
        if(temp.next==null){//到了链表的最后
            break;
        }
        if(temp.next.no==no){
            //找待删除节点的前一个节点
            flag = true;
            break;
        }
        temp = temp.next;
    }
    //判断flag
    if(flag){
        temp.next = temp.next.next;
    }else{
        System.out.print("找不到要删除的节点%d",no);
    }
}
```

获取单链表的节点个数(带头节点的链表要去掉头节点)

```java
public void getLength(HeroNode head){
    if(head.next == null){
        System.out.println("link empty");
        
    }
    HeroNode cur = head.next;  //辅助变量
    int length=0;
    while(cur!=null){
        length++;
        cur=cur.next;
    }
    return length;
}
```

查找链表中的倒数第k个节点

思路：1.先接收head节点，同时接收一个index(表示倒数第index个节点)

​             2.将链表遍历，得到链表长度

​		     3.得到size后，遍历链表size-index个，就能得到了，然后返回该节点

```java
public static HeroNode finLastIndexNode(HeroNode head,int index){
    if(head.next==null){
        System.out.println("empty");
    }
    //获取链表长度
    int size = getLength(head);
    //第二次遍历找到size-index的位置
    //先检验index
    if(index<=0||index>size){
        return null;
    }
    HeroNode cur = head.next;//辅助变量
    for(int i =0;i<size-index;i++){
	cur = cur.next;
    }
    return cur;
}
```

双向链表：

含有数据域，和两个指向域，一个指向前面的结点，一个指向后面的结点

双向链表的实现：

```java
public class ShuangXiangLianBiao<T> implements Iterable<T>{


    //双向链表的设计
    private class Node<T>{
        T item;//数据
        Node pre;//pre域，指向上一个结点
        Node next;//next域，指向下一个结点
        public Node(T item, Node pre, Node next) {
            this.item = item;
            this.pre = pre;
            this.next = next;
        }


    }

    private Node head;//记录头结点
    private Node last;//记录尾节点
    private int N;//链表长度

    public ShuangXiangLianBiao() {
        //构造方法
        //初始化头结点和尾结点
        this.head = new Node(null,null,null);
        this.last = null;
        this.N=0;

    }
    public void clear(){
        //清空链表
        this.head.next=null;
        this.head.pre=null;
        this.head.item=null;
        this.last=null;
        this.N=0;
    }
    public boolean isEmpty(){
        //判断链表是否为空
        return N==0;
    }
    public int length(){
        //获取链表中元素的个数
        return N;
    }

    public void insert(T t){
        //向链表中添加一个元素
        //插入元素的话有两种清空，当前链表为空和不为空的时候
        if (isEmpty()){
                //创建新结点，让它成为尾节点
                Node newnode = new Node(t, head, null);
                last = newnode;
                head.next=last;
       	}else{//如果原链表不是空，先判断尾节点的数据是不是空的，如果是就把该数据放进这个节点里，如果不是就创建新结点，并让前一个结点指向它，并且它成为尾结点                          
                new Node(t,oldnode,null);
                oldnode.next=newnode;
                last = newnode;
               }                   
    }
    public void insert(T t,int i){
        //向链表的第i个位置添加元素
        //找到i位置的前一个结点
        Node Mid = head;
        for(int index=0;index<i;index++){
            Mid=head.next;
        }
        Node newnode = Mid.next;
        Node node = new Node(t, Mid, newnode);
        Mid.next = newnode;
        node.pre=newnode;
        N++;

    }
    public T get(int i){
        //获取并返回链表中的第i个元素
        Node Mid = head;
        for(int index = 0;index<i;index++){
            Mid = Mid.next;
        }
        return (T) Mid.item;
    }
    public T remove(int i){
        //删除并返回链表中第i个元素
        Node Mid = head;
        for (int index=0;index<i;index++){
            Mid = Mid.next;
        }
        Node M = Mid.next;//记录第i个结点
        Node Mnext = M.next;//i的后一个结点
        Mid.next=Mnext;
        Mnext.pre=Mid;
        N--;
        return (T) M.item;
    }
    public int indexOf(T t){
        //返回链表中首次出现指定的元素
        Node Mid = head;
        for(int index=0;Mid.next!=null;index++){
            Mid = Mid.next;
            if (Mid.item.equals(t))
                return index;
        }
        return -1;
    }
    public T getFirst(){
        //获取第一个元素
        if(isEmpty()){
            return null;
        }
        return (T) head.next.item;
    }
    public T getLast(){
        //获取最后一个元素
        if (isEmpty()){
            return null;
        }
        return (T) last.item;
    }
    @Override
    public Iterator<T> iterator() {
        return new Titerator();
    }
    private class Titerator implements Iterator{
        private Node h;

        public Titerator() {
            this.h = head;
        }

        @Override
        public boolean hasNext() {
            return h.next!=null;
        }

        @Override
        public T next() {
            h=h.next;
            return (T) h.item;
        }
    }



}
```

LinkedList实现：java提供的LinkedList集合也是使用双向链表实现，并提供了增删改查等相关方法

###### 链表的应用

* 链表的反转：

  * 链表反转是一个很常见的需求，即将原链表上将数据倒叙，我们可通过递归完成反转，即从原链表的第一个存数据的结点开始，一次递归调用反转每一个结点，直到把最后一个结点反转完毕，整个链表就反转完毕

  * 链表反转的实现：

    ```java
    public Node reverse(Node curr){
            //反转指定结点curr,并返回指定结点
            //该方法会被递归调用，需要出口
            if (curr.next==null){
                head.next=curr;
                return curr;
            }
            //如果还没到尾节点，就进行递归反转当前结点的下一个结点，返回链表反转后当前结点的上一结点
            Node pre = reverse(curr.next);
            //让返回的结点的下一个结点变为当前结点
            pre.next=curr;
            //让当前结点的下一结点变为null
            curr.next=null;
            return curr;
        }
    ```

* 快慢指针

  * 快慢指针是定义两个指针，两个指针的速度一快一慢，以此制造需要的差值，这个差值可以让我们找到链表上相应的结点，一般快指针的速度是慢指针的两倍
  
  * 快慢指针常用于解决这些问题：
    * 中间值问题
    
      * 我们可以用两个指针，一个快指针，一个慢指针，快指针的速度是慢指针的两倍，当快指针遍历完链表的时候，慢指针指向的结点就是中间值
    
      * ```java
        public T getMid(Node<T> first){
                //快慢指针查找中间值
                //先定义两个指针，一快一慢
                Node fast = first;
                Node slow = first;//刚开始都指向第一个结点
                if (fast!=null&&fast.next!=null){
                    fast=fast.next.next;//一次走两步
                    slow=slow.next;//一次走一步
                }
                //遍历结束后返回slow指针指向的结点数据
                return (T) slow.item;
            }
        ```
    
        
    
    * 单向链表是否有环问题
    
      * 单向链表有环是指有元素的next域指向了之前的结点，形成了一个环
    
      * 快慢指针在有环的情况下，它们总有相遇的时候，相遇就意味着这个连表示有环的
    
      * ```java
        public boolean isHuan(Node<T> first){//参数可以直接为头结点
                //用快慢指针来判断链表是否有环
                Node fast = first;
                Node slow = first;
                while (fast!=null&&fast.next!=null){
                    fast=fast.next.next;
                    slow=slow.next;
                    if (fast==slow)
                        return true;
                    
                }
                return false;
            }
        ```
    
        
    
    * 有环链表入口问题
    
      * 环的入口就是形成环的第一个结点
    
      * 当快慢指针相遇时，我们可以判断链表中有环，这时可以重新设置一个一个新指针指向链表起点，且步长与慢指针相同，则满指针与这个新指针相遇的结点就是环的入口
    
      * ```java
        public Node<T> getEntrance(Node<T> first){
                //寻找链表中环的入口
                Node fast = first;
                Node slow = first;
                Node slow1 = null;
                while (fast!=null&&fast.next!=null){
                    fast=fast.next.next;
                    slow=slow.next;
                    if (fast==slow&&slow1==null){
                        slow1=first;
                        continue;
                    }
                    if (slow1!=null){
                        slow1=slow1.next;
                        if(slow1==slow)
                            break;
                    }
                }
                return slow1;
            }
        ```
  
* 循环链表

  * 循环链表就是尾节点的next域是指向头结点的链表
  * 我们只需要在构建链表的时候，让尾节点的next域指向头结点即可

* 约瑟夫问题

  * 即在一个环中，指定一个起始点，往后开始计数一个数值，计数到那个位置就将那个结点拿出，求最后取出来的结点的编号
  
  * 解决方法
  
    ```
    //1.构建一个循环链表，长度可以自行指定
    //2.创建一个计数器count，记录当前报数的值
    //3.遍历循环链表，同时count++，当count到达一定数值时将对应结点删除并将计数器清零
    ```
  
    ```java
    public static void main(String[] args) {
            //解决约瑟夫问题
            //1.构建循环链表
            Node<Integer> first=null;
            Node<Integer> pre=null;
            for (int i=1;i<=41;i++){
                if(i==1){//第一个结点
                    first=new Node<Integer>(i,null);
                    pre=first;
                    continue;
                }
                //不是第一个结点
                Node<Integer> newNode = new Node<>(i, null);
                pre.next=newNode;
                pre=newNode;
                //最后一个结点
                if (i==41){
                    pre.next=first;
                }
    
            }
            Node<Integer> N = first;//检查链表
            /*while (N.next!=first){
                System.out.println(N.item+"|");
                N=N.next;
            }*/
            for (int i=0;i<=41;i++){
                System.out.print(N.item+"|");
                N=N.next;
            }
            //2.创建一个计数器，记录报数值
            int count=1;
            //3.遍历循环链表，同时计数器++，到指定的计数值将结点删除并将计数器清零
            Node<Integer> n = first;//从第一个开始遍历,即当前结点
            Node<Integer> b = null;//记录当前结点的上一个结点
            while (n!=n.next){
                count++;
                if(count==3){
                    b.next=n.next;
                    System.out.print(b.item+"/");
                    count=0;
                }else {
                    b=n;
                    n=n.next;
                }
    
            }
            System.out.print("The last one"+n.item);
        }
    
    
    
    
        private static class Node<T>{//结点类（单链表的）
            T item;//数据
            Node next;//next域
            public Node(T item,Node next){
                this.item=item;
                this.next=next;
            }
        }
    ```

##### 栈

就是栈，先进后出那个，数据进去为进栈，需要读取数据的时候就要从栈顶开始弹出数据

栈的结构：

* 栈顶
* 栈底

这两个东西之间的距离就是一个栈的长度

栈的实现：

```java
//栈设计
public class STACK<T> implements Iterable{
    //实现数据结构:栈
    //栈这个结构可以使用顺序结构也可以使用链式结构
    //这里使用链式结构实现
    private Node head;//栈顶
    private int N;//栈长度

    public STACK() {
        this.head=new Node(null,null);
        this.N=0;
    }



    public boolean isEmpty(){
        //判断栈是否为空
        return N==0;
    }
    public int Size(){
        //栈的长度
        return N;
    }
    public void Push(T t){
        //进栈
        //因为元素是先进后出的，在链式结构中，先放进来的就变成尾节点了
        //每次进栈一个元素，头结点就指向那个新的结点
        if(isEmpty()){
            Node newNode = new Node(t,null);
            head.next=newNode;
            N++;
        }else{
            Node oldNode = head.next;
            Node newNode = new Node(t, null);
            head.next=newNode;
            newNode.next=oldNode;
            N++;
        }

    }
    public T Pop(){
        //出栈（弹出栈顶元素）
        if (isEmpty()){
            System.out.println("空栈,没东西出");
            return null;
        }else{
            Node oldNode = head.next;//即弹出头结点指向的第一个结点
            if (oldNode.next!=null)
                head.next=oldNode.next;
            N--;
            return (T) oldNode.item;
        }
    }



    private class Node<T>{
        //结点类
        public T item;
        public Node next;
        public Node(T item,Node next){
            this.item=item;
            this.next=next;
        }
    }
    @Override
    public Iterator<T> iterator() {
        return new Siterator();//提供外部遍历方法
    }
    private class Siterator implements Iterator{
        private Node n;
        public Siterator() {
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}
```

###### 栈的应用

* 匹配括号问题

  问题描述：给定一个字符串，里面可能包含小括号(),[]这样的括号，我们需要检查字符串中的括号是否成对出现

  ```java
  //我们可以通过将数据存储在栈中，然后一个一个弹出，寻找括号对应的括号，就可以判断是否是一对的括号了
   public static boolean isMatch(String str){
          //用于检测一个字符串中的括号是否匹配
          //解决思路：对给定的字符串依次检验：若是左括号，入栈；若是又括号，出栈一个左括号判断是否与之匹配；
          // 是其他字符，不检验。检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的
          STACK<String> chars = new STACK<>();//用来保存左括号的栈
          char[] chars1 = str.toCharArray();
          for (char c : chars1){
              String s = c+"";
              if (s.equals("(")){
                  chars.Push(s);
              }else if (s.equals(")")){
                  String pop = chars.Pop();
                  if (pop==null){
                      return false;
                  }
              }
          }
          if (chars.Size()==0){
              return true;
          }else {
              return false;
          }
  
      }
  ```

  

* 逆波兰表达式

  

  ```java
  	//逆波兰表达式即后缀表达式，我们平时用的2*3*4/5+1属于中缀表达式，即二元运算符总是置于两个操作数中间的表达式
      //后缀表达式就是运算符是跟在操作数后的，比如上面那个式子，用后缀表达式来写是这样的：2345/*1+
      //后缀表达式的出现是因为，平时用的中缀表达式在计算机中很难使用，计算机需要判断大量的优先级问题
      //这会导致内存的大量浪费，于是就有了后缀表达式
      //后缀表达式常用栈来生成，后缀表达式只需要两种操作，即入栈和出栈，就可以解决任何普通表达式的运算
  
  ```

  中缀表达式生成后缀表达式的算法流程图：

  

  计算后缀表达式的代码实现：

  ```java
  public class KuoHaoPiPeiAndNiBoLanBiaodaShi {
      //用栈的思想来解决括号匹配问题
    //给定一个字符串，里面可能包含小括号(),[]这样的括号，我们需要检查字符串中的括号是否成对出现
      public static boolean isMatch(String str){
          //用于检测一个字符串中的括号是否匹配
          //解决思路：对给定的字符串依次检验：若是左括号，入栈；若是又括号，出栈一个左括号判断是否与之匹配；
          // 是其他字符，不检验。检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的
          STACK<String> chars = new STACK<>();//用来保存左括号的栈
          char[] chars1 = str.toCharArray();
          for (char c : chars1){
              String s = c+"";
              if (s.equals("(")){
                  chars.Push(s);
              }else if (s.equals(")")){
                  String pop = chars.Pop();
                  if (pop==null){
                      return false;
                  }
              }
          }
          if (chars.Size()==0){
              return true;
          }else {
              return false;
          }
  
      }
      public static long SuanShu(String[] strings){
          //逆波兰表达式
          //逆波兰表达式即后缀表达式，我们平时用的2*3*4/5+1属于中缀表达式，即二元运算符总是置于两个操作数中间的表达式
          //后缀表达式就是运算符是跟在操作数后的，比如上面那个式子，用后缀表达式来写是这样的：2345/*1+
          //后缀表达式的出现是因为，平时用的中缀表达式在计算机中很难使用，计算机需要判断大量的优先级问题
          //这会导致内存的大量浪费，于是就有了后缀表达式
          //后缀表达式常用栈来生成，后缀表达式只需要两种操作，即入栈和出栈，就可以解决任何普通表达式的运算
          //生成后缀表达式的代码先不管，我们先实现后缀表达式的计算
          //我们可以遍历得到的后缀表达式，用一个栈来保存操作数，当遇到运算符的时候，将操作数出栈进行运算
          /*解法：
          * 首先建立一个栈，用来存操作数
          * 然后遍历逆波兰表达式
          * 判断每一个元素是操作数还是运算符
          * 是运算符就从栈里弹出操作数进行运算
          * 是操作数就入栈
          * 一直到栈中只剩最后一个元素，这个元素就是逆波兰表达式的结果
          * */
          STACK<Integer> stack = new STACK<>();//存操作数的
          for (int i=0;i<strings.length;i++){
              String s = strings[i];
              switch (s){
                  case "+":
                      Integer pop1 = stack.Pop();
                      Integer pop2 = stack.Pop();
                      Integer result = pop2+pop1;
                      stack.Push(result);
                      break;
                  case "-":
                      Integer pop3 = stack.Pop();
                      Integer pop4 = stack.Pop();
                      Integer result1 = pop4-pop3;
                      stack.Push(result1);
                      break;
                  case "*":
                      Integer pop5 = stack.Pop();
                      Integer pop6 = stack.Pop();
                      Integer result2 = pop6*pop5;
                      stack.Push(result2);
                      break;
                  case "/":
                      Integer pop7 = stack.Pop();
                      Integer pop8 = stack.Pop();
                      Integer result3 = pop8/pop7;
                      stack.Push(result3);
                      break;
                  default:
                      stack.Push(Integer.parseInt(s));
                      break;
              }
          }
          int result = stack.Pop();
          return result;
      }
  }public static long SuanShu(String[] strings){
          //逆波兰表达式
          //逆波兰表达式即后缀表达式，我们平时用的2*3*4/5+1属于中缀表达式，即二元运算符总是置于两个操作数中间的表达式
          //后缀表达式就是运算符是跟在操作数后的，比如上面那个式子，用后缀表达式来写是这样的：2345/*1+
          //后缀表达式的出现是因为，平时用的中缀表达式在计算机中很难使用，计算机需要判断大量的优先级问题
          //这会导致内存的大量浪费，于是就有了后缀表达式
          //后缀表达式常用栈来生成，后缀表达式只需要两种操作，即入栈和出栈，就可以解决任何普通表达式的运算
          //生成后缀表达式的代码先不管，我们先实现后缀表达式的计算
          //我们可以遍历得到的后缀表达式，用一个栈来保存操作数，当遇到运算符的时候，将操作数出栈进行运算
          /*解法：
          * 首先建立一个栈，用来存操作数
          * 然后遍历逆波兰表达式
          * 判断每一个元素是操作数还是运算符
          * 是运算符就从栈里弹出操作数进行运算
          * 是操作数就入栈
          * 一直到栈中只剩最后一个元素，这个元素就是逆波兰表达式的结果
          * */
          STACK<Integer> stack = new STACK<>();//存操作数的
          for (int i=0;i<strings.length;i++){
              String s = strings[i];
              switch (s){
                  case "+":
                      Integer pop1 = stack.Pop();
                      Integer pop2 = stack.Pop();
                      Integer result = pop2+pop1;
                      stack.Push(result);
                      break;
                  case "-":
                      Integer pop3 = stack.Pop();
                      Integer pop4 = stack.Pop();
                      Integer result1 = pop4-pop3;
                      stack.Push(result1);
                      break;
                  case "*":
                      Integer pop5 = stack.Pop();
                      Integer pop6 = stack.Pop();
                      Integer result2 = pop6*pop5;
                      stack.Push(result2);
                      break;
                  case "/":
                      Integer pop7 = stack.Pop();
                      Integer pop8 = stack.Pop();
                      Integer result3 = pop8/pop7;
                      stack.Push(result3);
                      break;
                  default:
                      stack.Push(Integer.parseInt(s));
                      break;
              }
          }
          int result = stack.Pop();
          return result;
      }
  ```
  
  

##### 稀疏数组(SparseArray)

一个五子棋程序，有存盘退出和续上盘的功能，我们使用二维数组来记录棋盘信息，棋子没有点上的地方都是0，这就记录了很多没有意义的数据，这些0就属于没有意义的东东，我们可用稀疏数组来保存该数组

稀疏数组：当一个数组中大部分元素都是0，或同为一个值的数组时，我们可用用稀疏数组来保存该数组

处理方法：1、记录数组一共有几行几列，有多少不同的值

​					2、把具有不同值的元素的行列及值记录在一个小规模数组（这个小规模数组就是稀疏数组）中，从而缩小程序规模

比如下面这个例子：

一个含有大量0的数组，我们将不为0值的值记录在另一个数组中，这样我们就把原本6 * 7的数组转换为了一个3 * 9的数组

![稀疏数组](C:\Users\CHIYODAMOMO\Pictures\Saved Pictures\稀疏数组.PNG)

应用实例：

1、使用稀疏数组来保存二维数组(地图，棋盘)

2、将稀疏数组转换为原来的二维数组

二维数组转换为稀疏数组的解法：

1、遍历原来的数组，获取有效数据个数

2、根据有效数据个数创建稀疏数组

3、将二维数组的有效数据存入稀疏数组

稀疏数组恢复为二维数组的解法：

1、读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组

2、读取稀疏数组后面行的数据，将对应数据赋值给二维数组

代码实现：

```java
public static void main(String[] args){
	//创建一个原始二维数组11*11
    //0表示没有棋子，1表示黑子，2表示白子
    int chessArr1[][] = new int[11][11];
    chessArr1[1][2] = 1;.
    chessArr1[2][3] = 2;
    //将二维数组转换为稀疏数组
    //sum表示有效数据个数
    int sum = 0;
    //遍历二维数组，获取有效数据
    for(int i=0;i<chessArr1.length;i++){
		for(int j=0;j<chessArr1.length;j++){
            if(chessArr1[i][j]!=0){
                sum++;
            }
        }
    }
    //创建对应的稀疏数组
    int spareseArr[][]  =new int[sum+1][3];
    //给稀疏数组赋值
    spareseArr[0][0] = chessArr1.length;
    spareseArr[0][1] = chessArr1.length;
    spareseArr[0][2] = sum;
    //将非零值存入稀疏数组
    int count = 0;//记录是第几个非0数据
    for(int i=0;i<chessArr1.length;i++){
		for(int j=0;j<chessArr1.length;j++){
            if(chessArr1[i][j]!=0){
                count++;
                spareseArr[count][0] = i;
                spareseArr[count][1] = j;
                spareseArr[count][2] = chessArr1[i][j]l;
            }
        }
    }
    //将稀疏数组恢复成二维数组
    int chessArr2[][] = new int[spareseArr[0][0]][spareseArr[0][1]];
    for(int i = ;i<spareseArr.length;i++){
        chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; 
    }
    
}
```



##### 队列

银行叫号完成服务就属于一种队列，队列是一个有序列表，可用数组或链表来实现，队列遵循先入先出的原则，与栈相反

队列的实现:

​		数组的实现：队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下，其中maxSize是队列的最大容量

​       						 由于队列的输出与输入分别是从数据的前端和后端来处理，所以我们需要两个遍历front及rear来记录队列前后端的下标(指针)

数组模拟队列的思路分析：

1、我们将数据存入队列中的时候，尾指针需要向后移动，即rear+1，当头指针front=rear时表示队列为空

2、当尾指针的值小雨队列最大下标maxSize-1时，队列未满，可将数据存入，否则无法存入

代码实现：

```java
public class DuiLie<T> implements Iterable{
    //实现数据结构：队列
    //队列是先入后出，可以使用数组或者链表来实现，这里使用链表实现
    private int N;
    private Node head;
    private Node last;



    private class Node{//结点类
        public T item;
        public Node next;
        public Node(T item,Node next){
            this.item=item;
            this.next=next;
        }
    }
    public DuiLie(){
        this.N=0;
        this.head=new Node(null,null);
        this.last=null;
    }
    public boolean isEmpty(){
        //队列是否为空
        return N==0;
    }
    public int Size(){
        //队列元素个数
        return N;
    }
    public void enqueue(T t){
        //插入元素
        if (last==null){
            last=new Node(t,null);
            head.next=last;
        }else {
            Node old = last;
            last = new Node(t, null);
            old.next = last;
        }
        N++;
    }
    public T deenqueue(){
        //从队列中拿出元素
        if (isEmpty()){
            System.out.println("没有东东");
            return null;
        }else {
            Node oldfirst = head.next;
            head.next=oldfirst.next;
            N--;
            if (isEmpty()){
                last=null;
            }
            return oldfirst.item;
        }

    }
    @Override
    public Iterator iterator() {
        return new Ite();
    }
    private class Ite implements Iterator{
        private Node n;
        public Ite() {
            this.n=head;
        }
        @Override
        public boolean hasNext() {
            return n.next != null;
        }

        @Override
        public Object next() {
            return null;
        }
    }
}

```



```java
class ArrayQueue{
    private int maxSize; //队列最大容量
    private int front;//队列头
    private int rear;//队列尾
    private int[] arr;//存放数据的队列
    //构造方法：
    public ArrayQueue(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1;    //队列头指针
        rear = -1;     //队列尾指针
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }
    //判断队列是否为满
    public boolean isFull(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        if(isFull()){
            System.out.println("队列满，无法加入数据");
            return;
        }else{
            rear++;//尾指针后移
            arr[rear] = n;
        }
    }
    //出队列方法
    public int getQueen(){
        //要判断队列是否空，不为空才能取数据
        if(isEmpty()){
            throw new RuntimeException("队列空")；//抛异常
        }else{
            front++;//头指针后移
            return arr[front];
        }
    }
    //显示队列内的数据
    public void showQueue(){
        //判断队列是否为空，为空就显示不了数据
        if(isEmpty()){
            System.out.println("队列空，没数据");
            return;
        }else{
            for(int i=0;i<arr.length;i++){
                System.out.println("arr[%d]=%d\n",i,arr[i])
            }
        }
    }
    //显示队列头
    public void showHead(){
		if(isEmpty()){
            throw new RuntimeException("队列空")；
        }else{
           return arr[front+1];
        }
    }
}
//测试：
public static void mian(String[] args){
    //创建一个队列
    ArrayQueue arrayQueue = new ArrayQueue(3);
    char key = '';  //接收用户输入数据
    Scanner scanner = new Scanner(System.in);//输入数据
    boolean loop = true;
    //输出一个菜单
    while(loop){
        System.out.println("s(show):显示队列");
        System.out.println("e(exit):退出程序");
        System.out.println("a(add):添加数据到队列");
        System.out.println("g(get):从队列取数据");
        System.out.println("h(head):查看队列头");
        key = scanner.next.charAt(0);//接受一个字符
        //判断用户需要的功能
        switch(key){
            case 's':
                arrayQueue.showQueue();
                break;
            case 'e':
                scanner.close():
                loop = false;
                break;
            case 'a':
                System.out.print("请输入一个数据");
                int value = scanner.nextInt();
                arrayQueue.addQueue(value);
                break;
            case 'g':
                //可能会有异常
                try{
                    int res = queue.getQueue();
                    System.out.println("取出的数据是：%d\n",res);
                }catch(Exception e){
                    System.out.println(e.getMessage());
                }                
                break;
            case 'h':
                try{
                    int res = queue.getHead();
                    System.out.println("头数据是：%d\n",res);
                }catch(Exception e){
                    System.out.println(e.getMessage());
                }    
                break;
            default:
                break;
        }
    }
    System.out.println("程序退出")
}

```

数组模拟的队列有个缺点，已经用过的空间就不能再用了，会造成空间的浪费，所以我们要用环形队列的方式来进行操作,通过算法来将这个数组变为环形数组（核心是使用取模的方法）

思路分析：

1、front变量的含义变为指向队列的第一个元素，即arr[front]是队列的第一个元素,front初始为0

2、rear变量的含义变为指向队列的最后的一个元素的后一个元素，即arr[rear-1]是队列的最后一个元素，这样可空出一个空间作为约定，rear初始为0

3、当队列满时，(rear+1) % maxSize == front

4、当队列空时，rear == front

5、队列中有效数据的个数：(rear+maxSize-front)%maxSize

优化代码：

```java
class CircleArrayQueue{
    private int maxSize; //队列最大容量,这里的最大容量要比设置的少一个，因为有一个是约定的空间
    private int front;//队列头
    private int rear;//队列尾
    private int[] arr;//存放数据的队列
    //构造方法：
    public ArrayQueue(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = 0;    //队列头指针
        rear = 0;     //队列尾指针
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }
    //判断队列是否为满
    public boolean isFull(){
        return (rear+1) % maxSize == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        if(isFull()){
            System.out.println("队列满，无法加入数据");
            return;
        }else{            
            arr[rear] = n;
            rear = (rear+1) % maxSize;
        }
    }
    //出队列方法
    public int getQueen(){
        //要判断队列是否空，不为空才能取数据
        if(isEmpty()){
            throw new RuntimeException("队列空")；//抛异常
        }else{//front是指向队列的第一个元素
            //1、先把front对应的元素保留到一个临时变量中
            //2、将front后移,要考虑取模，不然可能会越界
            //3、将带有front对应元素的临时变量作为返回值返回
            int value;
            value = arr[front];
            front = (front+1) % maxSize;
            return value;
        }
    }
    //显示队列内的数据
    public void showQueue(){
        //判断队列是否为空，为空就显示不了数据
        if(isEmpty()){
            System.out.println("队列空，没数据");
            return;
        }else{
            //从front开始遍历，遍历有效数据的个数次
            for(int i=front;i<front+size();i++){
                System.out.println("arr[%d]=%d\n",i % maxSize,arr[i % maxSize])
            }
        }
    }
    //求出队列中有效数据的个数
    public int size(){
        return (rear + maxSize - front) % maxSize;
    }
    //显示队列头
    public void showHead(){
		if(isEmpty()){
            throw new RuntimeException("队列空")；
        }else{
           return arr[front];
        }
    }
}
```

#### 非线性表：

##### 符号表

符号表的主要目的是将一个键和一个值联系起来，符号表可以存储的数据元素是一个键值对数据，我们可以根据键来查找对应的数据，符号表中，键是唯一的，可以很精准的查找对应值

代码实现：

```java
public class FuHaoBiao<Key,Value> {
    //实现数据结构：符号表
    //符号表也可以通过链表或数组实现，这里使用链表使用
    private class Node<Key,Value>{
        public Key key;
        public Value value;
        public Node next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
    private Node head;//头结点
    private int N;//表的长度
    public FuHaoBiao() {
        this.head=new Node(null,null,null);
        this.N=0;
    }
    public boolean isEmpty(){
        return N==0;
    }
    public int Size(){
        return N;
    }
    public void put(Key key,Value value){
        //插入键值对
        //当符号表中已经存在了键为key的键，只需要找到该键值对，将值替换为value
        Node n = head;
        while (n.next!=null){
            n=n.next;
            if(n.key==key){
                n.value=value;
                return;
            }
        }
        //如果符号表中没有对应键，就要新加一个键值对
        Node newnode = new Node(key,value,null);
        Node oldnode = head.next;
        newnode.next=oldnode;
        head.next=newnode;
        N++;
    }
    public void put(Key key,Value value){
    	//有序符号表
        //主要是这里与普通的符号表不一样
        Node curr = head.next;
        Node pre = head;
        while (curr!=null&&key.compareTo(curr.key)>0){
            pre=curr;
            curr=curr.next;
        }
        if (curr!=null&&key.compareTo(curr.key)==0){
            curr.value=value;
            return;
        }
        Node node = new Node(key, value, curr);
        pre.next=node;
        N++;
    }
    public void delete(Key key){
        //删除某个键对应的键值对
        Node n = head;
        while (n.next!=null){
            n=n.next;
            if(n.key==key){
                n.next=n.next.next;
                N--;
                return;
            }else {
                System.out.println("没有该结点，没法删除");
            }
        }
    }
    public Value get(Key key){
        //获取某个键对应的值
        Node n = head;
        while (n.next!=null){
            n=n.next;
            if (n.key==key){
                return (Value) n.value;
            }
        }
        return null;
    }
}
```

##### 树：

```
    //树：树是由n(n>=1)个有限结点组成的一个具有层次关系的集合，它是根朝上，叶朝下的一种倒立树的结构
    //我们在符号表中，符号表增删改查的操作，随元素个数的增多，所用的时间是线性增长的，为了提高运算效率，
    //我们就需要树这种数据结构
    //树的特点；
    //1.每个结点都有零个或多个子结点
    //2.没有父结点的结点为根节点
    //3.每一个非根结点只有一个父结点
    //4.每个结点及其后代结点整体上可以看作是一棵树，称为当前结点的父结点的一个子树
    //树的一些相关词语：
    //结点的度：一个结点含有的子树的个数称为结点的度
    //叶结点：度为0的结点称为叶结点，也可称作终端结点
    //分支结点：度不为0的结点成为分支结点，也可称作非终端结点
    //结点的层次：从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推
    //结点的层序编号：将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数
    //树的度：书中所有结点的度的最大值
    //树的高度(深度)：树中结点的最大层次
    //森林：m(m>=0)个互不相交的树的集合，将一颗非空树的根结点删去，树就变成了一个森林，
    //给森林增加一个统一的根结点，森林就变成了一棵树
    //孩子结点：一个结点的直接后继结点称为该结点的孩子结点
    //双亲结点(父结点)：一个结点的直接前驱称为该结点的双亲结点
    //兄弟结点：同一双亲结点的孩子结点称为兄弟结点
    //二叉树：即度不超过2的树(任意一个结点最多有两个子结点)3
    //满二叉树：每一个层的结点数都达到最大值，则这个二叉树就是满二叉树
    //完全二叉树：叶结点只能出现在最上层和最下层，并且最下面一层的结点都集中在该层最左边若干位置的二叉树就是完全二叉树
```

代码实现：

```java
private class Node<Key extends Comparable,Value>{
    private class Node<Key extends Comparable,Value>{
            //结点类
            public Key key;
            public Value value;
            public Node left;//记录左子结点
            public Node right;//记录右子结点

            public Node(Key key, Value value, Node left, Node right) {
                this.key = key;
                this.value = value;
                this.left = left;
                this.right = right;
            }
        }
        private Node root;//记录根结点
        private int N;//记录数中元素个数

        public Shu() {
            this.root=null;
            this.N=0;
        }
        public void put(Key key,Value value){
            //向树中插入键值对
            //实现向树中插入元素的思想：
            /*
            1.如果当前树中一个结点都没有，就可以直接把要插入的结点作为根节点
            2.如果当前树不是空的，就从根节点开始
             2.1：如果新节点的key小于当前结点的key，就继续找当前结点的左子结点
             2.2：如果新节点的key大于当前结点的key，就继续找当前结点的右子结点
             2.3：如果新节点的key等于当前结点的key，即树种已存在这样的结点，新节点替换原结点
            * */
            root = put(root,key,value);//向整个树插入结点


        }
        public Node put(Node x,Key key,Value value){
            //在指定树x上，添加一个键值对，返回添加后的新树
            //判断x子树是否为空，若为空，新节点直接作为根节点，若不为空，就按上面的规则插入
            if (x==null){
                N++;
                return new Node(key,value,null,null);
            }
            if( key.compareTo(x.key)>0){
                x.right=put(x.right,key,value);
            }else if (key.compareTo(x.key)<0){
                x.left=put(x.left,key,value);
            }else{
                x.value=value;
            }
            N++;
            return x;
        }
        public Value get(Key key){
            //从书中找出某个键对应的值
            return get(root,key);
        }
        public Value get(Node x,Key key){
            //从指定的树x中找出某个键对应的值
            //判断x子树是否为空，若为空就输出树没东西，如果不为空就查
            if (x==null){
                System.out.println("shu is empty");
                return null;
            }
            if (key.compareTo(x.key)>0){
                return (Value) get(x.right,key);
            }else if (key.compareTo(x.key)<0){
                return (Value) get(x.left,key);
            }else {
                return (Value) x.value;
            }
        }
        public void delete(Key key){
            //删除某个键对应的某个键值对
            /*删除树中结点的思想：
            1.找到要删除的结点
            2.找到要删除结点右子树中的最小结点
            3.删除右子树中的最小结点
            4.让被删除结点的左子树成为最小结点的左子树，让被删除结点的右子树成为最小节点的右子树
            5.让被删除结点的父结点指向最小结点
            * */
            delete(root,key);

        }
        public Node delete(Node x,Key key){
            //删除指定树x中键值对应的某个键值对
            //判断x子树是否是空的，是的话就报空，不是就按上面的规则删除
            if (x==null){
                System.out.println("shu is empty");
                return null;
            }
            N--;
            if (key.compareTo(x.key)>0){
                x.right = delete(x.right,key);

            }else if (key.compareTo(x.key)<0){
                x.left = delete(x.left,key);

            }else {
                //删除的操作
                if(x.right==null){
                    System.out.println("wu you zishu ");
                    return x.left;
                }
                if (x.left==null){
                    System.out.println("wu zuo zishu");
                    return x.right;
                }
                Node minNode = x.right;
                while (minNode.left!=null){
                    minNode = minNode.left;

                }
                Node n = x.right;
                while (n.left!=null){
                    if (n.left.left==null){
                        n.left=null;
                    }else {
                        n=n.left;
                    }
                }
                minNode.left=x.left;
                minNode.right=x.right;
                x=minNode;
            }

            return x;
        }
        public int Size(){
            //树中元素的个数
            return N;
        }
        public Key min(){
            //查找树中最小的键
            return (Key) min(root).key;
        }
        private Node min(Node x){
            //找出指定树中查出最小的键所在的结点
            if (x==null){
                System.out.println("shu is empty");
                return null;
            }

            if (x.left!=null){
                return  min(x.left);
            }else {
                return x;
            }
        }
        public Key max(){
            //查找树中最大的键
            return (Key) max(root).key;
        }
        private Node max(Node x){
            //查找树x中键最大的结点
            if (x==null){
                System.out.println("shu is empty");
                return null;
            }
            if (x.right!=null){
                return max(x.right);
            }else {
                return x;
            }
        }
}
```

二叉树的基础遍历：

* 根据根节点什么时候被访问，分为以下三种遍历方式

* 前序遍历：先访问根结点，再访问左子树，最后访问右子树

* 中序遍历：先访问左子树，中间访问根结点，最后访问右子树

* 后续遍历：先访问左子树，再访问右子树，最后访问根结点

  ```java
  //遍历树：
      //前中后序遍历用到了一种遍历思想：深度优先算法
      //前序遍历：
      public DuiLie<Key> preErgodic(){
          //使用前序遍历获取整个树中的所有键
          DuiLie<Key> keys = new DuiLie<>();
          preErgodic(root,keys);
          return keys;
      }
      private void preErgodic(Node x,DuiLie<Key> keys){
          //使用前序遍历把指定树x中的所有键放到keys队列中
          if (x==null){
              return;
          }
          keys.enqueue((Key) x.key);
          if (x.left!=null){
              preErgodic(x.left,keys);
          }
  
          if (x.right!=null){
              preErgodic(x.right,keys);
          }
      }
      //中序遍历：
      public DuiLie<Key> midErgodic(){
          //使用中序遍历获取整个树中的所有键
          DuiLie<Key> keys = new DuiLie<>();
          midErgodic(root,keys);
          return keys;
      }
      private void midErgodic(Node x,DuiLie<Key> keys){
          //使用中序遍历把指定树x中的所有键放到keys队列中
          if (x==null){
              return;
          }
          if (x.left!=null){
              midErgodic(x.left,keys);
          }
          keys.enqueue((Key) x.key);
          if (x.right!=null){
              midErgodic(x.right,keys);
          }
      }
      //后序遍历：
      public DuiLie<Key> aftErgodic(){
          //使用后序遍历获取整个树中的所有键
          DuiLie<Key> keys = new DuiLie<>();
          aftErgodic(root,keys);
          return keys;
      }
      private void aftErgodic(Node x,DuiLie<Key> keys){
          //使用后序遍历把指定树x中的所有键放到keys队列中
          if (x==null){
              return;
          }
          if (x.left!=null){
              aftErgodic(x.left,keys);
          }
  
          if (x.right!=null){
              aftErgodic(x.right,keys);
          }
          keys.enqueue((Key) x.key);
      }
  ```

* 层序遍历

  ```java
  //层序遍历：这是一种对树从上到下，从左往右的顺序的遍历，是一层一层的从左往右拿数据的遍历
      //实现思路：这里需要一个辅助队列来帮助我们进行层序遍历
      //首先我们要有一个队列，它是用来存储每一层的结点的
      //使用循环从队列冲弹出一个结点(当前结点)
      //获取当前结点的key值，如果当前结点的左子节点不为空，就把左子节点放到队列中
      //如果当前结点的右子结点不为空，就把右子结点放到队列中
      //层序遍历使用了一种遍历思想：广度优先算法
      public DuiLie<Key> layerErgodic(){
          //层序遍历
          //这里要有两个队列，分别存树中的键和结点
          DuiLie<Key> keyDuiLie = new DuiLie<>();//存键
          DuiLie<Node> nodeDuiLie = new DuiLie<>();//存结点
          nodeDuiLie.enqueue(root);
          while (!nodeDuiLie.isEmpty()){
              //从队列中弹出一个结点，存到存键的队列中
              //判断当前结点是否还有左右节点，有的话要放到存结点的队列中
              Node node = nodeDuiLie.deenqueue();
              keyDuiLie.enqueue((Key) node.key);
              if (node.left!=null){
                  nodeDuiLie.enqueue(node.left);
              }
              if (node.right!=null){
                  nodeDuiLie.enqueue(node.right);
              }
          }
          return keyDuiLie;
      }
  ```

* 树的最大深度问题

  ```java
  //二叉树的最大深度问题
      //计算二叉树的最大深度即树的根节点到最远叶子的最长路径上的结点数
      //实现的思想：
      //如果根节点为空，深度为0
      //如果根节点不为空，就分别计算左右子树的最大深度
      //子树的最大深度+1即为整个树的最大深度
      public int maxDepth(){
          //计算树的最大深度
          return maxDepth(root);
      }
      private int maxDepth(Node x){
          //计算指定树的最大深度
          if (x==null){
              return 0;
          }
          int max=0;//整个树的最大深度
          int maxl=0;//左子树的最大深度
          int maxr=0;//右子树的最大深度
          if (x.left!=null){
              maxl = maxDepth(x.left);
          }
          if (x.right!=null){
              maxr = maxDepth(x.right);
          }
          max = maxl>maxr?maxl+1:maxr+1;
          return max;
      }
  
  ```

* 折纸问题

  ```java
  //二叉树折纸问题
      //折纸问题：给定一个参数N，表示一张纸从上边向下边对折N次，要求从上到下打印折痕方向
      //比如折一次，就会有一个向下的折痕，如果折两次，就有一条上折痕和两条下折痕
      //折痕朝上突出的输出up，朝下突出的输出down
      //我们可以用树的结构来描述这个折痕：把第一次对折产生的折痕作为树的根结点，把第二次对折产生的
      //折痕作为树的左右子节点，以此类推。
      public static void main(String[] args) {
          //解决折纸问题
          Node<String> stringNode = creatTree(2);
          printTree(stringNode);
      }
  
      //模拟纸的对折
      public static Node<String> creatTree(int N) {
          //定义一个根节点
          Node<String> root = null;
          for (int i = 0; i < N; i++) {
              if (i==0) {//第一次折叠
                  root = new Node<>("down",null,null);
                  continue;
              }
              DuiLie<Node> duiLie = new DuiLie<>();
              duiLie.enqueue(root);
              while (!duiLie.isEmpty()) {
                  //从队列种弹出一个结点，然后判断是否有左右子结点，如果都没有就给该结点添加结点
                  Node tim = duiLie.deenqueue();
                  if (tim.left!=null) {
                      duiLie.enqueue(tim.left);
                  }
                  if (tim.right!=null) {
                      duiLie.enqueue(tim.right);
                  }
                  if (tim.left==null&&tim.right==null) {
                      tim.left = new Node("down",null,null);
                      tim.right = new Node("up",null,null);
                  }
              }
          }
          return root;
      }
  
      //将生成的树打印到控制台
      public static void printTree(Node<String> root) {
          //使用中序遍历
          if (root==null) {
              return;
          }
          if (root.left!=null){
              printTree(root.left);
          }
          System.out.println(root.item);
          if (root.right!=null){
              printTree(root.right);
          }
      }
      public static class Node<T>{
          //结点类
          public T item;//存储元素
          public Node left;
          public Node right;
  
          public Node(T item, Node left, Node right) {
              this.item = item;
              this.left = left;
              this.right = right;
          }
      }
  ```

  

##### 堆:

堆特点:

* 堆是完全二叉树,除了树的最后一层结点不是满的,其他的每一层从左往右全是满的,如果最后一层结点不是满的,那么要求左子树是满的,右边可以不满.

* 堆一般是使用数组来实现的,具体实现方法就是将二叉树的结点按层级顺序放入数组中,根节点位置在位置1,子节点位置在2,3,而子结点的字结点分别在位置4,5和6,7以此类推.如果一次结点的位置为k,那么它的父节点位置就是k/2,它的子结点位置在2k,2k+1.

* 每个结点都大于等于它的两个字结点,注意堆中仅仅规定每个结点大于等于它的两个子结点,但是两个子结点的顺序并无规定,这是跟二叉查找树是不一样的.

堆的API实现:

```java
//API设计:
    //Dui(int capacity):创建容量为capacity的堆对象
    //成员方法:
    /*
    * private boolean less(int i,int j):判断堆中索引i处的元素是否小于索引j处的元素
    * private void exch(int i,int j):交换堆中索引i与索引j处的值
    * public T delMax():删除堆中最大的元素,并返回该元素
    * public void insert(T t):向堆插入一个元素
    * private void swim(int k):使用上浮算法,使索引k处的元素能在堆中处于一个正确的位置
    * private void sink(int k):使用下沉算法,使索引k处的元素能在堆中处于一个正确的位置
    * */
    //成员变量:
    //private T[] items:存储元素的数组
    //private int N:堆中元素的个数
```

堆实现:

```java

public class Dui<T extends Comparable<T>>{
    private int N;
    private T[] items;
    public Dui(int capacity){
        this.items = (T[])new Object[capacity];
        this.N = 0;
    }
    private void exch(int i,int j){
        T temp = items[i];
        items[i] = items[j];
        items[j] = temp;
    }
    private boolean less(int i, int j){
        return items[i].compareTo(items[j]) < 0;
    }

    public T delMax() {
        //删除最大元素(对于堆来说就是根节点)
        //删除结点时,把当前数组最后的那个元素用来替换该元素,然后对堆进行调整,对根节点进行下沉,就可以让堆有序了
        T maxT = items[1];
        exch(1,N);
        items[N] = null;
        N--;
        sink(1);
        return maxT;
    }
    public void insert(T t){
        //插入元素
        items[++N] = t;
        swim((N-1)/2);//要跟父结点进行比较
    }
    private void swim(int k){
        //上浮算法
        //首先进行循环,判断当前结点的值与父结点谁大,如果当前的结点大,就需要进行上浮
        while(k > 1){
            if(less(k/2,k)){
                exch(k,k/2);
            }
            k = k/2;
        }
    }
    private void sink(int k){
        //下沉算法
        //首先判断有没有子节点了
        while(2*k <= N){
            int maxTindex ;
            //如果有子节点,就记录下子节点比较大的那个,如果没有,就直接是那个子节点
            if(2*k+1<=N){
                if(less(2*k,2*k+1)){
                    maxTindex = 2*k+1;
                }else{
                    maxTindex = 2*k;
                }
            }else{
                maxTindex = 2*k;
            }
            //判断当前节点是否比较大的那个子节点大,如果大的话就不用管了,如果小了,就替换他俩的位置
            if(!less(k,maxTindex)){
                break;
            }else{
                exch(k,maxTindex);
                k = maxTindex;
            }
        }
    }   


}
```

堆排序:

```java
/**
	基于堆这种数据结构,又可以衍生出一种排序算法,即堆排序.
	堆排序API设计:
    /**
     * public static void sort(Comparable[] source):对source数组进行从小到大排序
     * private static void createHeap(Comparable[] source,Comparable[] heap):根据原数组,构造堆heap
     * private static boolean less(Comparable[] heap,int i,int j):判断heap堆中索引i处的元素是否小于索引j处元素的值
     * private static void exch(Comparable[] heap,int i,int j):交换heap堆中索引i和索引j处的元素
     * private static void sink(Comparable[] heap,int target,int range):在heap堆中,堆target元素做下沉,范围是0-range.
*/
```

堆排序的代码实现:

```Java
public class DuiSort<T extends Comparable<T>>{
	public static void sort(Comparable[] source){
        //实现堆排序
        //原理:只要对构造好的堆进行类似于堆删除的操作,就可以完成排序了
        //步骤:
        //首先要构造一个堆
        //1.将堆顶元素和堆中最后一个元素进行交换位置
        //2.通过对堆顶元素的下沉,把最大元素放到堆顶,此时最后一个元素不参与堆的调整,因为最大的数据已经在数组末尾了
        //3.重复1步骤和2步骤,直到堆中剩下最后一个元素

        //堆排序过程:
        //要先构造一个堆
        Comparable[] heap = new Comparable[source.length + 1];
        createHeap(source,heap);
        //记录未排序元素最大的索引值
        int N = heap.length - 1;
        //通过循环堆索引1处的元素和排序的元素中最大索引处的元素
        while(N != 1){
            exch(heap,1,N);
            //排序后最大元素所在的索引不让它参与后续的排序了
            N--;
            //堆索引1处的元素进行下沉
            sink(heap,1,N);
        }
        //将排序好的数组还给源数组
        System.arraycopy(heap,1,source,0,source.length);
    }
    private static void createHeap(Comparable[] source,Comparable[] heap){
        //构造堆:
        //我们有两种构造堆的方式:
        //1.遍历原数组,每得到一个元素就添加到新数组中,并通过上浮对堆进行调整,最后得到的就是一个堆
        //2.创建一个新数组,然后把原数组中所有的数据拷贝到新数组的1-length处,再从新数组长度的一半处开始往1索引处从左到右的扫描,然后对扫描到的每一个元素进行下沉处理.最后就可以得到一个堆
        //实现:
        //第一步:把source拷贝到heap数组的1-length处,构建无序堆
        System.arraycopy(source,1,heap,1,source.length);
        //第二步:把无序堆从一半处开始从索引1处进行扫描下沉
        for (int i = heap.length/2;i > 0;i--){
            sink(heap,i,heap.length-1);
        }

    }
    private static boolean less(Comparable[] heap,int i,int j){
        return heap[i].compareTo(heap[j]) < 0;
    }
    private static void exch(Comparable [] heap,int i,int j){
        Comparable temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
    private static void sink(Comparable[] heap,int target,int range){
        //下沉算法
        while(2*target <= range){
            //找出当前结点的较大子结点
            int max;
            if (2*target+1 <= range){
                if (less(heap,2*target,2*target+1)){
                    max = 2*target+1;
                }else{
                    max = 2*target;
                }
            }else{
                max = 2*target;
            }
            //比较当前结点的值和较大子结点的值
            if(!less(heap,target,max)){
                break;
            }
            exch(heap,target,max);
            target = max;
        }
    }
}
```

##### 优先队列:

```
/**
 * 优先队列
 * 普通队列是一种先进先出的数据结构,元素在队尾入队,从队首出队,而在某些情况下,我们需要找出队列中最大或者最小的值,比如消息队列这个东西,
 * 用来保存计算机的任务,而计算机的任务是有优先级的,我们需要在这些计算机的任务中找出优先级最高的任务先执行,执行完毕后要把这个任务从队列
 * 中删移除.普通的队列要完成这样的功能的话,就需要每次遍历队列中的元素并进行比较以找出最大/最小值,效率不高,这种情况下我们就可以用特殊的
 * 队列,优先队列来完成这个任务.
 * 优先队列按照作用不同可用分为以下两种:
 *  最大优先队列: 可以获取并删除队列中最大的值
 *  最小优先队列: 可以获取并删除队列中最小的值
 * 实现优先队列可以使用堆来实现,因为堆的最大元素总是在第一个,最小元素总是在最后一个.
 * */
```

```Java
class ZuiDaYouXianDuiLie<T extends Comparable<T>>{
    /*最大优先队列*/
    /**API:
     * 有一个int型参数的构造方法:构造一个容量为指定大小的最大有限队列
     * private boolean less(int i,int j):判断堆中索引i处的元素是否小于索引j处的元素
     * private void exch(int i,int j):交换堆中索引i处和索引j处的元素
     * public T delMax(): 删除队列中最大的元素,并返回这个元素
     * punlic void insert(T t): 向队列中插入一个元素
     * private void swim(int k): 使索引k处的元素上浮,让它能在堆中处于一个正确的位置
     * private void sink(int k): 使索引k处的元素下沉,让它能在堆中处于一个正确的位置
     * public int size() : 获取队列的大小
     * public boolean isEmpty() : 判断队列是否为空
     * private T[] imtes : 用于存储元素的数组
     * private int N: 记录元素的个数
     * */
    private T[] imtes;
    private int N;

    public ZuiDaYouXianDuiLie(int size){
        imtes = (T[]) new Comparable[size];
        N = 0;
    }
    private boolean less(int i,int j){
        return imtes[i].compareTo(imtes[j]) < 0;
    }

    private void exch(int i,int j){
        T temp = imtes[i];
        imtes[i] = imtes[j];
        imtes[j] = temp;
    }

    private void swim(int k){
        while (k > 1){
            if (less(k/2,k)){
                exch(k/2,k);
            }
            k = k/2;
        }
    }

    private void sink(int k){
        while (k * 2 <= N) {
            int max;
            if (2*k+1<=N){
                if(less(2*k,2*k+1)){
                    max = 2*k+1;
                }else {
                    max = 2 * k;
                }
            }else {
                max = 2 * k;
            }
            if (!less(k,max)){
                break;
            }
            exch(k,max);
            k = max;
        }
    }

    public T delMax(){
        T max = imtes[1];
        exch(1,N);
        N--;
        sink(1);
        return max;
    }

    public void insert(T t){
        imtes[++N] = t;
        swim(N);
    }

    public int size() {
        return N;
    }

    public boolean isEmpty() {
        return N == 0;
    }
}
```

最小优先队列:

```java
class ZuiXiaoYouXianDuiLie<T extends Comparable<T>>{
    /*最小优先队列*/
    /*对于最小优先队列,我们也可以用堆,这里使用小根堆,它的特点:
    *   最小的元素放在数组索引1处
    *   每个节点的数据总是小于等于它两个子节点的数据
    * */
    /**API与最大优先队列一致.*/
    /**API:
     * 有一个int型参数的构造方法:构造一个容量为指定大小的最大有限队列
     * private boolean less(int i,int j):判断堆中索引i处的元素是否小于索引j处的元素
     * private void exch(int i,int j):交换堆中索引i处和索引j处的元素
     * public T delMin(): 删除队列中最小的元素,并返回这个元素
     * punlic void insert(T t): 向队列中插入一个元素
     * private void swim(int k): 使索引k处的元素上浮,让它能在堆中处于一个正确的位置
     * private void sink(int k): 使索引k处的元素下沉,让它能在堆中处于一个正确的位置
     * public int size() : 获取队列的大小
     * public boolean isEmpty() : 判断队列是否为空
     * private T[] imtes : 用于存储元素的数组
     * private int N: 记录元素的个数
     * */
    private T[] imtes;
    private int N;

    public ZuiXiaoYouXianDuiLie(int size){
        imtes = (T[]) new Comparable[size];
        N = 0;
    }
    private boolean less(int i,int j){
        return imtes[i].compareTo(imtes[j]) < 0;
    }

    private void exch(int i,int j){
        T temp = imtes[i];
        imtes[i] = imtes[j];
        imtes[j] = temp;
    }

    private void swim(int k){
        while (k > 1){
            if (less(k,k/2)){
                exch(k,k/2);
            }
            k = k/2;
        }
    }

    private void sink(int k){
        while (k * 2 <= N) {
            int min;
            if (2*k+1<=N){//如果有右节点
                if(less(2*k,2*k+1)){//找到子节点中的较小值,有的话就交换
                    min = 2*k;
                }else {
                    min = 2 * k + 1;
                }
            }else {
                min = 2 * k;
            }
            if (!less(k,min)){
                break;
            }
            exch(k,min);
            k = min;
        }
    }

    public T delMin(){
        T min = imtes[1];
        exch(1,N);
        N--;
        sink(1);
        return min;
    }

    public void insert(T t){
        imtes[++N] = t;
        swim(N);
    }

    public int size() {
        return N;
    }

    public boolean isEmpty() {
        return N == 0;
    }
}
```

索引优先队列:

```java
class IndexYouXianDuiLie<T extends Comparable<T>>{
    /**索引优先队列
     * 在最大/最小优先队列中,有一个缺点,那就是没法通过索引访问已存在队列里的元素并对它们进行操作
     * 对于这个问题,有一种索引优先队列这个数据结构.同样的,索引优先队列也分为最大索引优先与最小索引优先.
     *
     * 索引优先队列就是为每一个元素关联一个索引,这个索引可以作为这个元素所在数组中的索引值.
     * 通过这个索引,我们就可以通过索引去获取和修改元素了.
     * 但是即使有了索引,但放进去的时候它并不是有序的,所以我们可以增加一个数组,
     * 它是用来完成排序的,并且它存储的是排序后元素对应的索引值.
     * 这样操作后,我们会发现,当我们为堆做有序化的时候,调整的其实是那个专门做排序的数组,
     * 如果要对存储原元素的数组中的元素进行更改时,就需要对专门排序的数组进行有序化,这时就需要
     * 找到那个被修改元素的索引值所在有序数组中的位置以便调整,此时我们只能遍历,当数据量大时,效率
     * 会非常低,所以我们可以引入一个辅助数组,它的数组下标与元素的索引值像调换,也就是用元素的索引值
     * 作为这个数组的下标,里面的元素是有序数组中元素对应的数组下标值.有了这个数组,我们就可以直接通过
     * 索引来找到有序数组中这个索引所在的下标位置,就可以很快的进行有序化了.
     * */
    /*这里为最小索引优先*/
    /**最小索引优先队列API:
     * 构造方法 : 构造一个指定大小的队列.
     * private T[] items : 存储原元素的数组
     * private int[] pq : 保存每个元素在items中的索引,并且它是堆有序的.
     * private int[] qp : 保存pq数组的逆序,也就是索引是它里面的元素值,元素值是pq中元素所对应的下标
     * private int N : 有效元素的个数
     * private boolean less(int i,int j) : 判断索引i处的元素是否小于索引j处的元素
     * private void exch(int i,int j) : 交换索引i与索引j处的元素
     * private void swim(int k) : 使索引k处的元素进行上浮,以保持它在一个正确位置
     * private void sink(int k) : 使索引k处的元素进行下沉,以保持它在一个正确位置
     * public void insert(int i,T t) : 插入一个元素,并给它关联一个索引i
     * public void changeItem(int i,T t) : 修改索引i处的元素为t
     * public boolean isEmpty() : 判断队列是否为空
     * public boolean contains(int k) : 判断索引k处的元素是否存在
     * public int minIndex() : 获取最小元素的索引
     * public void delete(int i) : 删除指定索引处的元素
     * public int delMin() : 删除最小元素,并返回它的索引
     * */
    private T[] items;
    private int[] pq;
    private int[] qp;
    private int N;
    public IndexYouXianDuiLie(int capacity){
        items = (T[]) new Comparable[capacity];
        pq = new int[capacity + 1];
        qp = new int[capacity + 1];
        N = 0;
        Arrays.fill(qp, -1);
    }
    private boolean less(int i,int j){
        return items[pq[i]].compareTo(items[pq[j]]) < 0;
    }

    private boolean isEmpty(){
        return N == 0;
    }

    private boolean contains(int k){
        return -1 == qp[k];
    }

    private void exch(int i,int j){
        //交换pq中的
        int temp = pq[i];
        pq[i] = pq[j];
        pq[j] = temp;
        //更新qp中的
        qp[pq[i]] = i;
        qp[pq[j]] = j;
    }

    private void swim(int k){
        while (k > 1){
            if (less(k,k/2)) {
                exch(k,k/2);
            }
            k = k/2;
        }
    }

    private void sink(int k){
        while (k <= N){
            int min;
            if (k <= 2*k+1){
                if (less(2*k,2*k+1)){
                    min = 2*k;
                }else {
                    min = 2*k+1;
                }
            }else {
                min = 2 * k;
            }
            if (less(k,min)) {
                break;
            }
            k = min;
        }
    }

    public  void insert(int i,T t){
        //判断索引i处是否有东西
        if (contains(i)){
            return;
        }else {
            N++;
            items[i] = t;
            pq[N] = i;
            qp[i] = N;
            swim(N);
        }
    }

    public void changeItem(int i,T t){
        items[i] = t;
        swim(qp[i]);
        sink(qp[i]);
    }

    public int minIndex(){
        return pq[1];
    }

    public void delete(int i){
        exch(qp[i],N);
        items[qp[i]] = null;
        swim(qp[i]);
        sink(qp[i]);
        pq[i] = -1;
        N--;
    }

    public int delMin(){
        int minIndex = pq[1];
        exch(1,N);
        qp[pq[N]] = -1;
        pq[N] = -1;
        items[minIndex] = null;
        N--;
        sink(1);
        return minIndex;
    }
}
```



##### 树的进阶

###### 平衡树

我们知道,二叉查找树它的查询效率相比于单纯的链表和数组的查询效率要高,但是在某些情况下,它在最糟糕的时候查找效率依旧很低,比如我们用9,8,7,6,5,4,3,2,1来构造一颗二叉树,它就会形成一个类似线性结构的,只有左节点的查找树,这个时候想查找到1,就得遍历比较每个元素,效率低下,而造成这个现象的原因就是因为树没有平衡.为了解决这个问题,我们有另一个类型的树来解决,那就是2-3查找树.

* 查找树

  2-3查找树要么是一个空的,要么满足下列条件:

  * 它的2-节点(含有一个键和两个链)的键的左节点都比本节点的小,右节点的键都比本节点的键大.
  * 它的3-节点(含有两个键和三条链)的键的左节点都比本节点的小,中节点的键处在本节点的两个键中,右节点的键都比本节点的大.

* 2-3树查找算法

  同二叉树一样,都是先与根节点相比较,如果根节点就有要查找的元素,则查找命中.否则就根据比较结果到链中对应的子树去找.如果链是空的,那么查找未命中.

* 2-3树插入元素

  2-3树的元素插入与二叉树一样,都是先查找有没有这个元素,然后将新元素作为新节点挂载到未找到的节点上.2-3树是需要保持高效率的,所以它在查找的时候也要保持平衡.2-3查找树的插入情况多样:

  * 向2-节点中插入元素

    向2-节点中插入元素,只需要将这个2-节点变为3-节点,然后在它本节点内插入即可.

  * 向一颗只含有一个3-节点的树插入元素

    假设2-3树只包含一个3-节点,这个节点有两个键,没有空间来存放第三个键了,最自然的方式是假设这个节点可以放入第三个元素,暂时使它变为一个4-节点,同时它将包含四条链,我们将这个4-节点的中间元素提升,左边的键作为其左子节点,右边的键作为其右子节点.插入完成,变为平衡2-3查找树,树的高度+1

  * 向一个父节点未2-节点的3-节点中插入元素

    情况类似上面,只是中间元素是提升到父节点也就是2-节点中,使其父节点变为一个3-节点,然后将左右节点分别挂在这个3-节点的恰当位置.

  * 向一个父节点为3-节点的3-节点中插入元素

    当插入节点为3-节点时,我们将该节点拆分,中间元素提升至父节点,但是此时父节点是一个3-节点,插入之后,父节点变成了一个4-节点,然后继续将父节点的中间元素提升到它的父节点中,直到提升到一个2-节点中为止.

  * 分解根节点
  
    如果插入节点到根节点的路径上全是3-节点的时候,最终我们的根节点会变成一个临时的4-节点,此时需要将这个根节点拆分为两个2-节点,根节点的中间节点提升为根节点,树的高度+1.
  
* 2-3查找树的性质

  通过对于2-3树插入操作的分析,我们可以发现,2-3树在插入元素的时候,它会通过局部的变换来保持树的平衡,一颗完全平衡的2-3树具有以下性质:

  * 任意空链连接到根节点的路径长度是相等的
  * 4-节点变为3-节点时,树的高度不会发生变化,除非根节点变成了4-节点,树的高度就会+1.
  * 2-3树与普通二叉树的最大区别在于,二叉树是自顶向下生长,而2-3树是自底向上生长

* 2-3树的实现

  2-3树的实现相比于普通二叉树来讲更加复杂.因为:

  * 需要处理不同节点类型
  * 需要多次比较操作来比较节点并将节点下移
  * 需要通过上移元素拆分4-节点
  * 拆分4-节点的情况有很多.

  因为2-3树的复杂性,在某些情况插入元素时的平衡操作会使得2-3树的效率变低,但它作为一个重要的概念与思路,对于B树与B+树,红黑树来讲十分重要.

###### 红黑树

我们知道,2-3树能够保证在插入元素后,树依然可以保持平衡,它在最坏情况下所有的节点都是2-节点.树的高度为lgN,相比于普通二叉查找树,最坏的情况下树高为N,确实保证了最坏情况下的时间复杂度,但是2-3树实现非常的麻烦,因此就有了2-3树的简单实现之一:红黑树.

红黑树是对2-3树进行编码,它背后的基本思想是用标准的二叉查找树(完全的2-节点构成)和一些额外的信息(代替3-节点)来表示2-3树,红黑树中的链分为两种类型:

**红链接: 将两个2-节点连接起来形成一个3-节点**

**黑链接: 是2-3树中的普通链**

确切的说,我们将3-节点表示为由一条条**左斜的红链接**(两个2-节点,其中之一是另一个的左子节点)相连的两个2-节点.这种表示方法的一个优点是:我们无需改动就可以直接使用标准二叉树中的get方法.

* 定义(红黑树是含有红黑链接并满足下列条件的二叉查找树)

  * 红链接均为左连接
  * 没有任何一个节点同时和两条红链接相连.
  * 该树是完美黑色平衡的,即任意空连接到根节点的步数与路径上的黑链接数量相同.

* 红黑树实现

  * 我们知道,除了根节点以外,其他节点总是只有唯一一个来自父节点的链指向自己,所以我们可以通过一个boolean类型的标识符来判断这个链是红链还是黑链.

  * 红黑树的平衡化

    对红黑树进行一些增删改查的操作后,很有可能会出现红色的右链或者两条连续红链,而这种情况是不符合红黑树的定义的,所以需要通过旋转对这些情况进行修复,以保持红黑树的平衡.

    * 左旋

      当某个节点的左子节点为黑色,右子节点为红色,此时需要左旋.

      左旋的过程:父节点为h,为红色的子节点是x

      * 让x的左子节点变为h的右子节点 : h.right = x.left;
      * 让h称为x的左子节点 : x.left = h;
      * 让h的color变为x的color : h.color = x.color;
      * 让h的color变为红: h.color = true.

    * 右旋

      当某个节点的左子节点是红色,且左子节点的左子节点也是红色,那么此时需要右旋

      右旋的过程: 父节点为h,左子节点为x

      * 让x的右子节点成为h的左子节点 : h.left = x.right
      * 让h成为x的右子节点 : x.right = h;
      * 让x的color变为h的color : x.color = h.color;
      * 让h的color为红 : h.color = true;

  * 向红黑树中插入数据

    * 向当个2-节点中插入新键

      一颗只含有一个键的红黑树只含有一个2-节点,插入一个键后,我们就需要马上进行旋转.

      * 如果新键小于当前节点的键,我们只需要新增一个红色节点即可,新的红黑树与一个单个的3-节点完全等价.
      * 如果新键大于当前节点的键,那么新增的红色节点将会产生一条红色的右链接,此时我们需要通过左旋,把红色右链接变成左连接.形成的红黑树依然与单个3-节点等价.其中包含两个键,一个红色链接.
    
    * 向底部的2-节点插入新键
    
      用和二叉查找树相同的方式去向一颗红黑树中插入一个新键,会在树的底部新增一个节点(保证有序),唯一的区别是我们会用红链接将新节点与它的父节点相连,如果它的父节点是一个2-节点,那么就可以使用上面哪一个那样的操作.
    
    * 链颜色反转
    
      当一个节点的左子节点和右子节点的颜色都是红色的时候,也就是出现了临时的4-节点,此时只需要把左子节点和右子节点的颜色变为黑色,同时让当前节点的颜色变为红色即可.
    
    * 向一颗双键树(也就是树只有一个3-节点)中插入新键
    
      这个情况可分为三个子情况:
    
      * 新键大于原树中的两个键
    
        此时可以将该节点向右插入,然后进行颜色反转.
    
      * 新键小于原树中的两个键
    
        此时会将新节点放在根节点的左子节点的左子节点处,此时左边会产生连续的两个红链,这时就可以进行右旋,右旋后右边会产生一个红链,这时就可以进行颜色反转.
    
      * 新键介于原树中的两个键之间
    
        此时就将新键置于根节点的左子节点的右子节点处,此时产生了一个右红链接,需要进行左旋,左旋后产生两条连续的左红链接,需要进行右旋,右旋后产生一左一右两个红链接,需要进行颜色反转.
    
    * 根节点的颜色总是黑色
    
      因为根节点不存在父节点,所以我们可以一直让它保持为黑色
    
    * 向树底部的3-节点插入新键
    
      向树底部的3-节点插入新键时,可能会出现向只有一个3-节点里插入新键那样的情况,我们解决的时候是一样的.需要注意的是颜色转换会使得父节点变红,相当于向父节点中插入了一个新节点,我们只需要使用相同方法解决即可,直到遇上一个2-节点或根节点为止.
    
  * 红黑树的API设计与代码实现
  
    ```Java
    /**红黑树
     * API设计:
     *  内部类:Node(Key k,Value v,Node left,Node right,boolean color)及其构造方法
     *  private boolean isRed(Node x) : 判断当前节点的父指向链是否是红色
     *  private Node rotateLeft(Node h): 左旋
     *  private Node rotateRight(Node h): 右旋
     *  private void flipColors(Node h) : 颜色反转
     *  private Node put(Node h, Key k,Value v) : 在指定树中完成插入操作,并返回新的树
     *  private Value get(Node x,Key k) : 从指定树中找出键所对应的值
     *  public void put(Key k,Value v) : 在整个树上完成插入操作
     *  public Value get(Key k) : 在树中找出对应的值
     *  public int size() : 获取树中的元素个数
     *
     *  private Node root : 根节点
     *  private int N : 树中元素个数
     *  private static final boolean RED : 红色链标识
     *  private static final boolean BLACK : 黑色链标识
     *
     * */
    public class HongHeiShu<Key extends Comparable<Key>,Value> {
        private class Node{
            public Key key;
            private Value value;
            public Node left;
            public Node right;
            public boolean color;
            public Node(Key key,Value value,Node left,Node right,boolean color){
                this.key = key;
                this.value = value;
                this.left = left;
                this.right = right;
                this.color = color;
            }
        }
    
        private Node root;
        private int N;
        private static final boolean RED = true;
        private static final boolean BLACK = false;
    
        private boolean isRed(Node x){
            if(null == x){
                return BLACK;
            }
            return x.color == RED;
        }
    
        private Node rotateLeft(Node h){
            /*获取h节点的右子节点,表示为x节点*/
            Node x = h.right;
            /*让x节点的左子节点作为h节点的右子节点*/
            h.right = x.left;
            /*让h节点成为x节点的左子节点*/
            x.left = h;
            /*让x节点的color为h的color*/
            x.color = h.color;
            /*让h节点的color变为RED*/
            h.color = RED;
    
            return x;
        }
    
        private Node rotateRight(Node h) {
            /*获取h节点的左子节点表示为x*/
            Node x = h.left;
            /*让x节点的右子节点成为h的左子节点*/
            h.left = x.right;
            /*让h节点成为x节点的右子节点*/
            x.right = h;
            /*让x节点的color等于h的color*/
            x.color = h.color;
            /*让h的color变为RED*/
            h.color = RED;
            return x;
        }
    
        private void flipColors(Node h){
            h.color = RED;
            h.left.color = BLACK;
            h.right.color = BLACK;
        }
    
        private Node put(Node h,Key key,Value value){
            /*判断h是否是空的,就直接创建一个节点,并且是一个红节点就行*/
            if (null == h){
                N++;
                return new Node(key,value,null,null,RED);
            }
            /*如果不为空,就需要比较节点h与要传入的键的大小*/
            int cmp = key.compareTo(h.key);
            if (cmp < 0){
                /*继续往左*/
                h.left = put(h.left,key,value);
            }else if (cmp>0) {
                /*继续向右*/
                h.right = put(h.right,key,value);
            }else {
                /*进行值替换*/
                h.value = value;
            }
            //插入完成后要保持树的平衡
            //进行左旋:当当前节点h的左子节点为黑色,右子节点为红色需要进行左旋
            if (isRed(h.right) && !isRed(h.left)){
                h = rotateLeft(h);
            }
            //进行右旋 : 当当前节点h的左子节点为红色,左子节点的左子节点为红色时要右旋
            if (isRed(h.left) && isRed(h.left.left)){
                h = rotateRight(h);
            }
            //进行颜色反转 : 当当前节点的左右子节点都为红色需要进行颜色反转
            if (isRed(h.right) && isRed(h.left)){
                flipColors(h);
            }
    
            return h;
        }
    
        private Value get(Node h, Key key) {
            if (null == h){
                return null;
            }
            int cmp = key.compareTo(h.key);
            if (cmp < 0){
                return get(h.left,key);
            }else if (cmp > 0) {
                return get(h.right,key);
            }else {
                return h.value;
            }
        }
    
        public void put(Key key, Value value) {
            root = put(root,key,value);
            root.color = BLACK;
        }
    
        public Value get(Key key) {
            return get(root,key);
        }
    
        public int size() {
            return N;
        }
    }
    ```
  
    
  
    

###### B-树

我们知道2-3树中,一个节点最多能有两个键,它的实现中红黑树使用对链接进行染色去表示两个key.而B树也是一个实现2-3树的数据结构.它一个节点允许有多于两个key的存在.

B树是一种树状数据结构,它能够存储数据,对其进行排序并允许以O(logN)的复杂度进行查找,顺序读取,插入和删除等操作.

* B树的特征

  B树中允许一个节点包含多个键,可以是3,4,5个甚至更多.我们可以选择一个参数M来构造一个B树,我们可以把这个B树称作是M阶的B树,那么这个树会有以下特点:

  * 每个节点最多有M-1个键,并以升序排序
  * 每个节点最多能够有M个子节点
  * 根节点至少有两个子节点

在我们实际的运用里面,B树的阶数一般都是100以上的,这就可以在有大量数据的情况下,B树的深度也非常小,查询的效率会非常的高.

* B树数据的存储

  我们以一个5阶B树为例,5阶B树它一个节点能够包含4个键,和五条子链.

  * 如果是一颗空的B树,我们加入新的键就直接放入它的根节点中.根节点可以放入4个键,且这四个键是有序的.
  * 当根节点满后,还要再次插入数据的话,需要比较插入的节点与已经存在节点的大小,并放于合适的位置,但是这个时候就有五个节点了,不符合5阶B树的定义,此时需要将根节点的中间位置的节点上升成为父节点,剩下的成为两个子节点.
  * 其他新键插入时也按照上面那个规则来.

* B树在磁盘文件中的应用

  在计算机的操作系统中,我们不可避免的要通过IO来操作文件,我们的文件是存在于磁盘上的,计算机操作磁盘上的文件是通过文件系统实现的,文件系统中就使用了B树作为存储数据的数据结构.

  * 磁盘

    磁盘是一种能够存储大量数据的设备,但是它的读取速度比较慢,因为涉及到了机器操作,读取速度为毫秒级.磁盘的结构如图:

    ![磁盘结构](D:\Java学习笔记\picture\磁盘结构.PNG)

    磁盘由盘片构成,每个盘片有两面,每一面称为盘面.盘片中心有一个可旋转的主轴,它能够使盘片以固定的旋转速度旋转,通常是5400rpm或7200rpm,一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内.盘片的每个表面是由一组称为磁道同心圆组成的,每个磁道被划分为一组扇区(以磁道圆心到每个扇区边缘的连接作为一个扇区),每个扇区包含相等数量的数据为,通常是512个字节,扇区之间由一些间隙隔开,这些间隙中不存储数据.

  * 磁盘IO

    ![磁盘IO](D:\Java学习笔记\picture\磁盘IO.PNG)

    磁盘用磁头来读写存储在盘片表面的位,而磁头连接在一个移动臂上,移动臂沿着盘片半径前后移动,可以将磁头定位到任何磁道上,这称之为寻道操作,一旦定位到磁道后,盘片转动,磁道上的每个位经过磁头时,读写磁头就可以感知到该位的值,也可也修改值,对磁盘的访问时间分为: 寻道时间,旋转时间,传送时间.

    由于存储介质的特性,磁盘本身存取就比计算机主存慢的多,再加上机械运动耗费,因此,为了提高效率,要尽量减少磁盘IO,减少读写操作.为了达到这个目的,磁盘往往不是严格按需读取,而是每次都会预读,即使只需要一个字节,磁盘也会从这个位置开始,顺序向后读取一定长度的数据放入内存,这样做的理论依据是计算机科学中著名的局部件原理 : 当一个数据被用到时,其附近的数据通常也会马上就被使用.由于磁盘顺序读取的效率很高(因为不需要寻道时间,只需要很短的旋转时间),因此预读可以大大提高IO效率.

    页是计算机管理存储器的逻辑块,硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块,每个存储块称为一页(1024字节或其整数倍),预读的长度一般是页的整数倍.主存和磁盘以页为单位交换数据.当程序尧都区的数据不在主存中的时候,会触发一个缺页异常,此时系统会向磁盘发出读盘信号,磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中,然后异常返回,程序继续允许.

    文件系统的设计者就利用了磁盘的预读原理,将一个节点的大小设为等于一个页,这样每个节点只需要一次IO就可以完全载入,那么3层的B树就可以存储(这里一页就按1024个字节来算)1024 * 1024 * 1024个也就是大概10亿个字节的数据,如果换成二叉树,则需要30层才能存储这么多数据.假定操作系统一次读取一个节点,并且根节点保留在内存中,那么B树在10亿个数据中查找目标,只需要小于3次硬盘读取就可以找到目标,而红黑树需要小于30次的磁盘读取,因此,B树大大提高了IO的效率.

###### B+树

B+树是B树的一种变形树,它与B树的差异在于:

1.非叶子节点仅具有索引作用,也就是非叶子节点只存储Key,不存储Value

2.树的所有叶子节点构成一个有序链表(叶子节点是通过指针相连的),可以按照Key排序的次序遍历全部数据

* B+树的数据存储

  这里也以5阶B+树作为例子 :

  首先我们可以向空树中插入4个新键值对.当根节点满了后,要再插入数据,那么中间的那个键就要提升,但原本的键值对仍然在下面,提升上去的只有键,原本的键值对仍然存放在下面作为子节点.要插入其他新键也按照这个操作来.

* B+树与B树的对比

  * B+树的优点在于:

    由于B+树在非叶子节点上不包含真正的数据,只当做索引使用,因此在内存相同的情况下,B+树可以存储更多的键.

    B+树的叶子节点都是相连的,因此对整颗树的遍历只需要一次线性遍历叶子节点即可.而且由于数据顺序排列并且相连,所以B+树还便于区间查找和搜索.而B树需要进行每一层的递归遍历.

  * B树的优点在于:

    由于B树的每个节点都包含Key和Value,因此我们根据Key查找Value时,只需要找到Key所在的位置,就可以找到Value,但B+树只有叶子节点存储真正的数据,索引每一次查找,都必须一次一次的查,直到找到树的最大深度,也就是叶子节点的深度才能找到Value.

* B+树在数据库中的应用

  在数据库的操作中,查询操作可以说是最频繁的,因此在设计数据库时,不许要考虑查询的效率问题.在很多数据库中都是使用了B+树来提高查询的效率.

  在操作数据库的时候,为了提高查询效率,可以基于某张表的某个字段建立索引,就可以提高查询效率,其实这个索引就是B+树来实现的.举个例子:

  假设有一张表,没有建立主键索引的时候是这样的:

  ![未建立主键索引的表](D:\Java学习笔记\picture\未建立主键索引的表.PNG)

  此时我们执行select * from user where id = 18,就需要从第一个数据开始一直遍历到第六条才能查询到目标结果,此时共比较了6次.

  当建立了主键索引后:

  ![建立了主键索引的表](D:\Java学习笔记\picture\建立了主键索引的表.PNG)

  当建立了主键索引后,就会有一个B+树来存储对应数据,此时去执行同样的语句,那么就只需要比较三次就能够查询到正确数据,提高了擦汗寻效率.

  当我们使用查询: select * from user where id >=12 and id<=18;如果有索引,那么B+树它的叶子节点形成了一个有序链表,我们只需要找到id为12的叶子节点,按照遍历链表的方式向后查询即可,效率会非常的高.

###### 树-并查集

并查集是一种树形的数据结构,它可以很高效的完成以下操作:

* 查询元素p和元素q是否属于同一组(一般也就是比较节点所在树的根节点是否一致)
* 合并元素p和元素q所在的组(合并树,用一棵树的根节点去指向另一颗树的根节点)

![并查集功能](D:\Java学习笔记\picture\并查集功能.PNG)

并查集结构:

并查集也是一种树,但这棵树跟之前的二叉树,红黑树,B树等不一样,这种树的要求比较简单:

* 每个元素都唯一的对应一个节点
* 每一组数据中的多个元素都在同一颗树中(每一组数据就是一棵树)
* 一个组中的数据对应的树和另外一个组中的护具对应的树之间没有任何联系
* 元素在树中并没有父子级关系的硬性要求

![并查集结构](D:\Java学习笔记\picture\并查集结构.PNG)

并查集实现

并查集的API设计:

* 类名:UF

* 构造方法: UF(int N) :初始化并查集,以整数标识(0,N-1)给节点

* 成员变量

  * private int[] eleAndGroup : 记录节点元素和该元素所在分组的标识
  * private int count : 记录并查集中数据的分组个数

* 成员方法

  * public int count() : 获取当前并查集中的数据有多少个分组
  * public boolean connected(int p,int q) : 判断并查集中元素p与元素q是否在同一分组中
  * public int find(int p) : 元素p所在的分组标识符
  * public void union(int p,int q) : 把p元素所在分组和q元素所在分组合并

* 具体实现

  * 构造方法的实现
    * 初始情况下,每个元素都在一个独立分组中,所以,初始情况下,并查集中的数据默认分为N个组
    * 初始化数组eleAndGroup
    * 把数组eleAndGroup的索引看作是每个节点存储的元素,把数组每个索引处的值看作是该节点所在的分组,那么初始化情况下,i索引处存储的值就是i.
    * ![并查集UF初始情况](D:\Java学习笔记\picture\并查集UF初始情况.PNG)
  * union合并方法的实现
    * 如果p,q已经在同一个分组中,则无需合并
    * 如果p和q不在同一个分组中,则只需要将p所在的组的所有元素的标识符修改为q元素所在组的标识符即可
    * 分组数量-1

* 代码实现

  ```Java
  public class UF {
      private int[] eleAndGroup;
      private int count;
  
      public UF(int n){
          //初始化分组数量,默认时等于元素个数
          count = n;
          //初始化eleAndGroup数组
          eleAndGroup = new int[n];
          //初始化数组中元素及其所在的组的标识符
          //让数组的索引作为并查集的每个节点的元素,每个索引处的值就是该元素所在组的标识符
          for (int i = 0; i < eleAndGroup.length; i++) {
              eleAndGroup[i] = i;
          }
      }
  
      public int count() {
          return count;
      }
  
      public boolean connected(int p,int q){
          return find(p) == find(q);
      }
  
      public int find(int p){
          return eleAndGroup[p];
      }
  
      public void union(int p,int q){
          //判断p,q是否已经在同一分组中
          if (connected(p,q)){
              return;
          }
          //如果不在同一分组中,就分别找出p,q所在的组的标识符
          int pGroup = find(p);
          int qGroup = find(q);
          //合并组
          //让p所在组的所有元素的组标识符变为q所在分组的标识符
          for (int i = 0; i < eleAndGroup.length; i++) {
              if (eleAndGroup[i] == pGroup){
                  eleAndGroup[i] = qGroup;
              }
          }
          //组数量-1
          count--;
  
      }
  }
  ```

* 并查集的优化

  在实际的开发中,并查集使用的频率是比较高的,比如并查集存储的每一个整数标识的是一个大型计算机网络中的计算机,我们就可以通过connected方法来检测该网络中的某两台计算机是否联通(也就是处于同一个网络中),如果联通,它们之间就可以进行通信,如果没联通,我们就可以通过union方法使它们联通.

  一般像计算机这样网络型的数据,我们要求网络中的每两个数据是联通的,也就是说,我们要通过多次union方法使得网络中所有的数据相连,如果有N个数据,那就需要调用N-1次union方法才能使所有数据联通,但有序union里遍历了所有元素,所以这样去合并所有元素的话复杂度是O(N的平方),要解决大规模数据合并问题,我们就需要对这个合并算法进行优化

  * 优化方案

    * 仍然让数组的索引作为某个节点的元素
    * eleAndGroup[i]的值不再是当前节点所在的分组标识符,而是该节点的父节点
    * 这里用到了父节点,那么这个并查集就变成了一棵树

  * 优化实现

    其他地方基本与UF类一致,只需要优化find方法和union方法

    * find查询方法实现
      * 判断当前元素p的父节点eleAndGroup[p]是不是自己,如果是自己就证明已经是根节点了.
      * 如果当前的父节点1自己,则让p=eleAndGroup[p],继续找父节点的父节点,直到找到根节点为止
    * union合并方法的实现
      * 找到p元素所在树的根节点
      * 找到q元素所在树的根节点
      * 如果p和q已经在一个树中,则无需合并
      * 如果不在一个树中,则只需要将p元素所在树根节点的父节点设置为q元素的根节点即可
      * 分组数量-1

  * 代码实现

    ```Java
    /**优化的并查集
     * 通过树的结构*/
    public class UF_Tree {
        private int[] eleAndGroup;
        private int count;
    
        public UF_Tree(int n){
            //初始化分组数量,默认时等于元素个数
            count = n;
            //初始化eleAndGroup数组
            eleAndGroup = new int[n];
            //初始化数组中元素及其所在的组的标识符
            //让数组的索引作为并查集的每个节点的元素,每个索引处的值就是该元素所在组的标识符
            for (int i = 0; i < eleAndGroup.length; i++) {
                eleAndGroup[i] = i;
            }
        }
    
        public int count() {
            return count;
        }
    
        public boolean connected(int p,int q){
            return find(p) == find(q);
        }
    
        public int find(int p) {
            while (true){
                if (p == eleAndGroup[p]){
                    return p;
                }
                p = eleAndGroup[p];
            }
    
        }
    
        public void union(int p,int q){
            //找到p,q所在组的根节点
            int pRoot = find(p);
            int qRoot = find(q);
    
            //如果它们在一棵树上,就不合并
            if (pRoot == qRoot){
                return;
            }
    
            //如果不在就要合并
            //让p的根节点的父节点指向q
            eleAndGroup[pRoot] = qRoot;
        }
    }
    ```

  * 优化后的性能分析

    我们优化后的算法uinon,如果要把N个数据联通,人需要调用N-1次union方法,当里面已经没有for循环了,所以union的复杂度由O(N的平方)变为了O(N).

    但是我们还修改了find方法,find方法在修改前不管是什么情况下复杂度都是O(1),而修改后的find算法的复杂度最坏情况下仍然是O(N的平方).而union方法里调用了find方法,那么在最坏的情况下,union的复杂度仍然是O(N的平方).

* 路径压缩

  在优化后的并查集中union方法最坏还是O(N的平方),其主要问题就是在于最坏情况下,树的深度和数组长度一致,如果能够通过一些方法让数据在合并时,生成的树深度尽可能小,就可以优化find方法了.

  在之前的union算法中,合并树的时候就是直接将一棵树直接接到了另一颗树上,这种合并方法是比较暴力的,如果我们把并查集中每一课树的大小记录下来,然后在合并的时候,让小的树连接到大的数上,就可以减少数的深度.

  如果我们能保证每次合并都能把小树合并到大树上,就可以压缩合并后新树的路径,这样就可以提高find方法的效率了.为了完成这个需求,我们需要另一个数组来记录存储每个根节点对应的树中元素的个数,并且需要一些代码来调整数组中的值.

  * 优化的API设计:

    * 类名: UF_Tree_Weighted

    * 构造方法: UF_Tree_Weighted(int N) : 初始化并查集并以整数标识(0,N-1)个节点

    * 成员变量

      * private int[] eleAndGroup : 记录节点元素和该元素的父节点
      * private int[] sz : 存储每个根节点对应的树中元素的个数
      * private int count : 记录并查集中数据的分组数

    * 成员方法

      * public int count() : 获取当前并查集中的数据有多少个分组
      * public boolean connected(int p,int q) : 判断并查集中元素p和元素q是否在同一分组中
      * public int find (int p) : 获取元素p所在分组的标识符
      * public void union(int p,int q) : 合并p,q两个元素所在的分组

    * 代码实现

      ```Java
      public class UF_Tree_Weighted {
          private int[] eleAndGroup;
          private int[] sz;
          private int count;
          public UF_Tree_Weighted(int n){
              count = n;
              eleAndGroup = new int[n];
              sz = new int[n];
              for (int i = 0; i < eleAndGroup.length; i++) {
                  eleAndGroup[i] = i;
              }
              Arrays.fill(sz, 1);
          }
      
          public int count() {
              return count;
          }
      
          public boolean connected(int p,int q){
              return find(p) == find(q);
          }
      
          public int find(int p) {
              while (true){
                  if (p == eleAndGroup[p]) {
                      return p;
                  }
                  p = eleAndGroup[p];
              }
          }
      
          public void union(int p, int q) {
              int pRoot = find(p);
              int qRoot = find(q);
              if (pRoot == qRoot){
                  return;
              }
              
              //比较pRoot对应的树大还是qRoot对应的树大
              if (sz[pRoot] < sz[qRoot]){
                  eleAndGroup[pRoot] = qRoot;
                  sz[qRoot] += sz[pRoot];
              }else {
                  eleAndGroup[qRoot] = pRoot;
                  sz[pRoot] += sz[qRoot];
              }
              
              count--;
          }
      }
      ```

  * 并查集应用案例: 畅通工程

    某省调查城镇交通情况,得到现有城镇道路统计表,表中列出了每条道路直接联通的城镇.省政府"畅通工程"的目标是使全省任何两个城镇之间都可以实现交通(不一定要有直接的道路相连,只要互联间接通过道路可达即可).问最少还需要建设多少条道路.

    城镇道路统计表内容如下:
    20 : 城市的个数

    7 : 已建好的道路数目

    0 1 : 从这到最下面都是标识已经修建好的道路,每一行两个数字标识已连接的两个城市

    6 9

    3 8

    5 11

    2 12 

    6 10

    4 8

    也就是总共20个城市,已经修好了7条道路,还需要多少条道路才能够全部联通.

    * **解题思路**
      * 创建一个并查集UF_Tree_Weighted(20)
      * 分别调用nuion(0,1)......,union(4,8).标识把已经修建好的道路把对应城市连接.
      * 如果城市全部连接起来,那么并查集中剩余的分组数目为1,所有城市都在一个树中,所以只需要获取当前并查集中剩余的分组数目-1就可以得到还需要修建的道路.

###### 图

在现实生活中,许多应用场景中会包含很多点与点之间的连接.而这些应用场景我们都可以用图这种数据结构去解决.

**图的应用**

* 地图

  我们经常用的地图,就是由城市以及连接城市的道路组成,我们把城市看作一个点,道路看作是一条连接,那么地图就是一种典型的图结构.

* 电路

  我们看的那些电路图,那些元件也可也看作是一个点,那些电线也可以看作是点与点之间的连线

**图的定义与分类**

* 定义

  图是由一组顶点和一组能够将两个顶点相连的边组成

* 特殊的图

  * 自环 : 一条连接一个顶点和其自身的边
  * 平行边 : 连接同一对顶点的两条边

* 图的分类

  * 按照连接两个顶点的边不同,可以把图分为以下两种
    * 无向图 : 边仅仅是连接两个顶点,没有其他含义
    * 有向图 : 边不仅连接两个顶点,并且具有方向

* 图的相关术语

  * 相邻顶点

    当两个顶点通过一条边相连时,我们称这两个顶点是相邻的,并且称这条边依附于这两个顶点

  * 度

    某个顶点的度就是依附于该顶点的边的个数

  * 子图

    是一幅图的所有边的子集(包含这些边依附的顶点)组成的图

  * 路径

    是由边顺序连接的一系列的顶点组成

  * 环

    是一条至少含有一条边且终点起点相同的路径

  * 连通图

    如果图中任意一个顶点都存在一条路径到达另一个顶点,那么这幅图就称之为连通图

  * 连通子图

    一个非连通图由入港连通的部分组成,每一个连通的部分都称为该图的连通子图

**图的存储结构**

要标识一幅图,只需要表示清除以下两部分内容即可:

* 图中所有的顶点
* 所有连接顶点的边

常见的图存储结构有两种 : 邻接矩阵和邻接表

**邻接矩阵**

* 使用一个V*V的二位数组int[V]/[V] adj,把索引的值看作是顶点

* 如果顶点V和顶点W相连,我们只需要将adj[V]/[W]和adj[W]/[V]的值设置为0即可.

* 比如:

* ![图的邻接矩阵表示法](D:\Java学习笔记\picture\图的邻接矩阵表示法.PNG)

  很明显,邻接矩阵表示图的话存储的空间复杂度为V的平方,所以如果问题规模比较大,可能空间是不够用的

**邻接表**

* 使用一个大小为V的存储队列的数组Queue[V] adj,把索引看作是顶点

* 每个索引处adj[V]存储一个队列,该队列中存储的是所有与该节点相邻的其他顶点

* 比如这样:

* ![图的邻接表表示法](D:\Java学习笔记\picture\图的邻接表表示法.PNG)

  由此可见,邻接表的空间复杂度并不是线性级别的,它的占用没有邻接矩阵那么大,所以我们会比较常用邻接表的方式来表示图.

**图的实现**

* API设计

  * 类名 : Graph
  * 构造方法 : Graph(int V) : 构造一个包含V个顶点但不包含边的图
  * 成员变量
    * private final int V : 记录顶点数量
    * private int E : 记录边数量
    * private Queue<Integer> [] adj : 邻接表
  * 成员方法
    * public int V() : 获取图中顶点数量
    * public int E() : 获取图中边的数量
    * public void addEdge(int v, int w) : 向图中添加一条边v-w
    * public Queue<Integer> adj(int v) : 获取和顶点v相邻的所有顶点

* 代码实现:

  ```Java
  import com.qin.ShuJuJeGouStudy.ShuJuJieGou.XianXingBiao.DuiLie;
  public class Graph {
      private final int V;
      private int E;
      private DuiLie<Integer>[] adj;
  
      public Graph(int V){
          this.V = V;
          E = 0;
          this.adj = new DuiLie[V];
          for (int i = 0; i < V; i++) {
              adj[i] = new DuiLie<Integer>();
          }
      }
  
      public int V() {
          return V;
      }
  
      public int E() {
          return E;
      }
  
      public void addEdge(int v,int w){
          //无向图中,边是没有方向的,所以边可以是v-w也可以是w-v.
          //所以v的邻接表中要有w,w中也要有v
          adj[v].enqueue(w);
          adj[w].enqueue(v);
          E++;
      }
  
      public DuiLie<Integer> adj(int v){
          return adj[v];
      }
  }
  ```
  

**图的搜索**

在很多情况下,我们需要遍历图,得到图的一些性质.比如找出图中与指定的顶点相连的所有顶点,或者判定某个顶点与指定顶点是否连通等等.

有关图的搜索,最经典的算法有深度优先搜索和广度优先搜索.

**深度优先搜索**

深度优先搜索指的是在搜索时,如果遇到一个节点既有子节点,又有兄弟节点,那么先找子节点,再去找兄弟节点:

![图的深度优先搜索](D:\Java学习笔记\picture\图的深度优先搜索.PNG)

深度优先搜索API设计

* 类名 : DepthFirstSearch
* 构造方法 : DepthFirstSearch(Graph G,int s): 构造深度优先搜索对象,使用深度优先搜索找出与顶点s相通的所有结点
* 成员变量
  * private boolean[] marked : 索引表示顶点,值表示当前顶点是否已经被搜索
  * private int count : 记录有多少个顶点与s顶点相通
* 成员方法
  * private void dfs(Graph G,int V) :深度优先算法
  * public boolean marked(int w) : 判断顶点w与顶点s是否连通
  * public int count() : 获取与顶点s相通的顶点的个数

代码实现 : 

```Java
public class GraphDepthFirstSearch {
    private boolean[] marked;
    private int count;

    public GraphDepthFirstSearch(Graph g,int s){
        //初始化marked数据
        marked = new boolean[g.V()];
        //初始化与顶点s相通的顶点数量
        count = 0;
        //搜索与顶点s相通的顶点数量
        dfs(g,s);
    }

    private void dfs(Graph g,int v){
        //深度优先搜索核心实现
        //把顶点v标识为已搜索
        marked[v] = true;
        //遍历顶点v的邻接表
        DuiLie<Integer> adj = g.adj(v);
        for (Integer w : adj) {
            if (!marked(w)) {
                dfs(g, w);
            }
        }
        //连通个数++
        count++;
    }

    public boolean marked(int w){
        return marked[w];
    }

    public int count() {
        return count;
    }
}
```







**广度优先搜索**

广度优先搜索就与深度优先搜索相反,是先去找兄弟节点再去找子节点

广度优先搜索查找顺序:

![图的广度优先搜索顺序](D:\Java学习笔记\picture\图的广度优先搜索顺序.PNG)

广度优先搜索API设计:

* 类名 :  BreadthFirstSearch
* 构造方法 : BreadthFirstSearch(Graph g,int s): 构造广度优先搜索对象,使用广度优先搜索找出图g中与s顶点相邻的所有顶点
* 成员方法
  * private void bfs(Graph g,int v) : 广度优先搜索,找出图g中与顶点v相连通的所有顶点
  * public boolean marked(int w) : 判断w顶点与s顶点是否相通
  * public int count():获取与顶点s相通的所有顶点数量
* 成员变量
  * private boolean[] marked : 索引代表顶点,值表示当前顶点是否已经被搜索
  * private int count : 记录与s顶点连通的顶点数
  * private DuiLie<Integer> waitSearch : 辅助数组,用来存储待搜索顶点的邻接表

* 代码实现

  ```Java
  public class BreadthFirstSearch {
      private boolean[] marked;
      private int count;
      private DuiLie<Integer> waitSearch;
  
      public BreadthFirstSearch(Graph g,int s) {
          marked = new boolean[g.V()];
          count = 0;
          waitSearch = new DuiLie<Integer>();
          bfs(g,s);
      }
  
      private void bfs(Graph g,int v){
          //把当前顶点v标识为已搜索
          marked[v] = true;
          //让顶点v进入队列,等待搜索
          waitSearch.enqueue(v);
          //通过循环,如果队列不为空,就从队列中弹出一个待搜索的顶点进行搜索
          while (!waitSearch.isEmpty()){
              //如果队列不为空,弹出一个待搜索的顶点
              Integer wait = waitSearch.deenqueue();
              //遍历wait顶点的邻接表
              for (Integer integer : g.adj(wait)) {
                  if (!marked(integer)){//如果这个顶点跟s顶点相连通,就over,如果没连通,就继续搜索
                      bfs(g,integer);
                  }
              }
          }
          count++;
      }
  
      public boolean marked(int w){
          return marked[w];
      }
  
      public int count() {
          return count;
      }
  }
  ```

**路径查找**

在显示生活中,我们经常会使用地图来规划路线,输入一个出发点和一个目的地,就可以把路线规划好,而对于图这种数据结构来讲,从顶点s到顶点v是否存在一条路径这样的问题就是地图找路的问题,也就是路径查找问题.

路径查找算法API设计:

* 类名:DepthFirstPaths
* 构造方法 : DepthFirstPaths(Graph g,int s) : 构造深度优先搜索对象,通过dfs找出图g中起点为s的所有路径
* 成员变量 
  * private boolean[] marked : 索引表示顶点,值表示当前顶点是否已经被搜索
  * private int s : 表示起点顶点
  * private int[] edgeTo : 索引代表顶点,值表示从起点s到当前顶点路径上的最后一个顶点
* 成员方法
  * private void dfs(Graph g,int v) : 使用dfs找出图g中与v顶点相连通的顶点
  * public boolean hasPathTo(int v) : 判断顶点v与s是否存在路径
  * public STACK<Integer> pathTo(int v) : 找出从起点s到目标v的路径

* 代码实现

  ```Java
  public class DepthFirstPaths {
      private boolean[] marked;
      private int s;
      private int[] edgeTo;
  
      public DepthFirstPaths(Graph g,int s){
          this.marked = new boolean[g.V()];
          this.s = s;
          this.edgeTo = new int[g.V()];
          dfs(g,s);
      }
  
      private void dfs(Graph g,int v){
          //标识v为已搜索
          marked[v] = true;
          //遍历v的邻接表,拿到每个相邻顶点进行递归搜索
          DuiLie<Integer> adj = g.adj(v);
          for (Integer w : adj) {
              //如果顶点w没有被搜索,就对它进行递归搜索
              if (!marked[w]){
                  //记录到达w顶点的路径上的最后一个顶点是v
                  edgeTo[w] = v;
                  dfs(g,w);
              }
          }
      }
  
      public boolean hasPathTo(int v){
          return marked[v];
      }
  
      public STACK<Integer> pathTo(int v){
          //判断从顶点v到s是否有路径
          if (!hasPathTo(v)){
              return null;
          }
          //创建栈来保存路径中的所有顶点
          STACK<Integer> path = new STACK<>();
          //从顶点v开始,遍历edgeTo数组,一直找到起点为止
          for (int x = v;x != s;x = edgeTo[x]){
              path.Push(x);
          }
          //完成后也要把起点放入栈中
          path.Push(s);
  
          return path;
      }
  }
  
  ```
  

**有向图**

在实际生活中,很多应用相关的图是有方向的,比如网络,可以从A页面的连接跳转到B页面,此时A与B的连接方向是A->B,而不能说是B->A,此时就需要有向图来解决这一类问题.

* 有向图的相关术语

  * 定义

    有向图是一副具有方向性的图,是由一组顶点和一组有方向的边组成的,每条有方向的边都连着一对有序的顶点

  * 出度

    由某个顶点指出的边的个数称为该顶点的出度

  * 入度

    指向某个顶点的边的个数称为该顶点的入度

  * 有向路径

    由一系列顶点组成,对于其中的每个顶点都存在一条有向边,从它指向序列中的下一个顶点

  * 有向环

    一条至少含有一条边,且起点和终点相同的有向路径

* 一副有向图中两个顶点v和w可能存在以下四种关系

  * 没有边相连,也就是不相通
  * 存在从v到w的边v->w
  * 存在从w到v的边w->v
  * 即存在v->w的边也存在w->v的边,也就是双向连接

实际中的有向图规模一般都很大,我们来看的话是很难看明白的,且不说简单的,稍微庞大一点点我们就很难通过眼睛分析出来了.

* 有向图实现

  * API设计

    * 类名: Digraph

    * 构造方法 : Digraph(int V) : 构建一个有V个顶点但不含边的有向图

    * 成员变量

      * private final int V : 记录顶点数量
      * private int E : 记录边数量
      * private DuiLie<Integer>[] adj : 邻接表

    * 成员方法

      * public int V() : 获取有向图的顶点数量
      * public int E() : 获取有向图的边数量
      * public void addEdge(int v,int w) : 向有向图中添加一条从v到w的边
      * public DuiLie<Integer> adj(int v) : 获取由v指出的边所连接的所有顶点
      * private Digraph reverse() : 获取这个有向图的反向图

      反向图存在的目的是可以方便的获取到指向顶点v的其他顶点

  * 代码实现

    ```Java
    public class Digraph {
        private final int V;
        private int E;
        private DuiLie<Integer>[] adj;
    
        public Digraph(int V){
            this.V = V;
            this.E = 0;
            this.adj = new DuiLie[V];
            for (int i = 0; i < adj.length; i++) {
                adj[i] = new DuiLie<Integer>();
            }
        }
    
        public int V(){
            return V;
        }
    
        public int E(){
            return E;
        }
    
        private Digraph reverse(){
            Digraph r = new Digraph(V);
            //遍历原图的每一个顶点
            for (int i = 0; i < V; i++){
                //获取顶点i指出的所有边
                for (Integer w : adj[i]) {
                    //原图中表示的是顶点i指向w的边
                    r.addEdge(w,i);//方向添加方向边
                }
            }
            return r;
        }
    
        public void addEdge(int v,int w){
            //只需要让顶点w出现在v的邻接表中即可
            adj[v].enqueue(w);
            E++;
        }
    
        public DuiLie<Integer> adj(int v){
            return adj[v];
        }
    }
    
    ```

  * 拓扑排序

    在实际生活中,我们经常要在同一时间接到许多需要完成的任务,而这些任务的完成次序是存在先后顺序的.以Java后端学习为例,我们需要从Java基础->JavaWeb->Java框架等这样一个循序渐进且有依赖的过程,比如学习JavaWeb的前提是掌握了Java基础.我们可以把这个过程简化为以标号为顶点编号的方式来表示整个过程,我们把这些顶点进行排序转换成一个线性序列,这就需要拓扑排序来解决.

    * 拓扑排序定义

      给顶一副有向图,将所有的顶点排序,使得所有的有向边均从排在钱买你的元素指向排在后面的元素,此时就可以明确的表示处每个顶点的优先级.

    * 检测有向图中的环

      当要学习一个内容的时候必须要先学另一个内容,而学另一个内容的时候又要学这个内容,那这就成一个环了,我们就不知道要从哪开始了.因此为了使用拓扑排序解决优先级问题,我们必须要保证图中没有环的存在

      * 检测有向图环的实现

        * 类名 : DirectedCycle

        * 构造方法:DirectedCycle(Digraph g) : 构造一个检测环对象,检测图g中是否有环

        * 成员变量

          * private boolean[] marked : 索引代表顶点,值表示当前顶点是否已经被搜索
          * private boolean hasCycle : 记录图中是否有环
          * private boolean[] onStack : 索引代表顶点,记录当前顶点有没有处于正在搜索的有向路径上

        * 成员方法

          * public boolean hasCycle () : 判断图中是否忧患
          * private void dfs(Digraph g,int v) : 基于深度优先搜索检测有向图g中是否有环

        * 检测有向环的原理

          我们有一个onStack[]的布尔数组,索引为顶点,当我们进行深度遍历时,

          * 如果当前顶点正在索索,则把对应的onStack数组中的值改为true,标识为进栈
          * 如果当前顶点搜索完毕,则把对应的onStack数组中的值改为false,标识为出栈
          * 如果即将要搜索某个顶点,但该顶点已经在栈中,则说明有环

        * 代码实现

          ```Java
          public class DirectedCycle {
              private boolean[] marked;
              private boolean hasCycle;
              private boolean[] onStack;
          
              public DirectedCycle(Digraph g){
                  this.marked = new boolean[g.V()];
                  hasCycle = false;
                  this.onStack = new boolean[g.V()];
                  //要遍历图中的所有顶点,并对每个顶点都进行搜索,防止多个子图构成的图检测不到环
                  for (int i = 0; i < g.V(); i++) {
                      if (!marked[i]){
                          dfs(g,i);
                      }
                  }
              }
          
              private void dfs(Digraph g,int v){
                  //将顶点v标识为已搜索
                  marked[v] = true;
                  //v进栈
                  onStack[v] = true;
                  //进行深度搜索
                  DuiLie<Integer> adj = g.adj(v);
                  for (Integer w : adj) {
                      if (!marked[w]){
                          dfs(g,w);
                      }
                      //判断当前顶点是否在栈中,如果在那就找到环了
                      if (onStack[w]){
                          hasCycle = true;
                          return;
                      }
                  }
                  //当前顶点出栈
                  onStack[v] = false;
              }
          
              public boolean hasCycle(){
                  return hasCycle;
              }
          }
          ```

    * 基于深度优先的顶点排序

      如果要把图中的顶点生成线性序列其实是非常简单的,我们只要在深度搜索的时候,将已经搜索的顶点放入一个线性序列的数据结构中,就可以完成排序了.

      * 顶点排序实现

        * API设计

          * 类名:DepthFirstOrder
          * 构造方法 : DepthFirstOrder(Digraph g) : 构造一个顶点排序对象,生成顶点线性序列
          * 成员变量
            * private boolean[] marked : 索引代表顶点,值表示当前顶点是否被搜索
            * private STACK<Integer> reversePost : 使用栈来存储顶点序列
          * 成员方法
            * private void dfs(Digraph g,int v) : 基于深度优先搜索,生成顶点线性序列
            * public STACK<Integer> reversePost() : 获取顶带你线性序列

        * 代码实现

          ```JAVA
          public class DepthFirstOrder {
              private boolean[] marked;
              private STACK<Integer> reversePost;
          
              public DepthFirstOrder(Digraph g){
                  this.marked = new boolean[g.V()];
                  this.reversePost = new STACK<Integer>();
                  //遍历每个顶点,以每个顶点作为入口完成一次搜索
                  for (int i = 0; i < g.V(); i++) {
                      if (!marked[i]){
                          dfs(g,i);
                      }
                  }
              }
          
              private void dfs(Digraph g,int v){
                  marked[v] = true;
                  DuiLie<Integer> adj = g.adj(v);
                  for (Integer w : adj) {
                      if (!marked[w]){
                          dfs(g,w);
                      }
                  }
                  reversePost.Push(v);
              }
          
              public STACK<Integer> reversePost(){
                  return reversePost;
              }
          }
          
          ```

    * 拓扑排序实现

      * API设计
      
        * 类名 : TopoLogical
        * 构造方法 : TopoLogical(Digraph g) : 构造拓扑排序对象
        * 成员变量
          * private STACK<Integer> order : 顶点的拓扑排序
        * 成员方法
          * public boolean isCycle() : 判断图g是否有环
          * public STACK<Integer> order : 获取拓扑排序的所有顶点
      
      * 代码实现
      
        ```JAVA
        public class TopoLogical {
            private STACK<Integer> order;
        
            public TopoLogical(Digraph g){
                //首先要检测图g里有没有环
                DirectedCycle cycle = new DirectedCycle(g);
                if(!cycle.hasCycle()){
                    //如果没环就进行顶点排序
                    DepthFirstOrder order = new DepthFirstOrder(g);
                    this.order = order.reversePost();
                }
            }
        
            public boolean isCycle(){
                return order == null;
            }
        
            public STACK<Integer> order(){
                return order;
            }
        }
        ```
  
  
  
  
  * 加权无向图
  
    加权无向图是一种为每一条边关联一个权重值或者是成本的图模型.这种图可以自然的表示很多种应用.比如在一副航空图种,边表示航线,权值可以表示距离或者费用;在电路图中,边表示导向,权值可以表示导线的长度,或者是信号通过这条线所需的时间(也就是成本);所以我们很容易就能想到那些最小成本的问题,比如西安到纽约,要怎样走才能使时间最小或者金钱成本最低.
  
    * 加权无向图的边表示
  
      加权无向图中的边我们就没法用简单的v-w两个顶点来表示了,因为有一个权重值的存在,因此我们可以用对象来描述一条边
  
      * API设计
  
        * 类 : Edge implements Comparable<Edge>
        * 构造方法 : Edge(int v,int w,double weight) : 通过顶点v和w以及权重weight构造一个边对象
        * 成员变量
          * private final int v :  顶点v
          * private final int w: 顶点w
          * private final double weight : 权重值
        * 成员方法
          * public double weight() : 获取边的权重值
          * public int either() : 获取边上的一个点
          * public int other(int vertex) : 获取边所除了顶点vertex外的另一个顶点
          * public int conparaTo(Edge that) : 比较当前便和参数that的权重,如果当前边的权重大就返回1,如果一样大就返回0,如果当前边权重较小就返回-1
  
      * 代码实现
  
        ```JAVA
        public class Edge implements Comparable<Edge>{
            private final int v;
            private final int w;
            private final double weight;
        
            public Edge(int v,int w,double weight){
                this.v = v;
                this.w = w;
                this.weight = weight;
        
            }
        
            public double weight(){
                return weight;
            }
        
            public int either(){
                return v;
            }
        
            public int orther(int vertex){
                if (v == vertex){
                    return w;
                }
                return v;
            }
        
            @Override
            public int compareTo(Edge o) {
                return Double.compare(this.weight, o.weight);
            }
        }
        ```
  
    * 加权无向图的实现
  
      * API设计
  
        * 类名 : EdgeWeightedGraph
        * 构造方法 : EdgeWeightedGraph(int V) : 构造一个含有V个顶点的加权无向图
        * 成员变量
          * private final int V : 记录顶点数量
          * private int E : 记录边的数量
          * private DuiLie<Edge>[] adj : 邻接表
        * 成员方法
          * public int V() : 获取图中的顶点数量
          * public int E() : 获取图中的边的数量
          * public void addEdge(Edge e) : 向加权无向图中添加一条边
          * public DuiLie<Edge> adj(int v) : 获取顶点v关联的所有边
          * public DuiLie<Edge> edges() : 获取加权无向图的所有边
  
      * 代码实现
  
        ```JAVA
        public class EdgeWeightedGraph {
            private final int V;
            private int E;
            private DuiLie<Edge>[] adj;
        
            public EdgeWeightedGraph(int V){
                this.V = V;
                this.E = 0;
                this.adj = new DuiLie[V];
                for (int i = 0; i < adj.length; i++) {
                    adj[i] = new DuiLie<Edge>();
                }
            }
            public int V(){
                return V;
            }
            public int E(){
                return E;
            }
            public void addEdge(Edge e){
                int v = e.either();
                int w = e.orther(v);
                adj[v].enqueue(e);
                adj[w].enqueue(e);
                E++;
            }
            public DuiLie<Edge> adj(int v){
                return adj[v];
            }
        
            public DuiLie<Edge> edges(){
                DuiLie<Edge> allEdges = new DuiLie<>();
                //遍历图中的每一个顶点,找到各自的邻接表,邻接表中存的就就算该顶点关联的每一条边
                //但是无向图中,同一条边会被记录两次,需要让一条边只记录一次
                for (int v = 0 ; v < V; v++){
                    for (Edge e : adj[v]) {
                        int ew = e.orther(v);
                        if (ew < v){
                            allEdges.enqueue(e);
                        }
                    }
                }
                return allEdges;
            }
        
        }
        ```
  
        
  
  * 最小生成树
  
    前面我们给无向图的边增加了一个权重,那么我们就可以根据这个权重去解决最小成本问题了.但如何才能找到最小成本对应的顶点和边呢,这就要学习到最小生成树了.它的相关算法就是用来解决这类问题的.
  
    * 定义
  
      图的生成树是它的一颗含有其所有顶点的无环连通子图,一副加权无向图的最小生成树它的一颗树的权值(树中所有边的权重之和)最小.
  
      只考虑连通图,最小生成树的定义说明它只存在于连通图中,如果图不是连通图,那么分别计算每个连通图子图的最小生成树,合并到一起称为最小生成森林.
  
      所有边的权重都各不相同,如果不同边的权重可以相同,那么一幅图的最小生成树就可能不唯一了,虽然我们的算法能够去处理这种情况.
  
    * 最小生成树的原理
  
      * 性质
  
        * 用一条链连接树种的任意两个顶点都会产生一个新的环
  
          ![最小生成树性质1](D:\Java学习笔记\picture\最小生成树性质1.PNG)
  
        * 从树种删除任意一条边,将会得到两颗独立的树
  
          ![最小生成树性质2](D:\Java学习笔记\picture\最小生成树性质2.PNG)
  
      * 切分定理
  
        要从一副连通图种找出该图的最小生成树,就需要通过切分定理
  
        * 切分
  
          将图的所有顶点按照某些规则分为两个非空且没有交集的集合.
  
        * 横切边
  
          连接两个属于不同集合的顶点的边称之为横切边.
  
          比如我们将图中的顶点切分为两个集合,灰色顶点属于一个集合,白色顶点属于另外一个集合,效果如下:
  
          ![横切边](D:\Java学习笔记\picture\横切边.PNG)
  
          连接灰色集合和白色集合之间的边(黑色高亮实线)就是横切边.
  
        * 切分定理
  
          在一副加权无向图中,给定任意的切分,它的**横切边中的权重最小者**必然属于图中的最小生成树,比如:
  
          ![切分定理](D:\Java学习笔记\picture\切分定理.PNG)
  
          注意:一次切分产生的多个横切边中,权重最小的边不一定是所有横切边中唯一属于图的最小生成树的边.
  
      * 贪心算法
  
        弹性算法是计算图的最小生成树的基础算法,它的基本原理就是切分定理.使用切分定理找到最小生成树的一条边,不断重复直到找到最小生成树的所有边.如果图有V个顶点,那么需要找到V-1条边,就可以表示该图的最小生成树.
  
        计算图的最小生成树的算法有很多,但是它们都可以看作是贪心算法的一种特殊情况,这些算法的不同之处就在保存切分和判定去找你红最小的横切边的方式
  
        * Prim算法
  
          这个算法是一种计算最小生成树的算法.
  
          它的每一步都会为一颗生成中的树添加一条边,一开始这棵树只有一个顶点,然后会向它添加V-1条边,每次总是将下一个连接树中的顶点与不在树中的顶点且权重最小的边加入到树中.
  
          * Prim算法的切分规则
  
            把最小生成树中的顶点看作是一个集合,把不在最小生成树中的顶点看作是另外一个集合.
  
          * Prim算法的实现原理
  
            Prim算法始终将图中的顶点切分为两个集合,最小生成树顶点和非最小生成树顶点,通过不断的重复做某些操作,可以将非最小生成树的顶点都加入到最小生成树中,直到所有的顶点都加入到了最小生成树中.
  
            我们的API设计中,使用了最小索引优先队列存放树中顶点和非树中顶点的有效横切边,那它是如何表示的嘞 : 我们可以让最小索引优先队列的索引值表示图的顶点,让最小索引优先队列中的值表示从其他某个顶点到当前顶点的边权重.
  
            比如如下图的步骤:
  
            ![Prim实现原理例子](D:\Java学习笔记\picture\Prim实现原理例子.PNG)
  
            初始化状态,先默认0是最小生成树中的唯一一个节点,其他的顶点都是非最小生成树中的顶点,此时的横切边就是0-2,0-4,0-6,0-7这四条边,我们只需要将索引优先队列的2,4,6,7索引处分别存储这些边的权重就可以表示了.
  
            现在只需要从这四条横切表重找出权重最小的边,然后把对应的顶点加入到生成树中即可.因此就可以把0-7这条边加入进来,此时0和7都是最小生成树中的节点,其他的不属于.现在我们需要做两个操作:
  
            * 0-7这条边已经不是横切边了,需要让他失效:只需要调用最小索引队列的delMin方法即可,也就是删掉最小的.
            * 2和4的顶点各有两条连接指向最小生成树,需要只保留一条 : 4-7的权重小于0-4的权重,因此保留4-7,调用索引优先队列的change(4,0.37)即可.0-2的权重小于2-7的权重,所以保留0-2,不需要做其他操作.
  
            ![Prim实现原理例子2](D:\Java学习笔记\picture\Prim实现原理例子2.PNG)
  
            只需要不断重复上面的操作,就可以把所有的顶点加入到最小生成树中.
  
          * Prim的实现
  
            * API设计
  
              * 类名 : PrimMST
              * 构造方法 : PrimMST(EdgeWeightedGraph g) : 根据一副加权无向图,创建最小生成树构造对象
              * 成员变量
                * private Edge[] edgeTo : 索引表示顶点,值表示当前顶点和最小生成树之间的最短边
                * private double[] distTo : 索引代表顶点,值表示当前顶点和最小生成树之间的最短边的权重 
                * private boolean[] marked : 索引代表顶点,值表示当前顶点是否已经在最小生成树中 
                * private IndexMinPriorityDuiLie<Double> pq : 存放树中顶点与非树中顶点之间的有效横切边
              * 成员方法
                * private void visit(EdgeWeightedGraph g,int v) : 将顶点v添加到最小生成树中,并且更新数据
                * public DuiLie<Edge> edges() : 获取最小生成树的所有边
  
            * 代码实现
  
              ```JAVA
              public class PrimMST {
                  private Edge[] edgeTo;
                  private double[] distTo;
                  private boolean[] marked;
                  private IndexYouXianDuiLie<Double> pq;
              
                  public PrimMST(EdgeWeightedGraph g,int v){
                      edgeTo = new Edge[g.V()];
                      distTo = new double[g.V()];
                      Arrays.fill(distTo, Double.POSITIVE_INFINITY);
                      marked = new boolean[g.V()];
                      pq = new IndexYouXianDuiLie<Double>(g.V());
                      //默认让顶点0进入树中,但树中只有一个顶点0,所以0默认没有和其他顶点相连
                      //所以distTo[0]= 0.0;
                      distTo[0] = 0.0;
                      pq.insert(0,0.0);
                      //初始化完毕,开始进行遍历索引优先队列,拿到最小横切边对应的顶点并加入到树中
                      while (!pq.isEmpty()){
                          visit(g,pq.delMin());
                      }
                  }
              
                  private void visit(EdgeWeightedGraph g,int v){
                      //把顶点v加入到最小生成树中,并进行标记
                      marked[v] = true;
                      //更新数据最小索引优先队列的数据和EdgeTo以及distTo里的数据
                      for (Edge edge : g.adj(v)) {
                          int orther = edge.orther(v);
                          //判断另外一个顶点是否在树中,如果不在树中就要更新数据
                          if (!marked[orther]){
                              if (edge.weight() < distTo[orther]){//比较边edge是否小从orther顶点到树中以及存在的最小边的权重
                                  edgeTo[orther] = edge;
                                  distTo[orther] = edge.weight();
                                  if (pq.contains(orther)){
                                      pq.changeItem(orther,edge.weight());
                                  }else {
                                      pq.insert(orther,edge.weight());
                                  }
                              }
                          }
                      }
                  }
              
                  public DuiLie<Edge> edges(){
                      DuiLie<Edge> edges = new DuiLie<>();
                      //遍历edgeTo,拿到每一条边,只要不是null就加入到队列
                      for (Edge edge : edgeTo) {
                          if (null != edge){
                              edges.enqueue(edge);
                          }
                      }
              
                      return edges;
                  }
              }
              
              ```
  
      * Kruskal算法
  
        Kruskal算法是计算一副加权无向图的最小生成树的另一种算法,它的主要思想是按照边的权重(从小到大)处理它们,将边加入加入最小生成树中,加入的边不会与已经加入最小生成树的边构成环,直到树中含有V-1条边为止.
  
        * Kruskal算法与Prim算法的区别
  
          Prim算法是一条边一条边的去构造最小生成树,每一步都为树添加一条边.Kruskal算法构造最小生成树的时候也是一条边一条边构造的,但它的切分规则是不一样的.它每一次寻找的边会连接一片森林中的两棵树.如果一副加权无向图由V个顶点构成,初始化情况下每个顶点都构成一颗独立的属,则V个顶点对应V棵树,组成一片森林,Kruskal算法每一次处理都会将两棵树合并成一棵树,直到整个森林中只剩下一棵树为止.
  
        * Kruskal算法的实现原理
  
          在我们的API中,使用了一个最小优先队列pq来存储图中所有的边,每次是哦那个pq.delMin()来取出权重最小的边,并得到该边关联的两个顶点v和w,通过uf.connect(v,w)来判断v和w是否已经连通,如果连通了就说明它们两个在同一棵树中,那么久不用把这条边加入到最小生成树中.因为在一棵树的任意两个顶点上添加一条边都会形成环,而最小生成树中不可以存在环,如果不连通,就可以通过uf,union(v,w)把两个顶点对应的树合并成一棵树,并把这条边加入到mst队列中,这样如果把所有边都处理完毕了,最终mst中存储的就是最小生成树中的所有边:
  
          ![kruskal算法](D:\Java学习笔记\picture\kruskal算法.PNG)
  
          ![Kruskal算法2](D:\Java学习笔记\picture\Kruskal算法2.PNG)
  
          ![kruskal算法3](D:\Java学习笔记\picture\kruskal算法3.PNG)
  
          ![kruskal算法4](D:\Java学习笔记\picture\kruskal算法4.PNG)
  
          ![kruskal算法5](D:\Java学习笔记\picture\kruskal算法5.PNG)
  
          ![kruskal算法6](D:\Java学习笔记\picture\kruskal算法6.PNG)
  
        * Kruskal算法实现
  
          * API
  
            * 类名 : KruskalMST
            * 构造方法 : KruskalMST(EdgeWeightedGraph g) : 根据一副加权无向图,创建Kruskal算法构造最小生成树
            * 成员变量
              * private DuiLie<Edge> mst : 保存最小生成树的所有边
              * private UF_Tree_Weighted uf ; 索引表示顶点,使用uf.connect(v,w)可以判断v,w两个顶点是否在同一棵树中,是用uf,union(v,w)可以把顶点v所在的树和顶点w所在的树合并
              * private ZuiXiaoYouXianDuiLie<Edge> pq : 存储图中所有的边,使用最小优先队列,对边按照权重进行排序.
            * 成员方法
              * public DuiLie<Edge> edges() : 获取最小生成树的所有边
  
          * 代码实现
  
            ```JAVA
            public class KruskalMST {
                private DuiLie<Edge> mst;
                private UF_Tree_Weighted uf;
                private ZuiXiaoYouXianDuiLie<Edge> pq;
            
                public KruskalMST(EdgeWeightedGraph g){
                    mst = new DuiLie<Edge>();
                    uf = new UF_Tree_Weighted(g.V());
                    pq = new ZuiXiaoYouXianDuiLie<Edge>(g.E());
                    //将边存储到pq中
                    for (Edge edge : g.edges()) {
                        pq.insert(edge);
                    }
                    //初始化完毕,遍历pq,取得最小权值的边进行处理
                    while (!pq.isEmpty() && mst.Size() < g.V()-1){
                        //找到权值最小的边
                        Edge edge = pq.delMin();
                        //找到这个边的两个顶点
                        int v = edge.either();
                        int w = edge.orther(v);
                        //判断这两个顶点是否在一棵树中,在就下一条边,不在就合并
                        if (!uf.connected(v,w)) {
                            uf.union(v,w);
                            mst.enqueue(edge);
                        }
                    }
                    
                }
            
                public DuiLie<Edge> edges(){
                    return mst;
                }
            }
            ```
  
            
  
  * 加权有向图
  
    * 加权有向边的API设计
  
      * 类名 : DirectedEdge
      * 构造方法 : DirectedEdge(int v,int w,double weight) : 通过顶点v和w以及权重构造一个有向边
      * 成员变量
        * private final int v : 边起点
        * private final int w : 边终点
        * private final double weight : 边权重
      * 成员方法
        * public double weight() : 获取边的权重
        * public int from() : 获取有向边起点
        * public int to() : 获取有向边终点
  
    * 代码实现
  
      ```JAVA
      public class DirectedEdge {
          private final int v;
          private final int w;
          private final double weight;
      
          public DirectedEdge(int v,int w,double weight){
              this.v = v;
              this.w = w;
              this.weight = weight;
          }
      
          public int form(){
              return v;
          }
      
          public int to(){
              return w;
          }
      
          public double weight(){
              return weight;
          }
      }
      ```
  
    * 加权有向图的API设计
  
      * 类名 : EdgeWeightedDigraph
      * 构造方法 : EdgeWeightedDigraph(int V) : 构造一个有V个顶点的加权有向图
      * 成员变量
        * private final int V : 顶点数量
        * private int E : 边数量
        * private DuiLie<DirectedEdge>[] adj : 邻接表
      * 成员方法
        * public int V() :获取顶点数量
        * public int E() : 获取边数量
        * public void addEdge(DirectedEdge e) :添加加权有向边
        * public DuiLie<DirectedEdge> adj(int v) : 获取顶点v的邻接表
        * public DuiLie<DirectedEdge> edges() : 获取加权有向图的所有边
  
    * 加权有向图的代码实现
  
      ```JAVA
      public class EdgeWeightedDigraph {
          private final int V;
          private int E;
          private DuiLie<DirectedEdge>[] adj;
      
          public EdgeWeightedDigraph(int V){
              this.V = V;
              this.E = 0;
              this.adj = new DuiLie[V];
              for (int i = 0; i < adj.length; i++) {
                  adj[i] = new DuiLie<DirectedEdge>();
              }
          }
      
          public int V(){
              return V;
          }
      
          public int E(){
              return E;
          }
      
          public void addEdge(DirectedEdge edge){
              int v = edge.form();
              adj[v].enqueue(edge);
              E++;
          }
      
          public DuiLie<DirectedEdge> adj(int v){
              return adj[v];
          }
      
          public DuiLie<DirectedEdge> edges(){
              DuiLie<DirectedEdge> edges = new DuiLie<>();
              for (int i = 0; i < V; i++) {
                  for (DirectedEdge e : adj[i]) {
                      edges.enqueue(e);
                  }
              }
              return edges;
          }
      }
      ```
      
      
  
  * 最短路径
  
    我们在现实生活中,总是有这样的需求:从一个地方到另一个地方,并且我们总是会寻找时间/距离/费用最小的那个路径,这也就是我们的加权有向图的最短路径问题
  
    * 最短路径的定义和性质
  
      * 定义
  
        在一副加权有向图中,从顶点是到顶点t的最短路径是所有从顶点s到顶点t的路径中总权重最小的路径
  
      * 性质
  
        * 路径具有方向性
        * 权重不一定等价于距离.权重可以是距离/时间/花费等内容,权重最小指的是成本最低
        * 只考虑连通图,一幅图中并不一定是所有顶点都可达,如果s与t不可达,那它们之间也就不存在最短路径
        * 最短路径不一定是唯一的
  
      * 最短路径树 : 给定一副加u请安有向图和一个顶点s,以s为起点的一颗最短路径树是图的一副子图,它包含顶点s以及从s可达的所有顶点.这颗有向树的根节点为s,树的每条路径都是有向图中的一条最短路径
  
    * 松弛技术
  
      松弛技术来源于生活,一条橡皮筋沿着两个顶点的某条路径展开,如果这两个顶点之间短路径不止一条,如果存在更短的路径,那么把橡皮筋转移到更短的路径上,橡皮筋就可以放松下来了.
  
      松弛这种简单原理刚好可以用来计算最短路径树.
  
      在我们的API中,有两个成员变量edgeTo和distTo,它们分别存边和权重,一开是给定一副图g和顶点s,我们只知道图的边和这些边的权重,其他的义务索指,此时初始化顶点到顶点s的总去找你红distTo[s]=0;顶点s到其他顶点的总权重默认无穷大,随着算法的执行,不断用松弛技术处理图的边和顶点,并按照一定条件更新edgeTo和distTo中的数据,最终就能够得到最短路径树.
  
      * 边的松弛
  
        放松边v->w意味着检查从s到w的最短路径是否先从s到v然后再从v到w?如果是,则v到w这条边需要加入最短路径树中,更新edgeTo和distTo中的内容:edgeTo[w] = 表示v到w这条边的DirectedEdge对象,distTo[w] = distTo[v] + v到w这条边的权重;如果不是,就忽略v到w这条边的权重.
  
        ![松弛技术](D:\Java学习笔记\picture\松弛技术.PNG)
  
      * 顶点的松弛
  
        顶点的松弛是基于边的松弛完成的,只需要把某个顶点指出的所有边松弛,那么该顶点就松弛完毕.比如想要松弛顶点v,只需要遍历v的邻接表,把每一条边都松弛,那么顶点v就松弛了.
  
        比如把起点设置为0,那么找出0到6的最短路径0->2->7->3->6的过程如下:
        ![顶点的松弛](D:\Java学习笔记\picture\顶点的松弛.PNG)
  
    * 最短路径的API设计
  
      计算最短路径树的经典算法是dijstra(迪杰斯特拉)算法
  
      * 类名 : DijstraSP
      * 构造方法 : DijstraSP(EdgeWeightedDigraph g,int s) : 根据给定的加权有向图和顶点,计算以s为根节点的最短路径树
      * 成员变量
        * private DirectedEdge[] edgeTo : 索引表示顶点,只表示从顶点s到当前顶点的最短路径上的最后一条边
        * private double[] distTo :索引表示顶点,指表示顶点s到当前顶点的最短路径的总权重
        * private IndexYouXianDuiLie<Double> pq : 存放树中顶点与非树中顶点之间的有效横切边
      * 成员方法
        * private void relax(EdgeWeightedDigraph g,int v) : 松弛图g中的顶点v
        * public double distTo(int v) : 获取从顶点s到顶点v的最短路径的总权重
        * public boolean hasPathTo(int v) :判断顶点s到顶点v是否可达
        * public DuiLie<DirectedEdge> pathTo(int v) : 查询从起点s到顶点v的最短路径中的所有边
  
    * 代码实现
  
      ```JAVA
      public class DijstraSP {
          private DirectedEdge[] edgeTo;
          private double[] distTo;
          private IndexYouXianDuiLie<Double> pq;
      
          public DijstraSP(EdgeWeightedDigraph g,int s){
              edgeTo = new DirectedEdge[g.V()];
              distTo = new double[g.V()];
              pq = new IndexYouXianDuiLie<Double>(g.V());
              Arrays.fill(distTo, Double.POSITIVE_INFINITY);
              //初始化完毕,找到图g中以顶点s为起点的最短路径树
              //默认让顶点s进入最短路径树种
              distTo[s] = 0.0;
              pq.insert(s,0.0);
              //遍历pq,获得每一条边,进行松弛
              while (!pq.isEmpty()){
                  relax(g,pq.delMin());
              }
          }
      
          private void relax(EdgeWeightedDigraph g,int v){
              //放松顶点v,也就是放松这个顶点的所有边
              for (DirectedEdge e : g.adj(v)) {
                  //获取该边的终点
                  int w = e.to();
                  //通过松弛判断从起点s到顶点w的最短路径是否是先从s到v再由顶点v到w
                  if (distTo[v]+e.weight() < distTo[w]){
                      distTo[w] = distTo[v] + e.weight();
                      edgeTo[w] = e;
                      //判断pq中是否以及存在顶点w,如果存在,就更新权重,如果不存在,就直接加入
                      if (pq.contains(w)){
                          pq.changeItem(w,distTo[w]);
                      }else {
                          pq.insert(w,distTo[w]);
                      }
                  }
              }
      
          }
      
          public double distTo(int v){
              return distTo[v];
          }
      
          public boolean hasPathTo(int v){
              return distTo[v] < Double.POSITIVE_INFINITY;
          }
      
          public DuiLie<DirectedEdge> pathTo(int v){
              //判断从顶点s到v是否可达
              if (!hasPathTo(v)){
                  return null;
              }
              DuiLie<DirectedEdge> edges = new DuiLie<>();
              //逆推,找v的上一条边,以此往上找直到根节点s
              while (true){
                  DirectedEdge e = edgeTo[v];
                  if (null == e){
                      break;
                  }
                  edges.enqueue(e);
                  v = e.form();
              }
              return edges;
          }
      }
      ```
  



# 算法

## 时间复杂度

时间复杂度就是一个算法程序在实现结果的时候,需要付出的代价的最高阶项.

 		一个操作如果和样本的数据量没有关系,每次都是固定时间完成的操作,那么这个操作就是常数操作.比如我们从数组中取值:int a = array[1];这样就是一种常数操作.而我们从链表中去拿东西的时候就不是常数操作,因为它并不是一个连续的内存空间,要遍历找到我们想要的才能拿到.它的操作时间是与数据量有关的.平时的加减乘除,位运算等都是常数操作.

​		在我们的选择排序中,它会假定第一个是最小的,然后遍历后面的进行比较,假设我们我们有一个N个元素的数组,那么它会进行N+N-1+N-2+N-3+....+1次比较,进行相同次数的遍历,以及进行N次数据的交换,那么我们就可以得到,它最终会付出的代价(也就是总共的常数操作次数)将是 a*N的平方+b\*N+c,这里a,b,c都是常数,那么这个算法的时间复杂度将是N的平方,也就是保留最高次项.我们使用O(读作大O)来表示复杂度.那么选择排序的时间复杂度就是O(N²).那么为什么我们会忽略低阶项呢?是因为这个时间复杂度它是根据最高阶项作为上限的,现象以下,如果我们要对100亿个数据进行选择排序,是不是它的低阶项和系数对于N²来说就显得微不足道了呢.

* 算法优劣的比较

  算法优劣就体现在算法的复杂度上,包括空间复杂度和时间复杂度.这里就先说说时间复杂度,当然时间复杂度就是越低阶越好,是常数就更好.如果当两个算法的时间复杂度指标是一样的话,就得看常数项了,但是常数项是非常难以计算精确的.此时最好就是使用在不同数据样本下的实际运行时间来比较了,也就是用常数项时间来进行比较.

### 关于异或

我们可以使用异或操作来进行两个数据的交换,比如a = 1;b = 2;通过a ^= b;b ^= a; a ^= b;这样就可以交换过来,但是我们要注意一个点,就是这样操作的时候,a与b的地址必须不能是同一个,如果是同一个那么那块的地址将会被清零.

对于异或来讲,我们可以认为是相同为假不同为真,除此之外,我们还可以认为它是一个无进位相加运算.

这有个关于异或的面试题:

* 在一个整型的数组int[] arr中,有一个数据是出现了奇数次的,其他的都是出现了偶数次的,那么我们要如何找到这个奇数次的数据呢?要求时间复杂度为O(N),额外空间复杂度为O(1).那么如果是两个数据出现了奇数次呢?

  对于这个问题,我们可以只需要一个额外的整型变量,只需要将它和这个整型数组的所有数据都异或一遍,遍历结束后,这个整型变量的值就是我们要找的数据.

  对于第二问,我们可以设我们要找的数据是a,b,其他都是偶数次,也准备一个额外的整型变量,如果我们将它与数组中所有的数据异或后,它的结果就是a^b,而且a!=b,那么这个整型变量肯定不是0,那么这个整型变量的某一位上肯定不是0,那在那个位上,a和b肯定是不一样的,只有这种情况才能使得那个位不为0.此时我们再准备一个整型变量,让它去异或上那个位上不为0的数据,异或完成后,我们将会得到a或者b.那么再与前面那个整型变量异或一次,就可以得到我们要找的那两个数据了.

* 一些关于位运算的骚操作

  * 一个数与上自己的取反+1就可以得到最右边的1,并且其他位都是0.



### 关于二分查找的一些应用

* 查找一个有序数组中是否存在一个数

  这是最经典的二分查找用法

* 查找有序数组中比一个数还小的最左边的位置

  这个也可以使用二分查找来查询数据所在位置.

* 查询局部最小,就比如对于一个数组的0位置的数来说,如果它比1位置的数小,那么这个0位置的数就是局部最小,对于N-1位置,如果N-1位置比N-2位置小,那么N-1位置的数据就是局部最小.对于i位置的数来说,它需要比i-1位置的数小,比i+1位置的数小,它才是局部最小.

  对于这个问题也是可以使用二分查找的,即使数组不是有序的.我们可以直接查中间位置是否比M-1和M+1位置要小,是就直接返回.如果它不是局部最小,那么它左边或者右边肯定存在局部最小.只要二分下去就能肯定能找到一个局部最小的数据.

对于二分查找来说,并不一定是要求数据有序的,对于数据的特定状况和特定的问题时,即使数据是非有序的,也是可以使用二分的方法的.

而且我们平时找中点是这样 : (left + right) /2,当数组长度很长很长的时候,比如是Integer.MAX_VALUE,那么就会导致数据溢出,导致中点是一个负值.所以我们可以这么写来规避数据溢出: left + (right - left) / 2

### 对数器

对数器 : 我们有一个想要测试的方法a,然后有一个我们不考虑时间复杂度的解决方法b,我们平时测试代码都是通过线上OG,也就是使用别人的测试用例.但是我们也不能什么时候都用线上OG来测啊,因此,我们就可以使用对数器来进行测试.我们可以使用一个随机样本生成器,产生的数据在方法a与方法b中都进行运行一次,我们可以测试它们一定次数,当两个方法在某次测试中出现了不同的结果,那么要不就是方法a有问题要么就是方法b有问题或者是它们俩都有问题.然后我们通过人为干预和修改这个随机样本生成的数据长度和对代码的修改,测试到两个方法一直都是对的.那你的方法就肯定是对的了.这就是对数器.

对数器的作用就是判断我们解决问题的方法是否正确.



### 递归行为的剖析和递归行为的时间复杂度分析

一个简单的递归案例:求一个数组中的最大值

```Java
public int process(int[] arr,int left,int right){//母问题规模为N=left + right
    if(left == right){//除递归外的行为
        return arr[right];
    }
    int mid = left + ((right - left) >> 1);//除递归外的行为
    int leftmax = process(arr,left,mid);//子问题的规模为N/2,下面那个也是N/2,说明子问题是等量的,如果是左侧1/3调一次递归,右侧2/3调递归,那么就不是等量递归,就不符合master公式
    int rightmax = process(arr,mid,right);//调用了两次子问题
    return Math.max(leftmax,rightmax);//除递归外的行为
    //总的递归外行为复杂度为O(1).
    //所以这个递归符合master公式.所以可以直接得到时间复杂度.
}
```

我们把上面的步骤拆开来,可以得到一个二叉树,所以呢我们可以知道,递归其实就是对一个二叉树的后序遍历.并且是在方法栈中对于这个二叉树的压栈与出栈进行遍历完成的.

对于递归来讲,有一个master公式 :  T(N) = a*T(N/b) + O(N的d次幂).它的意思是,有一个规模为N的母问题,T(N/b)就是子问题的规模,a就是子问题的调用次数.最后那个是除了子问题调用之外的时间复杂度是多少.我们可以通过master公式来估计一个递归的时间复杂度.

对于master公式中的a,b,d三个参数,如果它们满足以下情况,它们的时间复杂度就有对应的值:

* 当log(b为底,a) < d的时候,递归复杂度为O(N的d次幂)
* 当log(b为底,a) = d的时候,递归复杂度为O(N的d次幂*logN)
* 当log(b为底,a) > d的时候,递归复杂度为O(N的log(b为底,a)次幂)

### 简单排序算法的时间复杂度分析

简单排序算法(冒泡,选择,插入)具体实现在上一个笔记中有.

* 对于冒泡来说,它要进行一次全遍历和一次N-1次内遍历,那么就是O(N²).
* 对于选择来说,它要进行一次N-1次遍历和N-1次内遍历,那么也就是O(N²)
* 对于插入排序来说,它的时间复杂度是与数据情况是有关的,因为它相当于是在一个已经有序的部分里去插入新的数据,如果这个要插入的数据一直比已经有序的部分的最后那个大,就可以直接放进去,甚至不需要进行遍历,那么它的复杂度就是O(N),而一般的时候都需要进行N次外遍历和N-1次内遍历,所以是O(N²).

### 时间复杂度为O(NlogN)的排序

* 归并排序

  以分治思想,将一组数据尽可能的拆分为等份的两份,直到每一个子组中的数据个数只剩一个,然后让两组都排序好,然后合并排序好的子组(通过双指针比较),最终合并出来的就是排序结果.归并排序为啥是O(NlogN)呢?

  我们可以在之前的归并排序的代码中看到,递归调用了两次,a = 2,并且递归的分量都是2,所以b = 2,merge方法的复杂度因为它是把排序好的放回原来的,所以很明显是O(N)的,所以得出d = 1,很明显,归并排序符合master公式,并且满足log(b,a) = d,因此归并排序的复杂度就是O(NlogN).









































