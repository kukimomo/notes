# JAVA学习内容及其路线

![img](https://i0.hdslb.com/bfs/article/f362d75a6fad0a76089f0741ed41d5990c6eeeae.jpg)

# JAVA基础语法

### Java常量：

1：整数:1,2,3,123

2：小数常量(浮点数)：带小数点的数字

3：字符常量：用单引号括起来的单个字符‘a’，‘A’，‘中’

4：字符串常量：用双引号括起来的部分“123”，“abc123”

5：布尔常量：只有两个：ture、false（真、假）

6：空常量：什么都不写

 

### 基本数据类型：

整数型：byte short int long

浮点型：float double

字符型：char

布尔型：boolean

引用数据类型：

字符串、数组、类、接口、Lambda

注：

1、字符串是引用类型，不是基本类型

2、浮点型可能不是精确的值

3、数据范围与字节数不一定相关

4、直接写数字的话

   浮点数默认类型是double，用float类型需要加上一个f/F后缀

   整型默认是int类型，用long型要加上l/L后缀

5、对于byte，short，char三种类型来说，右侧赋值的数值没有超过数据类型的范围，编译器会自动帮我们进行强制类型转换，如果赋值的数值超过数据类型范围，编译会报错。

 

使用变量时的注意事项：

1、创建多个变量时，变量名不可相同（同一个大括号里面）

2、对float与long型来说，字母后缀F与L不可省略

3、用byte或short型时，赋值的值不能超过类型的范围

4、变量一定要赋值后才可以使用

5、变量使用不能超出作用域的范围（作用域：从定义变量的一行开始，一直到所属的大括号结束位置的区域）

   创建变量之前不能使用变量

当数据类型不一样时，会发生数据类型转换

自动类型转换（隐性）

1.特点：代码不需要进行特殊处理，自动完成

2.规则：数据范围从小到大

比如（long a = 100）这段代码中，右侧的100默认为int变量，赋值给左边的long变量。符合规则。

强制类型转换（显性）【谨慎使用】

1.特点：代码需要特殊的格式处理，不能自动完成

2.格式：范围小的类型 范围小的变量名 = （范围小的类型）原本范围大的数据 

​       （如int）      （变量名）    （前面的数据类型）（范围大的数据）

如（int a = 100L,这里不符合自动转换规则，无法进行转换，正确格式为：int a = （int）100L

数据溢出：当把范围较大的类型强制转换成范围较小的类型时，范围较大的类型的变量值超过范围较小的类型就会导致数据溢出

精度损失：像小数，强制转换成整型等不含小数的类型时，小数点会消失，这就是精度损失

byte/short/char三种类型都可以进行数学运算，在运算时会成为int类型在进行运算

如byte a = 10；

  byte b = 20；

  （int） c = a+b；a与b先变成int型，最终结果为int，注意结果的类型。

布尔数据类型无法发生数据类型转换。

ASCII码表同C语言

ASCII值48代表‘0’

ASCII值为65代表‘A’

ASCII值为97代表‘a’

 

### 运算符

基本等同于C语言

如四则运算，取模运算

加：+

减：-

乘：* 

除：/ ：不能能够整除的只会得出整数部分

取模：% :取余数运算，在除法运算中取余数（只有对于整数的除法来说，取模运算才有意义）

运算当中有不同类型的数据时，结果取数据范围大的

如int+double会先变成double+double再得出double结果

给变量进行赋值时，如果右边的表达式中全是变量时，没有任何常量，那么编译器会直接将若干个常量表达式运算得到结果

【如果右边的表达式中都是常量，那么编译出的class字节码文件中相当于【直接就是】，这个操作就是编译器的常量优化，但是右边的表达式中有变量参与，编译器就不会进行这个优化】

 

 

 

 

 

### 加号的用法：

1：对于数值就是加法

2：对于字符（char）类型来说，字符会变成int类型（根据ASCII表进行转换）然后进行加法运算

3：对于字符串String（引用类型，不是关键字），加号代表字符串连接

字符串类型变量的基本使用：数据类型 变量名 = 数据值，如String a = “hello”

任何数据类型与字符串进行相加时，结果都会变成字符串

自增自减的用法（基本同C语言）：

单独使用时（不和其他操作混合使用，自己成为一个步骤）：单独使用时，自增自减号放在变量前后是一样的

混合使用时（和其他操作混合使用，如与赋值、打印等混合使用）：如果自增减在变量前，则先增减后进行运算等操作，如果自增减在变量后，则先使用变量再进行自增减

赋值运算符的用法（包含基本赋值与复合赋值）：

=：基本赋值运算符

+=,-=,*=,/=,%=：复合运算符

+=：a+=1相当于a=a+1

-=：a-=1相当于a=a-1

*=:a*=1相当于a=a*1

/=:a/=1相当于a=a/1

%=:a%=1相当于a=a%1

只有变量才可以使用赋值变量符，常量不可以用赋值运算符

赋值运算符使用时，不同类型的变量的结果还是原来的类型

比较运算符：

==：【 左边数据同右边进行比较，若成立则结果为ture

＜：

＞：

＜=（小于等于）：

＞=（大于等于）：

！=（不等于）：         】

比较运算符的结果一定是一个布尔值，成立为ture，不成立为false

如果进行多次判断，不能连着写 如（1<x<3）

逻辑运算符：

&&：与（并且），用于链接两个布尔值，全部是ture，否则全部是false

||：或（或者）,至少一个是ture，则结果为ture，全是false，结果才为false

！：非（取反）本来是ture，变成false

&&和||具有短路效果，如果根据左边已经可以判断得出最终结果，那么右边的代码将不再执行

逻辑运算符智能运用于布尔值，与、或运算符需要左右各有一个布尔值，非只需要写在一个布尔值的前面

如果有多个条件可以连续写  如（条件A && 条件B && 条件C || 条件D。。。。。。。。）

三元运算符（有三个数据参与的运算）

格式:数据类型 变量名 = 条件判断？表达式A：表达式B；（条件判断成立的话将表达式A的值赋值给左侧变量，如果不成立就将表达式B赋值给做边的变量）

一元：只需要一个数据就可以进行操作的运算符，如++，--，！

二元：要两个数据才可以进行操作的运算符，如+，-，*，/，

使用三元运算符是要保证表达式A与表达式B都符合左侧数据类型的要求

三元运算符的结果必须被使用

 

方法（类似C中的函数）：将一个功能抽取出来，把代码单独定义在一个大括号（{}）内，形成一个单独的功能

这样可以实验代码的复用性，解决代码冗余的现象[先看整体再看小部分]

方法名称的命名与变量一致，使用小驼峰

方法体：大括号当中可以包含任意条语句

方法定义的先后顺序无所谓

方法的定义不能产生嵌套包含关系

方法定义好了之后不会立即执行，一定要进行方法的【调用】（执行方法的操作就是调用）

调用方法的方法：

格式：方法名称（）；

 

 

 

JShell（脚本）命令：可以直接执行命令，不需创建文件（用于简短的项目条件下）

（输入什么就执行什么，一步一步执行的命令，就是脚本）

 

### 程序流程控制（代码执行的顺序）：

1、顺序结构：一步一步执行程序

2、判断语句：单if语句，if..else..语句，if..else if..else语句

单if语句：执行流程：先判断关系表达式的结果，如果说是true就执行语句体，如果是false就不执行。

格式：if（关系表达式）{

  语句体

  }

if..else语句【二选一】（用法基本同C语言）：

格式：if（关系表达式）{

  语句体1；

 

  }else{

  语句体2；

  }

 

 

if..else if..else语句【多选一】（用法基本等同于C语言）：

格式：if（判断条件1）{

  执行语句1； 

  }else if（判断条件2）{

  执行语句2；

  }

......

  else if(判断条件n){

  执行语句n；

  }else{

  执行语句n+1；

  }

 

3、选择语句：switch语句（类似C语言中的）

格式：switch(表达式【被检测量】){

  case 常量值1：（冒号）

  语句体1；

  break；

  case 常量值2：

  语句体2；

  break；

  .......

  case 常量值n：

  语句体n；

  break;

  ......

​        default：（作用同if..else if..else语句中的最后一个else）

  语句体n+1；

  break；（可省略，但不建议省略）

  }

 

注意：case语句后的数值不能相同

​     switch后的被检测量只可以是基本数据类型中的byte/short/char/int型

​         和引用数据类型中的String字符串，enum枚举

​     switch语句灵活，前后顺序可以颠倒。选择时，匹配到哪一个case就从哪一个位置向下执行，直到遇上break或者整体结束为止

### 4、循环结构【基本组成部分：1、（初始化语句【循环开始时执行，只做一次】，2、（条件判断）【成立就继续循环，不成立就推出循环】，3（循环体）【循环的内容】，4（步进语句）【每次循环后的扫尾，每次循环后都要有】）】

 

   循环语句：for语句，while语句，do while循环语句：

for语句格式：for（初始化表达式；布尔表达式（条件判断式）；步进表达式（循环一次后变量变化））{

 

​    循环体

 

​    }

while循环语句标准格式：while（条件判断）{

​      循环体

​      }

 

while循环语句扩展格式【与for一样】：while（条件判断）{

​      循环体；

​      步进表达式；

​      }

do while循环语句标准格式【与之前的循环不同，第一步是无条件执行的，即不管条件判断是否成立，都能进行一次循环】：do{

​      循环体；

​      步进表达式；

​      }while（条件判断）；

三种循环的区别：

1、若三种循环的条件判断从来没有满足过，则for循环与while循环会执行0次循环，而do-while循环会进行一次

2、for循环的变量在小括号中定义，只有循环内部使用。while循环和do-while循环循环初始化语句的初始化语句在外面，所以for循环中定义的变量在外面可以继续使用

 

break关键字的用法：

1、用于switch语句中，结束switch语句

2、用于循环语句中，打断循环【循环次数确定的话，用for方便】

continue关键字的用法：一旦执行，立刻跳过当前次循环内容，马上开始下一次循环

break与continue的区别：break后的全部没有了，continue只是continue的那一个一个没有了

 

 

出现死循环的情况：

1、忘记写步进表达式【错误】死循环运行时可用ctrl c强行停止

2、【开发用】死循环的标准格式：while（true）{

​        循环体；

​        }

在死循环后写语句会报错

 

嵌套循环【外循环一次，内循环多次】：

格式：for（初始化表达式；循环条件；步进表达式）{

  for（初始化表达式；循环条件；步进表达式）{

​      执行语句；

​    }

  }

 

集成开发环境（IDE）：是一种专门提高软件开发效率的软件                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

免费的IDE：Eclipse

收费的IDE：InetlliJ IDEA（广泛使用）

 

IDE保存文件的结构：

 

​        

​        文件*n        



​        [使用文档中的独特引言吸引读者的注意力，或者使用此空间强调要点。要在此页面上的任何位置放置此文本框，只需拖动它即可。]        



​        文件*n        



​        包-Package*n          包-Package*n        



项目-Project



 

所有代码要写在src文件里

包名称只能使用英文小写，数字，英文的     

​        模块-Moule        



.



名称的.可以分隔文件，如guilinligong.daxue.javaxuexi1这个名称，包含了三个文件，guilinligong包含daxue,daxue再包含javaxuexi1

 

 

可以输入代码的简写来快速输入代码

 

 

 

### 方法：

注意：方法定义的先后顺序无所谓

   方法定义必须是挨着的，不能在一个方法里定义另一个方法

   方法定义之后，不会自己执行，如果需要执行，一定要进行方法的定义

 

方法就是若干语句的功能集合。方法中的术语：

方法好比一个工厂，

钢铁厂：原料：铁矿石等，

产出物：铁

 

 

参数（原料）：就好比是原料，就是进入方法的数据

返回值（产物）：就是从方法中出来的产物

方法的完整定义模式：

修饰符 返回值类型 方法名称（参数类型 参数名称，…）{

 方法体

 return 返回值；

}

修饰符：就是public static

返回值类型：就是方法最终产生的数据的类型

方法名称：方法的名字，规则同变量，小驼峰。

参数类型：进入方法的数据是什么类型

参数名称：进入方法的数据对应的变量名称

参数如果有多个，用逗号进行分隔

方法体：方法要做的事

return：两个作用，第一停止当前方法，第二将后面的返回值还给调用处

返回值：方法执行后最终产生的数据结果

return后的返回值必须和方法名称前的返回值类型要保持对应。

一个方法内可以有多个return语句，但是必须保证同时只有一个会被执行到

 

方法的调用：三种调用方法：

单独调用：格式：

方法名称（参数）；

特点：没有打印赋值等，方法产生的结果都无法使用

 

 

 

 

打印调用：System.out.println(方法名称（参数）);

特点：把方法的调用写到打印语句中，结果将会进行打印显示

 

 

 

赋值调用：数据类型 变量名称 = 方法名称（参数）；

特点：把方法的结果赋值给一个变量

 

【此前学习的方法，返回值类型固定写为void，这种方法只能单独调用，不能进行打印调用或者赋值调用】

方法的调用流程：

1、 找到方法

2、 参数传递

3、 执行方法体

4、 带着方法的返回值返回到调用方法的地方【谁在调用我我就把结果还给谁】

对方法来说，参数可有可无，可以有很多

有参数与无参数的区别：

有参数：小括号中有内容【当一个方法需要一些数据条件，才能完成任务的时候】，如两个数字相加，要知道数字是多少，才能相加

无参数：小括号当中留空，一个方法不需要任何数据条件，自己就能独立完成任务，就是五参数。如定义一个参数，打印固定10次字符串

有返回值：调用方法>找到方法>传递参数>执行方法体>将返回值交给调用处【带着返回值】>调用方法….

无返回值：调用方法>找到方法>传递参数>执行方法体>直接结束【什么都不带】>调用方法…

注意事项：对于有返回值的方法，可以用单独调用、打印调用和赋值调用

而对于无返回值的方法，只能用单独调用【void方法】

 

 

### 方法的重载：

对于功能类似的方法来说，因为参数列表不一样，如果要记住这么多不同的方法名称，太麻烦，因此引入方法的重载（Overload）：各个方法的名称一样，但是参数列表不一样。这样可以只需要一个方法名称，就可以实现类似的多个功能。

方法重载与下列因素相关：

1、 参数个数不同

2、 参数类型不同

3、 参数的多类型顺序不同

方法重载与下列因素无关

1、 与参数名称无关

2、 与方法的返回值类型无关

 

 

在掉用输出语句的时候，println方法其实就是进行了多种数据类型的重载形式

 

 

### 数组：

存放多个相同数据类型的数据的容器

特点：

1、 数组是一种引用数据类型

2、 数组当中的多个数据，它们的类型必须统一

3、 数组的长度在程序运行期间不可改变

数组的创建：

1、 数组的初始化：在内存当中创建一个数组，并向其中赋予一些默认值

两种常见的初始化方式：1、动态初始化【指定长度】

​           静态初始化【指定内容】

 

动态初始化格式：数据类型[]数组名称 = new 数据类型[数组长度];

静态初始化格式：数据类型[]数组名称 = new 数据类型[]{元素1，元素2，…..}

省略格式的静态初始化：数据类型[]数组名称 = {…}；

数据类型：就是数组当中保存的数据的类型

左侧括号【[]】：代表我是一个数组

左侧数组名称：数组的名字

右侧的new：代表创建数组的动作，是一个关键字

右侧的数据类型：必须和左边数据类型保持一致

右侧中括号的长度：也就是数组当中可以保存多少个数据，是一个int数字

 

注意：静态初始化没有直接指定长度，会根据内容自动推算长度

静态初始化标准格式可以分为两个步骤

动态初始化标准格式也可以分为两个步骤

 

数组的编号大致同c语言

使用动态初始化数组的时候，其中的元素将会拥有一个默认值，其规则如下：

如果是整数类型，那么默认为0；

如果是浮点类型，那么默认为0；

如果是字符类型，那么默认为‘\u000’（不可见字符）

如果是布尔类型，那么默认为false

如果是引用类型，那么默认为null

注意：

静态初始化也有默认值：只不过系统马上把默认值替换成了大括号种的具体数值

 

### JAVA的内存：

​     

​        JAVA内存（5个部分）：    1：栈（Stack）：存放的都是方法种的局部变量（方法的参数，或者是方法{}内部的变量）。    作用域：一旦超出作用域，立刻从栈内存中消失    2：堆（Heap）：凡是new出来的东西，都在堆当中。堆内存里的东西都有一个地址值（16进制）    堆内存里的数据都有默认值，规则：     如果是整数类型，那么默认为0；    如果是浮点类型，那么默认为0；    如果是字符类型，那么默认为‘\u000’（不可见字符）    如果是布尔类型，那么默认为false    如果是引用类型，那么默认为null    3：方法区（Method Area）：储存.class相关信息，包含方法的信息。方法的运行在栈当中。    4：本地方法栈（Natice Method Stack）:与操作系统相关。    5：寄存器（pc Register）:与CPU相关。             



有五个部分：



​                

​        Int [] shuzu【数组的名称是一个局部变量】    { 通过地址值找到相应数据        }        



​        main(String[] args)【进入栈内存】                   System.out.println(shuzu);    Shuzu[n]=某个数值;        



​        地址值        



​             数组的各个变量    初始值为0        



 

栈（Stack）：

​        new int[n];        



​                   堆（Heap）：  



方法区（Method Area）：     

​        Public static void main(String[] args)        







以上是一个数组在内存中的运行过程。

 

数组异常情况：

1、 索引错误【不能使用不存在的数组项】

2、 空指针异常【所有的引用型变量都可以赋值为一个null值，但是其中什么都没有。数组没有进行new初始化的化，会导致空指针异常】

 

获取数组长度：格式：数组名称.length

 

遍历数组：对数组中的每一个数组进行逐一、挨个进行处理。默认的处理方式就是打印输出。

 

 

### 面向对象：

面向过程：（强调步骤）实现一个功能时，每一个具体步骤都是亲力亲为，详细处理每个细节

面向对象：（强调对象）实现一个功能时，不关心具体步骤，而是寻找一个具有该功能的来完成功能

面向对象的特点：面向对象思想是一种更符合我们思考习惯的思想，它可以使复杂的事情简单化，并将我们从执行者变为指挥者，面向对象的语言中，包含三大基本特征，即封装、继承和多态。、

 

 

类和对象：

  类：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物

  属性：该事物的状态信息(你是啥)

  行为：某种动作(你能用来干嘛)

  对象：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性和行为

现实中一类事物的一个实例：一只凯露（属性：黑猫，xx岁，xxkg等。行为：走，跑等）

  类和对象的关系：

​    类是对一类事物的描述，是抽象的，对象是一类事物的实例，是具体的。类是对象的模板，对象是类的实体。类的实体化就叫做创建。

 

类的定义：

Java中用class描述事物

   成员变量：对应事物的属性

   成员方法：对应事物的行为

类的定义格式：

public class ClassName{

成员变量

成员方法

}

定义类：就是定义类的成员，包括成员变量和成员方法。

​    成员变量：同定义变量，只是位置改变了，在类中，方法外

​    成员方法：同定义方法，只是要把static去掉。

通常情况下，类并不能单独的使用，需要根据类创建一个对象才能使用

创建一个对象的步骤:

\1. 导包

指出需要使用的类在什么位置

import 包名称.类名称

```
import cn.itcast. cn.qj17687313829.demofile
```

对于和当前类属于同一个包的时候，可以省略导包语句

\2. 创建

类名称 对象名 = new 类名称（）；

\3. 使用（分为两个情况）

使用成员变量：对象名.成员变量名   当类中没有对变量进行赋值时，变量会有默认值，规则同数组。可以在对像中对类中的变量进行赋值操作

使用成员方法：对象名.成员方法名（参数）

 

对象的内存图：

 

​                                                            

 

 

 

 

 

 

 

 

 

 

 

 

 

 



对象类型可以作为方法的参数

```
如：public static void way(lei stu3){}
```

Stu3是一个对象

类型是lei

参数是stu3

当一个对象作为参数传递到方法当中时，传递的是对象的地址值。

 

对象类型还可以作为方法的返回值

当使用对象类型作为方法的返回值时，返回值是对象的地址

public static lei way1(){
   lei two = new lei();
   two.name = "nmsl";
   two.eat("撒币");
   return two;
 }

 

 

成员变量和局部变量的区别：

\1. 定义的位置不同 局部变量在方法内部定义，成员变量在方法外部定义，写在类当中。

\2. 作用范围不同  局部变量只能在方法中使用，成员变量整个类是通用的

\3. 默认值不一样  局部变量没有默认值（方法的参数是局部变量），必须要赋值，成员变量会自动赋予默认值

\4. 内存位置不一样  局部变量在栈内存，成员变量在堆内存

\5. 生命周期不一样  局部变量随方法进栈诞生，方法出栈就消失，成员变量在对象创建时出现，对象被回收则消失

private关键字：用来确保变量的安全。写在想要保护的成员变量的类型前，这样之后这个成员变量就不能被直接访问了（对象.成员变量），只能进行间接访问

对被保护的变量进行间接访问,就是定义一对getter和setter方法,有了方法就可以使用代码对变量进行控制。
 对与setter方法来说，命名规则为：setX(大写字母)xx..，且该方法不能含有参数，返回值还要与成员变量对应。
 对于getter方法来说，命名规则为，getX(大写字母)xx..，且该方法不能含有返回值，参数类型要和成员变量对应。对于布尔值，要写为isXxx

 

this关键字：用来区分与成员变量同名的局部变量。当方法的局部变量和类的成员变量重名时，根据就近原则，优先使用局部变量。如果需要访问本类中的成员变量，需要使用格式：this.成员变量名来区分

 

面向对象的封装性：

  封装性在java中的体现：方法是一种封装，关键字（private）也是一种封装

相当于将一个功能给打包，可以随时调用来使用

 

 

构造方法：专门用来创建对象的方法，比如我们用new来创建对象时，就是在调用构造方法。格式：public 类名称（参数类型 参数名称）{
 方法体
 }
 注意：构造方法的名称必须与所在的类名称完全一样
   构造方法不要写返回值类型，void也不写。
   构造方法不能return一个具体的返回值，即不能产生返回值
   如果没有编写构造方法，编译器会自动生成一个没有参数，没有方法体的构造方法
   一旦编写了一个构造方法，编译器就不会自动生成其它的构造方法了
   构造方法可以重载，即方法名称相同，但参数列表不同

 

标准类：一个标准类，通常由四个组成部分组成

​    1：所有的成员变量都要使用private关键字修饰

​    2：为每一个成员变量编写getter和setter方法

​    3：编写一个无参的构造方法

​    4：编写一个全参的构造方法

一个标准类也叫JAVA BEAN

API：Application Programming Interface。应用程序接口，JAVA API就是JAVA字典，是JDK提供的类的说明文档。

Sacnnerd类的使用：从键盘输入数据。（该类不在lang包下，必须要导包（import.java.util.Scanner））

引用类型的一般使用步骤：

1：导包  导包语句：import 包路径，类名称；

目标类和当前类位于同一个包下可以省略导包语句

Java.lang包下的内容不需要导包

2：创建  即创建对象语句：类名称 对象名 = new 类名称；

3：调用  对象名.成员方法名（）；

获取从键盘输入的一个int数字：int num = sc.nextInt();

获取从键盘输入的一个字符串：String str = sc.next();

 

匿名对象的创建：new 类名称();

使用：new 类名称().成员变量

匿名对象只能使用一次，再new的话就是新对象了。

匿名对象作为方法的参数和返回值：

  public static void st(Scanner sc){//匿名对象作为方法参数
   int num = sc.nextInt();
   System.*out*.println(num);
 }
 public static Scanner sm(){//匿名对象作为方法返回值
   return new Scanner(System.*in*);
 }

Random类：随机生成一个数字

​      1：导包   import java.util.Random

​     2: 创建   Random 对象名 = new Random();

​     3：调用   获取随机的int数，范围是int所有范围，包含正负 ：int num = 对象名.nexInt();

​           生成范围内的数字，参数代表了范围，为左闭右开区间：

​                     int num = 对象名.nexInt(参数)；

​                   范围为m到n：

​                 int sum = 对象名.nextInt(m)+N;

 

对象数组： 格式：  类名[] 对象名 = new 类名[数组长度]；

数组有一个缺点：创建好的数组，程序运行期间数组长度不可改变，为了解决这个问题，我们会使用ArrayList类

 

ArrayList集合类：与数组不同，ArrayList集合的长度是可以变化的。

API中的类有时候后面会有一个<>,这个括号里面是类里面的东西都是什么类型，即泛型，以大写字母表示。泛型只能是引用类型，不能是基本类型。

格式： ArrayList<泛型> 对象名 = new ArrayList<泛型>；JDK1.7版本以上的右侧<>可以不写泛型内容，<>符号要写。

向ArrayList集合中添加数据需要用到add方法。格式：

对象名.add(数据内容);

ArrayList的常用方法：

添加：add方法 public Boolean add(E e);向集合中添加元素，参数类型与泛型一致

​       public E get (int index);从集合中获取元素，参数是索引编号，返回值就是对应位置的元素

​      public E remove(int index);从集合中删除元素，参数是索引编号，返回值就是被删除的元素

​      public int size();获取集合的长度，返回值是集合中包含元素的个数。

对于ArrayList集合来说，add添加是一定成功的，返回值可以用也可以不用，但是对于其它的集合来说，add不一定成功。

//如果想要在集合里放基本类型，必须使用基本类型对应的类（包装类）
 //包装类是引用类型，且都在lang包下，一半都是基本类型的首字母大写
 //特殊情况char的包装类:Character  int的包装类: Integer

 

//从JDK1.5开始，支持自动开箱自动装箱
 //自动装箱：基本类型转化为包装类型
 //自动拆箱：包装类型转化为基本类型

 

### 字符串概述及其特点：

程序当中所有用双引号引起来的值都属于String类的对象。

特点：字符串内容不可变

   字符串可以共享使用，

   字符串效果上相当于char[]字符数组，底层原理是byte[]字节数组

字符串的构造方法（3种构造方法，1种直接创建）：

public String()创建一个空白字符串，不含任何内容

public Stirng(char[] array),根据字符数组的内容创建对应字符串

public String(byte[] array),根据字节数组的内容创建对应字符串

String 变量名 = “字符串内容”，直接创建字符串

  

字符串常量池：

程序中直接用双引号创建的字符串会保存在字符串常量池中。

对于基本类型来说，==是数值的比较

对于引用类型来说，==是地址值的比较

字符串比较的相关方法：

如果需要比较字符串的内容，可以使用两个方法：

1：public boolean equals(Object obj);参数可以是任何对象，只有参数是一个字符串并且内容相同的才会返回ture，不然就会返回false。注意：任何对象都可以用Object进行接收。

equals()方法的特点：对称性：a.equals(b)等效于b.equals(a),如果比较的两个量一个是变量一个是常量，推荐将常量放在前面，避免出现空指针异常。

2：public boolean equalsIgnoreCase(String str);忽略大小写，进行内容比较。括号里面只接受字符串，即括号里要放一个字符串常量。

字符串获取的相关方法：

1：public int Length();获取字符串中含有的字符个数，拿到字符串的长度。

2：public Stirng concat(String str);将当前字符串和参数字符串拼接成为返回值，返回一个新的字符串。

3：public char charAt(int index);获取指定索引位置的单个字符。索引从0开始

4：public int indexOf(String str);查找参数字符串在本字符串当中首次出现的索引位置，如果没找到就会返回-1

字符串的截取方法：

1：public Sting substring(int index);截取从参数位置一直到字符串末尾，返回一个新的字符惨。

2：public String substring(int begin,int end);截取从begin开始，一直到end结束之间的字符串。返回一个新的字符串。为左闭右开区间。

字符串转换的相关方法：

1：public char[] toCharArray();将当前字符串拆分为字符数组作为返回值。

2：public byte[] getBytes();获取当前字符串底层的字节数组

3：public Stirng replace(CharSequence oldString,CharSequence newString);将所有出现的旧字符串替换成为新的字符串，返回替换之后的结果，即新字符串

字符串分割的相关方法：

  1：public String[] split(String regex);按照参数规则，将字符串切分为若干部分。该参数是一个正则表达式，如果按照英文的”.”来切字符串，要写成”\\.”

 

### static关键字概述：

  只要用了static关键字，内容就不是对象的，而是类的，凡是本类的对象，内容都是一样的。

静态static关键字修饰成员变量：

可以使用 类名称.成员变量 的格式直接使用成员变量

静态static关键字修饰成员方法：

一旦使用了static修饰成员方法，这个方法就会变成静态方法，不属于对象，而是属于类的，此时可以直接用 类名称.成员方法 的格式来调用。没有static的话，必须要先创建对象，才能通过对象使用成员方法。

注意事项：成员方法可以访问成员变量

​     成员方法可以访问静态变量

​     静态方法可以访问静态变量

​     静态方法不能直接访问非静态的变量和方法。原因：内存中是先有了静态内容，后有的非静态内容。

​     静态方法中不可以使用this关键字

​         

静态static关键字会在内存中的方法区创建一个新的区域（静态区），用于储存static修饰的内容。

数组工具类Arrays中的常用方法：

  1：public static String toString(数组);将参数数组变为字符串。

  2：public static void sort(数组);按默认升序对数组元素进行排序

如果数组内容是数值，将按从小到大排序，如果是字符串，将按字母升序，如果是自定义类型，这个自定义的类需要有Comparable或Comparator接口的支持。

 

数学工具类Math中的常用方法：

  1：public static double abs(double num);获取绝对值

  2：public static double ceil(double num);向上取整

  3：public static double floor(double num);向下取整

  4：public static long round(double num);四舍五入

  5：Math.PI 近似的圆周率

 

 

面向对象的继承性与抽象类：

 继承是多态的前提，没有继承就没有多态。

在程序中，继承主要解决的问题就是 共性抽取。存在继承关系的两个类之间，一个是父类，也称基类或超类，另一个是子类，也称派生类。

继承的特点：子类可以拥有父类的内容，子类可以有自己专有的内容。

继承的格式：（子类就是一个父类，即子类可以看作一个父类）

​     父类的创建：

public class 父类名称{

…} 

​     子类的创建：

​          public class 子类名称 extends 父类名称{

…}

在父子类的继承关系中，如果成员变量重名，则创建子类变量时，访问有两种方式：

1：直接通过子类对象访问成员变量：

等号左边是谁，就优先使用谁，没有就像上找

2：间接通过成员方法访问成员变量

  要看调用的方法是在哪个类中定义的

 

区分子类方法中重名的三种变量（与父类重名的成员变量，与局部变量重名的变量名）

  局部变量：直接写成员变量名

  本类成员变量：this.成员变量名

  父类成员变量：super.成员变量名

 

继承中成员方法的访问特点：

  如果父子类成员方法重名，在调用时，优先使用new对象的那个类的成员方法。

无论是成员方法还是成员变量，如果在当前类找不到，都会向上找，而不会向下找。

 

继承中方法的覆盖重写：

在继承关系中，方法的名称一样，参数列表也一样

重写：关键字 Override,方法名称一样，参数列表也一样，也称方法的覆盖

重载：关键字 Overload,方法名称一样，参数列表不一样

特点：创建的是子类对象，则优先使用子类方法

可以使用@Override来检测方法的重写格式是否正确

注意：1、必须保证父子类间方法名称与参数列表相同

   2、子类方法的返回值必须小于等于父类方法的返回值范围

  前提：Object类是所有类的祖宗类，即父类。

   3、子类方法的权限必须大于等于父类方法的权限（修饰符）

​    public > protected > 啥都不写 > private

使用类的原则：对于已投入使用的类，尽量不要进行修改，推荐定义一个新的类，来重复使用其中共性的内容，并在此基础上添加新功能。

 

继承中构造方法的访问特点：

1、 子类构造方法中有默认的super()，会先调用父类的构造方法，再用子类构造方法。

2、 可以使用super来调用父类的重载方法

3、 super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造。如果是无参构造可以不用写super，如果是有参必须写super，而且必须写在第一行。

super关键字的用法(用来访问父类内容)：

1、 在子类的成员方法中，访问父类的成员变量

2、 在子类的成员方法中，访问父类的成员方法

3、 在子类的构造方法中，访问父类的构造方法

this关键字的用法(用来访问本类内容)：

1、 在本类方法中，访问本类的成员变量

2、 在本类的成员方法中，访问本类的另一个成员方法、

3、 在本类的构造方法中，访问本类的另一个构造方法，this必须是构造方法的第一个语句

注意：super和this不能同时使用

继承的特点：

1、 一个类的直接父类只能有唯一一个。一个父类可以有很多子类。

2、 可以有多级继承关系，最顶层的类是Object类

 

 

 

抽象：

如果父类中的方法不确定实现的是什么功能，那这个方法就是抽象方法

抽象方法和抽象类的定义格式：

抽象方法：在public后加上abstract关键字，去掉{}，直接用分号结束

抽象类：抽象方法所在的类必须是抽象类，抽象类格式就在class前加上abstract关键字。

抽象类和抽象方法的使用：

1、 不能直接new抽象类对象

2、 必须用一个子类来继承抽象父类

3、 子类必须覆盖重写抽象父类中的所有抽象方法

 

抽象类和抽象方法使用的注意事项：

1、 抽象类不能创建对象

2、 抽象类中可以有构造方法，是供子类创建对象时初始化父类成员使用的

3、 抽象类中，不一定含有抽象方法，但是有抽象方法的类必定是抽象类

4、 抽象类的子类必须重写抽象父类中所有的抽象方法，否则会报错，除非该子类也是抽象类

 

接口：

   接口就是一种公共的规范标准，只要符合规范标准，大家就可以通用。

   接口是一种引用类型。它是多个类的公共规范。

接口的定义格式：

   public interface 接口名称{

​     接口内容

}

​    接口内容里可以有：常量，抽象方法，默认方法，静态方法，私有方法

接口的抽象方法定义：

   public abstract 返回值类型 方法名称(参数列表);

注意：接口中的抽象方法，修饰符必须是两个固定的关键字：public abstract

   并且这两个关键字是可以省略的 ，省略多少个都行

   方法的三要素可以随意定义

接口使用的步骤：

1、 接口不可以直接使用，必须有一个实现类才能使用。

实现类的格式：public class 实现类名称 implements 接口名称{

  实现类的内容

}

2、 接口的实现类必须覆盖重写接口中所有的抽象方法

3、 创建实现类的对象进行使用

如果实现类没有重写接口中的所有抽象方法，那么这个实现类必须是一个抽象类。

 

接口的默认方法定义：

public default 返回值类型 方法名称(参数列表){方法体}

接口中的默认方法，可以解决接口升级的问题。接口升级：当实现类正在运行时，接口增加了抽象方法。将新添加的方法改为默认方法就可以不用更改实现类。

接口的静态方法定义：接口可以定义静态static方法

  格式：public static 返回值类型 方法名称(参数列表){方法体}

接口静态方法的使用：接口名称.静态方法名(参数列表);

  不能通过接口的实现类调用接口静态方法。

接口私有方法的定义：需要一个私有方法，用来解决两个默认方法间的重复代码的问题。这个私有方法不能让实现类使用。

  普通私有方法 格式：private 返回值类型 方法名称(参数列表){方法体}

静态私有方法 格式：private static 返回值类型 方法名称(参数列表){方法体}

普通私有方法是解决多个默认方法间重复代码的问题

静态私有方法是解决多个静态方法间重复代码的问题

 

接口的常量定义与使用；

接口中也可以定义成员变量，但是必须使用public static final三个关键字修饰，从效果上看，这是接口的常量。

格式：public static final 数据类型 常量名称 = 数据 ； 

一旦使用final关键字修饰，则数据不可改变

三个关键字也可以省略

接口常量必须赋值，接口常量的命名最好使用纯大写以及下划线组合

 

注意：接口没有静态方法块和构造方法

   一个类的父类有且只有一个，但一个类可以同时实现很多接口。

   格式：public class 接口 implments 接口1，接口2{覆盖重写所有抽象方法}

   如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要覆盖重写一次

   如果实现类没有覆盖重写所有接口中的所有抽象方法，那这个实现类必须是一个抽象类

   如果实现类中实现的多个接口中存在重复的默认方法，必须对重复的默认方法进行覆盖重写

   一个类如果直接父类中方法与接口中的默认方法产生了冲突，优先使用父类中的方法

 

接口之间的多继承：

类与类之间是单继承的，直接父类只有一个

类与接口之间是多实现的，一个类可以有多个接口

接口与接口之间是多继承的

注意：多个父接口中的抽象方法可以重复

   多个父接口中的默认方法不可重复，如果重复了，子接口必须进行默认方法的覆盖重写，并且必须带着default关键字

 

 

 

 

面向对象的多态性：

类的继承extends与接口的继承implements是多态性的前提

一个对象拥有多种形态，这就是对象的多态性

 

多态的格式和使用：

格式：体现对象多态性

父类名称 对象名 = new 子类名称();

   接口名称 对象名 = new 实现类名称();

多态中成员变量与成员方法的使用特点：

成员变量：

直接通过对象名访问成员变量：看等号左边是谁就优先用谁，没有向上找

间接通过成员方法访问成员变量：看该方法属于谁优先用谁，没有向上找

(编译看左边，运行还是看左边)

成员方法：

new的是谁，就优先使用谁的方法，没有就向上找

(编译看左边，如果左边的类里没有相应方法，会报错。运行看右边)

 

对象的向上转型：

其实就是多态写法：父类名 对象名 = new 子类名();向上转型一定是安全的

从小范围转向大范围，即从小范围向上转换为更大范围的类。

弊端：一旦向上转型为父类，就不能调用子类原本的方法

解决方法：用向下转型还原

对象的向下转型：是一个还原的动作

格式：子类名 对象名 = (子类名)父类对象；

即将父类对象还原为原来的子类对象

instanceof关键字：

格式： 对象名 instanceof 类名称

这个关键字可以判断前面的对象能不能当作后面类的实例(对象)

一半用在方法里面。

 

final关键字的用法：

   代表最终的，不可改变的。

   对于基本类型来说：不可变意味着变量中的数据不可修改

   对于引用类型来说：不可变意味着变量中的地址值不可修改

1、 可以修饰类 ：

格式： public final class 类名称{}，即定义类的时候在class前加上final.

含义：这个类不能有任何子类。其中的成员方法不能被覆盖重写

2、 可以修饰方法：

格式： public final 返回值类型 方法名(参数列表){方法体}，

含义：这个方法不可以被覆盖重写

final关键字与abstract关键字是不可以同时使用的

3、 可以修饰局部变量：
 格式： final 变量类型 变量名 = 数据；

​    final 类名称 对象名 = new 类名称()；

含义： 赋值后的变量不可改变，只可以赋值一次，赋值后该变量就不可再改变了,对于对象来说，其地址不可改变。

4、 可以修饰成员变量：

格式：在类中 public final 变量类型 变量名 = 数据；

用了final关键字后，变量只能赋值一次后不可再改变，对于被final的成员变量，必须进行手动赋值。可以使用直接赋值或者构造方法赋值。

 

四种权限修饰符：从大到小：

   public, protected, default(不用写), private

同一个类： 都可以对被这些修饰符修饰的变量和方法进行访问

同一个包： 除了private修饰的东西都可以进行访问

不同包子类：public,protected权限的东西可以进行访问

不同包非子类：除public修饰的东西可以访问，其它的都不行

 

内部类：

如果一个类的内部包含另一个类，里面的类就是内部类，即两个类是包含关系，内部类不能脱离包含它的类存在。

 

分类：

1、 成员内部类

定义格式：

   修饰符 class 类名{

修饰符 class 内部类名{}

}

​    内部类可以随意使用外部类的成员变量和方法

​    外部类必须借助内部类对象来访问内部类的成员变量和方法

使用成员内部类：

通过外部类对象调用外部类的方法再间接使用内部类的东西

直接访问：外部类名称 内部类名称 对象名 = new 外部类名称().new 内部名称();

内部类的同名访问：

  内部类要访问重名的外部类变量，可以使用：外部类.this.变量名

2、 局部内部类(包含匿名内部类)
 如果一个类是定义在一个方法内部的，那这个类就是一个局部内部类。

即只有这个方法里面能使用这个类

定义格式：修饰符 class 类名{

​        修饰符 class 返回值类型 外部类方法名(参数列表){

class 局部内部类名{}

}

}

​    局部内部类中的final的使用：

​      局部内部类中如果要访问所在方法的局部变量，那这个局部变量必须是有效final的，即要访问的变量是只赋值过一次且没有被改变的

匿名内部类：

  用的最多，很常用

 

定义类的时候，权限修饰符的规则：

1、 外部类：public或者不写

2、 成员内部了：四个都可以写

3、 局部内部类：不能写

当接口的实现类（或是父类的子类）只需要使用一次，这种情况下就可以省略该类的定义，改为使用匿名内部类

  格式：接口名 对象名 = new 接口名(){覆盖重写的所有抽象方法};

后面的分号记得写

 

使用匿名内部类的注意事项：

匿名内部类在创建对象时只能使用一次，即只能new一次对象。如果还要new的话，大括号内容就必须重写。

匿名内部类的格式去掉前面的部分，只写new的部分，就是匿名内部类的匿名对象的写法，匿名对象在调用方法的时候，只能调用一次，想要同一对象调用多次方法就必须要写对象名。

 

类可以作为成员变量的类型

接口也可以作为成员变量的类型

接口还可以作为方法的类型和返回值

 

 

异常的处理：

捕获异常并对异常进行操作可用try catch

try{异常语句}catch{。。。}{对异常进行的操作}；

#       

### 多线程：

 进程：应用程序在内存中分配的空间，即正在运行中的程序

 线程：也称执行单元，执行路径，即进程中负责程序执行的单元。

 一个进程中至少有一个线程在负责该进程的运行，如果一个进程中出现了多个线程，就称该程序为多线程程序

 多线程技术原理：解决多部分代码同时执行的需求，因为CPU同一时间只能同时处理一个进程，多线程可能会使效率降低，但是可以增加空间的利用率。

 线程的基本组成部分：CPU时间片：系统给每个线程分配执行的时间

​           运行数据：包含栈空间和堆空间，堆是用来放线程需要使用的对象的，多个线程可以共享堆中的对象。栈是放线程需要使用的局部变量的，每个线程拥有独立的栈。

​            线程的逻辑代码

 

线程的特点：

1、 线程抢占式执行：效率高，可防止单一线程长时间独占CPU

2、 在单核CPU中，宏观上同时执行，微观上顺序执行 

 

创建线程的三种方式：

 1：继承Thread类，重写run方法

创建一个继承Thread类的类，将run方法覆盖重写

在mian方法中创建子类对象，即子线程，调用start()方法

在这个过程中不能调用对象中的方法，必须要用start()方法，不然就不是多线程了，而是直接使用普通对象的成员方法

当使用同一个类作为子线程时，需要区分线程

获取和修改线程名称的方法：

 获取线程ID和线程名称：1、在Thread的子类中调用this.getId()或this.getName。 该方法必须继承Thread类

​             2、使用Thread.currentThread().getName()

修改线程名称（线程的id是不可以修改的）：

1、调用线程对象的setName()方法

​       2、使用线程子类的构造方法赋值

 2：实现Runnable接口

添加一个Runnable接口，重写抽样方法(run方法)，创建实现类对象，创建线程对象，调用start()方法。如：

class MyRunnable implements Runnable{ public void run(){…} }  [实现Runnable接口并重写rn方法]

在mian里面：myRunnable mr = new MyRunnable(); [创建实现类对象，线程要执行的功能]

​       Thread t = new Thread(mr);  [创建线程对象]

​       t.start();   [调用start()方法启动线程]

 3：实现Callable接口：

 

线程的状态：New完后为初始状态，只在堆中开辟了内存，与一般的类并无区别。调用了start()方法后，线程进入就绪状态，等待OS选中，并分配时间片，此时为就绪状态。OS选中后进入运行状态，时间片到期后回到就绪状态。main结束后线程进入终止状态，释放内存。在运行时可以加入限期等待状态(使用sleep()方法)，和无时间等待状态(使用join()方法)。

 

 线程休眠方法：public static void sleep(long millis),该方法可让当前线程主动休眠millis毫秒

 当前线程主动放弃时间片回到就绪状态，竞争下一时间片的方法：public static void yield()。

 线程加入：public final void join()。将线程加入到当前运行的线程中，并阻塞当前线程，直到加入的线程执行完成后当前线程才会继续执行。

 设置线程优先级：使用线程对象的setPriority()方法，线程优先级为1到10，默认为5。

 守护线程：使用线程对象的setDaemon(true)方法将线程设置为守护线程。线程有两类，即用户线程（前台线程）和守护线程（后台线程），默认条件下线程为前台线程。当程序中的前后台线程都执行完毕后，后台线程会自动结束运行。垃圾回收器线程属于守护线程。设置守护线程时要在启动线程之前。

 

 线程安全：当多线程并发访问临界资源(共享资源)，如果破坏原子操作(不可分割的多步操作，视作一个整体操作，其顺序和步骤不可打乱或缺失)，可能会导致数据不一致 。

 保证线程的安全性：使用java的同步机制。

   同步代码块：

​      语法：synchronized(临界资源对象){原代码},该方法可以对临界对象上锁，可以实现在同一时刻只有一个线程使用临界资源。

###  JUC

JUC就是java.util.concurrent包,它是一个java提供的并发相关的包.

**线程是一个单独的资源类,它没有任何附属的操作!**

我们一般使用多线程的时候,使用Callable接口比较多,Thread类和Runnable接口其实用的不多,因为它们跟Callable相比不够好用.而这个Callable就是一个在JUC包下的一个接口.

线程和进程: 进程是一个程序的抽象,它是CPU进行资源调度的基本单位,它可以包含多个线程,线程是CPU任务调度的基本单位.

一般来说,Java是没办法开线程的,线程这个东西是由操作系统进行开辟的.

并发与并行: 并发是指一个核心去完成多个任务,而并行是多个核心来完成多个任务.

并发也就是通过快速切换任务执行来模拟并行操作的.而并行是真正的多线程,它每一个任务可以有不同的核心来进行处理.

我们可以通过Java的一个类来查看一些运行时的东西.

```Java
Runtime.getRuntime().availableProcessors();//这个Runtime类的这个方法可以查看CPU核心数
```

并发编程的本质: 为了充分利用CPU资源,就是为了节省资源的.

我们对于资源的操作分为两种:

* CPU密集型: 也叫计算密集型,指的是内存性能与系统硬盘比起CPU来说要好的多,这个时候CPU处于加载状态,CPU去读IO,IO可以很快完成,但CPU这时可能还没计算完,就说这个时候CPU还在加载,此时CPU的占用率非常高,也就是说,我们的操作在这个时候是CPU密集型的.一般就是一些计算操作.这类操作需求高效率,就需要使用C/C++这类语言保证计算效率.

* IO密集型:与CPU密集型操作相反,这时候CPU性能比内存等性能好,计算速度很快,大部分事件是CPU在等待IO的读写操作.一般就是一些涉及到网络,硬盘读写的操作.对于这类操作,我们可以使用解释型语言来进行开发,可以保证开发效率.

#### 回顾线程

线程状态:在State类里面,提供了线程的状态.它是一个枚举类.里面表明线程有6种状态:

* NEW : 创建线程

* RUNNABLE: 运行态

* BLOCKED: 阻塞态

  * 使线程阻塞我们一般有sleep和wait.它俩的区别

    ```Java
    1.sleep()是Thread类的方法,wait()是Object类里的方法
    2.sleep()需要捕获异常,它可能会有一个超时等待的问题,wait()就不用,而所有的线程都有个中断异常.
    3.sleep()可以随便用,而wait()是用在同步块里的
    4.sleep()阻塞时不会释放锁,wait()会
    ```

    

* WAITING: 等待态

* TIMED_WAITING: 超时等待

* TERMINATED: 终结态

#### 锁

线程之间的通信问题:生产者与消费者问题

```java
//有俩线程:A,B,他俩要操作同一个变量num,如果没有一种操作,它俩是独立的,就需要一个等待唤醒和通知唤醒操作来进行线程的通信
//整体的操作就是:判断是否等待,业务,通知其他线程
public class A{
    public static void main(String[] args){
        Data data = new Data();
        //多个线程对data操作啥的
        new Thread(()->{for(int i = 0;i < 10; i++)data.increment();}).start();
        new Thread(()->{for(int i = 0;i < 10; i++)data.decrement();}).start();
    }
}
//问题:当线程数更多的时候,上面的结果就不一定对了.因为我们使用的是if判断,它只会判断一次,就会导致在线程切换的时候,

class Data{
    private int num = 0;
    //使用老式锁
    public synchronized void increment(){
        while(num != 0){//我们应该使用while判断!以防止虚假唤醒!
            //要不要等待?
            this.wait();
        }       
        num++;
        //通知其他线程我加完了.
        this.notify();//还可以改成notifyAll(),这样可以有效防止线程死锁问题.如果在多个生产者与多个消费者的情况下,notify是只会随机唤醒一个正在等待的线程,这个时候也可能会导致唤醒的线程不对,
    }
    public synchronized void decrement(){
        while(num == 0){//if只会判断一次,会导致线程被虚假唤醒,本来是不应该唤醒的,因为被唤醒后线程将会从阻塞的地方继续往下走,就会直接++或者走--,就不会进行判断了,就会出现错误的结果.
            //要不要等
            this.wait();
        }
        num--;
        //通知其他线程说我减完了.
        this.notify();
    }
}
```

用Lock锁来实现生产者消费者问题

```Java
//老式的实现生产者消费者问题我们用的是synchronized与wait以及notify,使用Lock锁的话我们需要使用的是Lock与Condition,Lock锁与Condition就是代替老式的东西
public class A{
    public static void main(String[] args){
        Data data = new Data();
        //多个线程对data操作啥的
        new Thread(()->{for(int i = 0;i < 10; i++)data.increment();}).start();
        new Thread(()->{for(int i = 0;i < 10; i++)data.decrement();}).start();
    }
}
//问题:当线程数更多的时候,上面的结果就不一定对了.因为我们使用的是if判断,它只会判断一次,就会导致在线程切换的时候,

class Data{
    private int num = 0;
    Lock lock = new ReentrantLock();
    Condition condition = lock.newContition();
    //使用Lock锁
    public void increment(){
        lock.lock();
        try{
        while(num != 0){//我们应该使用while判断!以防止虚假唤醒!
            //要不要等待?
            condition.await();
        }       
        num++;
        //通知其他线程说我加完了.
        condition.signal();
        }catch(Exception e){}
        finally{
            lock.unlock();
        }
    }
    public synchronized void decrement(){
        lock.lock();
        try{
            while(num == 0){//if只会判断一次,会导致线程被虚假唤醒,本来是不应该唤醒的,因为被唤醒后线程将会从阻塞的地方继续往下走,就会直接++或者走--,就不会进行判断了,就会出现错误的结果.
                //要不要等
                condition.await();
            }
            num--;
            //通知其他线程说我减完了.
            condition.signal();
        }catch(){}
        finally{
            lock.unlock();
        }
    }
}
//对于Condition来说,它不仅是wait和notify的替代,它还可以精确通知唤醒指定线程.
//我们可以创建多个Condition,给每个不同的方法一个condition对象来唤醒和等待,就可以实现精确唤醒了.
    
```

锁:

怎么判断锁的是谁:

8锁:(就是关于锁的8个问题)

```Java
public class A{
    public static void mian(String[] args){
        Data data = new Data();
        new Thread(()->{data.senSms();}).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(()->{data.call();}).start();
    }
}
class Data{
    public synchronized void senSms(){
        TimeUnit.SECONDS.sleep(4);
        System.out.println("senSms");
    }
    public synchronized void call(){
        System.out.println("call");
    }
    public void say(){
        System.out.println("say");
    }
}
//问题1:上面的代码会输出啥?
//答:会输出senSms call
//问题2:如果在senSms方法里加上TimeUnit.SECONDS.sleep(4),又会输出啥?
//答:会输出senSms call
//为啥都是先输出senSms呢?其实并不是因为先调用,在多线程的情况下,并不是先调用的就先执行,这里是因为有synchronized锁的存在,这个锁它现在是在方法上的,它会去锁调用这个方法的那个对象.由于这两个方法用的是同一把锁,那么就是谁先拿到这把锁就是谁先执行.
//问题3:如果我们第二个线程调用的是say,会输出啥嘞?
//答:输出say senSms
//问题4:如果我们有两个对象,一个data,一个data1,上面那个线程不变,下面那个线程调用data1的call,又会输出啥嘞
//答:输出call senSms
```



* 传统锁:Synchronized关键字

  * 这个玩意可以修饰方法或者代码块.

  * 实现原理:对于同步方法，JVM采用`ACC_SYNCHRONIZED`标记符来实现同步。 对于同步代码块。JVM采用`monitorenter`、`monitorexit`两个指令来实现同步。

    ```Java
    方法级的同步是隐式的。同步方法的常量池中会有一个ACC_SYNCHRONIZED标志。当某个线程要访问某个方法的时候，会检查是否有ACC_SYNCHRONIZED，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。
    
    同步代码块使用monitorenter和monitorexit两个指令实现。可以把执行monitorenter指令理解为加锁，执行monitorexit理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行monitorenter）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行monitorexit指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。
    
    无论是ACC_SYNCHRONIZED还是monitorenter、monitorexit都是基于Monitor实现的，在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现。
    
    ObjectMonitor类中提供了几个方法，如enter、exit、wait、notify、notifyAll等。sychronized加锁的时候，会调用objectMonitor的enter方法，解锁的时候会调用exit方法。
    ```

    

* Lock锁(juc.lock包下的)

  * 在JUC.Lock包下有三个接口: Condition,Lock,ReadWriteLock.

  * Lock:有三个类实现了这个接口 ReentrantLock(可重入锁),ReentrantReadWriteLock.ReadLock,ReentrantReadWriteLock.WriteLock

  * Lock接口有两个核心的方法: lock()加锁, unlock()解锁.

  * Lock的使用:

    ```Java
    class Ziyuan{
        //这是一个资源类
        private int a;
        Lock lock = new ReentrantLock();
        //对于这个可重入锁,它里面有两个构造函数,无参构造函数会设置sync为一个非公平锁.一个参数为boolean的构造函数会根据输入true选择公平锁,输入false选择非公平锁.
        //在进行资源操作前要进行上锁
        lock.lock();
        try{
            //业务代码
        }catch(Exception e){...}
        finally{
            //操作完成后就要解锁
            lock.unlock();
        }
    }
    //公平锁:十分公平,要先来后到,线程必须排队执行
    //非公平锁:不公平的,可以插队,就是线程可以插队执行
    ```

    

  * Lock与Synchronized的区别:

    * Synchronized是全自动的,没法判断获取锁的状态,Lock是要手动加锁解锁的,并且可以判断是否获取到了锁.
    * Synchronized是关键字,Lock是个接口
    * 当一个线程获得了锁,Synchronized的锁的话,另一个线程就会一直在阻塞,等待锁的释放.而Lock锁的话另一个线程就不一定会等待下去.
    * Synchronized锁是一个不可重入锁,是不可以中断的,而且还是个非公平锁.而Lock锁是可重入锁,可以判断锁,而且可以自己设置锁的类型.
    * Synchronized锁适合锁少的代码同步问题,Lock适合大量锁的代码同步问题.

#### 集合类不安全

我们平时用的ArrayList这样内部方法没带锁的集合,它在单线程下是安全的,但是在并发情况下它就算不安全的.

```Java
public static void mainn(String[] args){
    List<String> list = new ArrayList<String>();
    for(int i = 0; i < 10;i++){
        new Thread(()->{list.add(UUID.randomUUID().toString().subString(0,5));
                       System.out.prinltn(list);
                       },String.valueOf(i)).start();
    }
}
//报异常
```



我们要是去使用多个线程去修改这种集合里面的东西的话,会引发一个异常: ConcurrentModificationException(并发修改异常).

解决的办法:

* 用Vector,但是实际上Verctor这个东西是比ArrayList还古老的东西,最好不用它.
* 用Collections.synchronizedList()把我们的集合变为上锁集合,括号内放入我们的集合对象,它会返回一个安全的集合对象.
* 用JUC包下的CopyOnWriteArrayList类.对比与Vector,Vector使用的是syn锁.而COW的方法使用的不是syn锁,使用的是Lock锁.

CopyOnWrite这个意思是写入时复制,简称COW,它是计算机程序设计领域的一种优化策略.在多个线程调用的时候,对于我们的list,读取的时候是固定的,而写入的时候,会去避免覆盖,防止数据问题.也就是说,它在写入的时候,会复制一份,写入写完后再插入回去.

对于Set来说平时的HashSet(本质是一个HashMap)也是一样的,同样的,也有个叫CopyOnWriteSet的类.

对于Map来说,平时的HashMap也是一个不安全的集合,JUC有个ConcurrentHashMap,

这里扩展以下HashMap,它的默认构造器里有一个加载因子(默认值0.75f),而重载的构造器有个初始化容器(默认大小为16).我们工作里面其实是不会用HashMap这个东西的.

#### Callable

Callable是在JUC包下的一个接口,它类似于Runnable接口,因为他们都是为其实例可能由另一个线程执行的类设计的,然而Runnable不返回结果,也不会抛出被检查的异常.总的来说它就是一个有返回值,可以抛出异常,方法不同的一个Runnable(Runnable用run方法,Callable是用的call方法).

```java
//使用Callable
class ThreadCallable implements Callable<String> {

    @Override
    public String call() throws Exception {
        //call是有返回值的
        return null;
    }
}

```

这有个问题,启动线程的话,有且只有一个方法,那就是Thread对象的start方法.而这个Thread的构造器里都是Runnable接口,那么这个Callable怎么跟Thread搭上关系呢?那肯定就是通过Runnable了.对于Runnable的实现类,它叫FutureTask,这个东西呢,它的构造器里有Callable.我们也就可以这样:

new Thread(new FutureTask(new Callable<>())).start(),这么去启动Callable接口,这个FutureTask类就是一个适配器.FutureTask中的get方法就可以获取Callable的call方法的返回值.但这个get可能会导致阻塞.如果call方法里面是一个耗时的操作,那就会等很久.解决办法就是让他最后执行或者使用异步通信来解决.而且这个地方,call方法的返回值是有缓存的.

常用的辅助类:

CountDownLatch类

它是用来计数的,允许一个或多个等待直到在其他线程中执行的一组操作完成的同步辅助.它里面有个方法,countDowm(),也就是进行一次减计数.

```java
 public static void main(String[] args) throws InterruptedException {
      //CountDownLatch的使用
      CountDownLatch countDownLatch = new CountDownLatch(6);
      for (int i = 0; i < 10; i++) {
          new Thread(new FutureTask<String>(new Callable<String>() {
              @Override
              public String call() throws Exception {
                  countDownLatch.countDown();//数量-1
                  System.out.println(Thread.currentThread().getName() + "call!");
                  return " ";
              }
          }));
      }
      countDownLatch.await();//等待计数器归零,然后才继续向下执行.
      System.out.println("Run");
  }
}
//就比如说我们想要先执行完上面那10条线程后才执行输出Run,就可以使用这个countdownlatch类.
```



CyclicBarrier类

它也是一个计数器.允许一组线程全部等待彼此达到共同屏障点的同步辅助.

```java
  public static void main(String[] args) throws InterruptedException {
      CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->{
          System.out.println("起飞咯");
      });//第一个参数是计数值.也就是要进行多少次计数才执行后面的回调方法.
    for (int i = 0; i < 7; i++) {
        int finalI = i;
        new Thread(()->{
            System.out.println(Thread.currentThread().getName() + "集合"+ finalI);
            try {
                cyclicBarrier.await();//等待,只有执行到了第7个线程才会去执行回调方法.
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();
    }
  }
```



Semaphore

信号量.我们主要用它来做限流.

```java
  public static void main(String[] args) throws InterruptedException {
      Semaphore semaphore = new Semaphore(3);//构造里的是线程的数量
    for (int i = 0; i < 6; i++) {
        //模拟6个车抢3个停车位.
        //信号量就相当于信号量.只有获取这个信号量的才能走.我们设置的是3个信号量.也就是可以同时跑3个线程,其他线程要等这三个释放信号量并得到信号量才能跑
      new Thread(
              () -> {
                try {
                  semaphore.acquire();//获得信号量
                  System.out.println("get"+Thread.currentThread().getName() + "车位");
                  Thread.sleep(2);
                  System.out.println("离开");
                } catch (InterruptedException e) {
                  e.printStackTrace();
                }
                semaphore.release();//释放信号量.
              })
          .start();
    }
  }
}
```

原理:

acquire方法: 获取信号量-1,如果信号量数量已经达到设置的量,就要进行等待,等待信号量的释放,阻塞为获取信号量的线程
release方法: 释放当前的信号量,会将当前当前的信号量释放+1,唤醒等待的线程

#### 读写锁

JUC包下的ReadWriteLock接口.它只有一个实现类:ReentrantReadWriteLock可重入读写锁.

ReadWriteLock维护一对关联的locks,一个用于只读操作,一个用于写入,read lock可以由多个读线程同时进行.而write lock同时只能由一个线程获取来进行写操作.

```java
//我们自己整的一个缓存类
class MyCacheLock{
    private ReadWriteLock lock = new ReentrantReadWriteLock();//创建一个读写锁,它比Lock粒度更细.
    protected volatile Map<String,Object> map = new HashMap<>();

    //存数据,写操作
    public void put(String key,Object value){
        try{
            lock.writeLock();//加个写锁
            System.out.println(Thread.currentThread().getName() + "写入开始");
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + "写入完毕");
        }finally {
            lock.writeLock().unlock();
        }
    }
    //拿数据,读操作
    public Object get(String key){
        try {
            lock.readLock();//加个读锁
            System.out.println(Thread.currentThread().getName() + "读开始");
            return map.get(key);
        }finally{
            lock.readLock().unlock();
        }

    }

    //我们如果想要线程安全的话,如果加syn锁,那么读写效率都会很低,而一般读可以由多个线程读,写只能一个线程写.这个时候就可以用
    //读写锁
}

```

对于读写锁,有三个状态

* 读-读: 可以多个线程同时进行
* 读-写: 不可以共存
* 写-写: 更不可能共存

平时我们说的独占锁,排他锁就是我们的写锁,而共享锁也就是读锁.

#### 阻塞队列

BlockingQueue.

BlockingDeque.

有一个队列,里面都是要执行的任务,我们有两个操作:读和写.队列里面的任务我们看作是一个个线程,我们的读和写也视作线程.队列里面都是这俩操作的集合.我们在加入读和写的时候,有以下情况会导致阻塞:

不得不阻塞的情况:

* 当队列满了,那么写操作就会阻塞.(没满的时候就是一个写任务加入队列)
* 当队列是空的,那么读操作就会阻塞.(队列不是空的话,就执行写任务,然后读操作拿取写入的数据.)

阻塞队列相关的接口: BlockingQueue, BlockingDeque(双端阻塞队列).

双端队列的话就是可以从队列的两边去取东西.

##### 队列

在学习阻塞队列前,我们先要会用队列

对于队列来说,它只是个先进先出(FIFO)的数据结构,也就是说,我们用它也就是对于数据元素的增删改查而已.

但是具体来说,队列有4种情况对应的4种API:

* 可抛出异常
* 不可抛出异常
* 阻塞等待
* 超时等待

##### BlockingQueue

它是一个阻塞队列的接口,它继承的接口有: Collection<E>,Iterable<E>,Queue<E>.

它的常用实现类: ArrayBlockingQueue,SynchronousQueue(同步队列),LinkedBlockQueue.

它跟List,Set两个接口一样,爹都是Collection,它也是属于集合框架的一员.不过它的爹还有一个,就是Queue接口,这个Queue接口才是真正与List,Set他俩平级的接口.

在Queue的实现类中,有个叫AbstractQueue,它表示非阻塞队列.跟阻塞队列是反过来的,而且它还是一个优先队列.

我们啥时候会去使用阻塞队列呢?

* 多线程并发处理的时候
* 在线程池里

BlockingQueue中的队列操作

BlockingQueue<String> bq = new BlockingQueue<>(队列长度);

| 队列操作   | 抛异常                                | 不可抛异常(有返回值)                       | 阻塞等待                                                     | 超时等待                                                     |
| ---------- | ------------------------------------- | ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 添加       | bq.add():当队列满的时候抛异常         | bq.offer()存成功了就返回true,不成功就false | bq.put(),存元素,如果满了,就一直阻塞,等着元素被拿出来.        | bq.offer(元素,阻塞值,阻塞值的单位),存元素,如果队列满了,就等一定的时间,如果超时还放不进去就放弃 |
| 删除       | bq.remove()当队列为空就抛异常         | bq.poll()拿成功了就返回值,队列空了就null   | bq.take()拿取元素,如果队列是空的,就一直阻塞,等着有元素放进来 | bq.poll(跟上面一样),取元素,如果队列空了.就等一定时间,如果超时了都没拿到东西,就放弃. |
| 检查(判断) | bq.element()查看队首元素,空队列抛异常 | bq.peek()查看队首元素,空队列返回null       | -                                                            | -                                                            |

#### 同步队列

SynchronousQueue同步队列是阻塞队列接口的一个实现类.

同步队列没有容量,也就是说,进去一个元素后,必须等待取出来后,才能放另一个元素.相当于最大容量是1个.

与其他的BlockingQueue的实现类不一样,它不存储元素,只要给它一个东西,就必须要把这个东西拿掉才能给另一个给它.

#### 线程池

这个是重中之重.

池化技术 : 

程序的运行,本质上是占用系统资源.而我们程序员做的,就是优化资源的使用.池化技术也是为了做这个而出现的.我们常见的使用池化技术的东西: JDBC连接池,线程池,内存池,对象池......

池化技术通俗了说,就是事先准备了资源,等待其他人去使用,使用完毕后再还回来.为啥要有池化技术嘞?就好比线程池吧,我们平时如果是手动去开辟线程的话是要new这个Thread对象的,new这个操作本身是占用系统资源的,而且执行完后线程会销毁,也是要占用系统资源的,当开辟很多个线程的时候,这两个操作会占用大量的系统资源,甚至超过线程本身执行的内容.而线程池,就事先创建好了一定数量的线程供我们使用,我们不需要去进行new和销毁,这样就大大降低了系统的资源开销,

线程池的好处:

* 降低系统资源的消耗
* 提高系统响应速度
* 方便线程管理
* 线程可复用
* 可以控制最大并发数

线程池必会内容: 三大方法,七大参数,四大拒绝策略

在说这些之前,先来说一些注意事项:

* 线程池最好别用Executors去创建,应该用ThreadPoolExecutor去创建,这也处理的方式可以避免资源耗尽的风险.为啥这样做的原因有两点:
  * Executors返回的线程池它的FixedThreadPool与SingleThreadPool允许的请求队列长度位Integer.MAX_VALUE,这可能会导致请求大量堆积,导致内存溢出
  * CachedThreadPool与ScheduledThreadPool允许的创建线程数量也是Integer.MAX_VALUE,这可能会导致线程的大量创建,导致内存溢出.
* Executors是一个工具类.三大方法就是它里面的三大方
* 线程池需要关闭.

###### 三大方法:

* Executors.newSingleThreadExecutor() 创建单个线程,它会返回一个ExecutorService对象,通过这个对象的.execute()方法就可以直接去启动线程了,这个方法的参数是一个回调函数.这个对象的.shutdown()方法就可以关闭线程池.
* Executors.newFixedThreadPool(数量) 创建固定线程数量的线程池,它会返回一个ExecutorService对象
* Executors.newCachedThreadPool() 创建一个可伸缩的线程池.它会返回一个ExecutorService对象

###### 七大参数:

对于上面的三大方法,它们有个共性,它们都是返回了一个ThreadPoolExecutor这个对象.所以呢,开启线程池的本质就是使用这个类,这个类里面又有七个参数,这就是我们要直到的七大参数.

* int corePoolSize : 核心线程池容量 , 就是主要处理任务的线程数量
* int maximumPoolSize : 最大线程池容量,当阻塞队列满了,就开始增加线程达到最大值
* long keepAliveTime : 超过多少时间无人使用池就会释放
* TimeUnit unit : 时间单位
* BlockingQueue<Runnable> workQueue : 阻塞队列,用来存任务的,存放未被核心线程处理的任务.
* ThreadFactory threadFactory : 线程工厂
* RejectedExecutionHandler handler : 拒绝策略,当线程池中的线程数达到了设置的最大线程池数量,并且阻塞队列满了,再来的任务就会被拒绝

手动创建一个线程池就是去new ThreadPoolExecutor(七大参数)

###### 四大策略(四个类):

* AbortPolicy : 不处理新加入的任务,并抛出异常
* CallerRunsPolicy : 不处理新加入的任务,并让这个新的任务爬回原来的地方.比如是主线程加进去的,那就让主线程来做
* DiscardOldestPolicy : 尝试与存在时间最长的线程竞争,如果竞争失败,就被丢弃
* DiscardPolicy : 不会处理新加入的任务,不会抛出异常,就是直接丢弃新任务

##### CPU密集型与IO密集型(任务)

 对于线程池的最大线程数，我们要如何判断应该设置成多大好呢？这就得看任务是CPU密集型还是IO密集型了。

所以对于最大线程数来讲，我们有两个策略：

* CPU密集型：按我们的CPU核心数来进行配置，比如我的电脑CPU是12核的，那我就可以设置成12.这样可以保证CPU执行的效率最高

  对于CPU的核数，可以通过Runtime.getRuntime().availableProcessors()来获取。

* IO密集型：如果我们有一些大型复杂的任务，就是那些十分占用IO的线程有多少，我们可以设置大于这些线程数量两倍的数字。

对于这个线程池的最大数量，是优化程序的一种策略。灵活运用可以大大提高程序的执行效率

##### 函数型接口与断定型接口和四大函数型接口

作为新时代的程序老哥，我们至少会这些技能：Lambda表达式，链式编程，函数式接口，Stream流式计算

这里我们先说函数式接口

什么是函数式接口呢?就是那些只有一个方法的接口，并且它的头上有一个@FunctionalInterface注解。

它的作用：简化编程模型，并且在很多的框架底层大量运用

常见的函数式接口：Runnable，Consumer，Function，Predicate，Supplier

四大函数式接口：Consumer，Function，Predicate，Supplier

Function<T,R>：

它里面就只有一个apply方法，它的原型：R apply(T t);对于这个接口，我们可以用它来自定义工具类，而且因为是函数式接口，可以直接用Lambda表达式。

Prdicate<T>:

它里面有个boolean tes(T t)方法，它是做判断的，所以也叫断定型接口。

##### 消费型接口与供给型接口

上面的函数式接口中，Consumer也叫消费型接口，Supplier也叫供给型接口。

Consumer<T>:

它里面的方法：void accept(T t),它只消费东西，没有返回值

Supplier<T>:

它里面的方法：T get(),它只生产东西，不需要什么输入



#### Stream流式计算

Stream流计算是啥嘞？

首先，我们知道我们的计算机系统至始至终都是在存储与计算各自数据。不管在什么时代里，都是这样的。

我们的集合，数据库这些东西是存储东西的。而计算应该交给流来操作。

这里的流并不是我们IO包下的输入输出流，而是JU包下的stream包，这个包里面有很多的接口，它基本就是用来做计算（数据处理）的。

stream包下的典型接口：Stream。我们来看看这个流式计算的经典使用：

```Java
psvm{
    User u1 = new User(1,"a",21);
    User u2 = new User(2,"b",22);
    User u3 = new User(3,"c",23);
    User u4 = new User(4,"d",24);
    //需求：
    /*
    一分钟之内完成下列需求，并且代码不超过一行：
    1.输出编号为偶数的用户
    2.输出年龄大于23的用户
    3.用户名转为大写
    4.用户名字母倒序
    5.只输出一个用户
    */
    List<User> list = Arrays.asList(u1,u2,u3,u4);//集合用作存储
    
    //流计算运用
    list.stream().filter(u->{return u.getId()%2==0；}).filter(u->{return u.getAge()>23;}).map(u->(return u.getName().toUpperCase();)).sorted((uu1,uu2)->{return uu2.compateTo(uu1);}).limit(1).forEach(System.out.println);
    //这个形式就是一个链式编程，且这个Stream接口中的各种方法运用了各种函数式接口，对于函数式接口我们又能用lambda表达式。
}
```

#### ForkJoin

ForkJoin（分支合并）：它出现在JDK1.7中，它用于在并行执行任务时去提高效率，在处理大数据量的时候效率更高。

它的核心思想是分治，也就是把一个大的任务拆成好多好多小任务，这些小任务也可以继续分，小任务处理的结果合并后就是要处理的大任务的结果了。

特点 ： 工作窃取，这个就是比如有两个线程，一个线程执行任务到了一半，但是另一个线程任务执行完了，这时候这个执行完任务的线程回去窃取还没执行结束的那个线程的任务，以此提高工作效率。

ForkJoin内部维护的是双端队列。我们来看个例子

```JAVA
psvm{
    //我们来做个计算任务，从1+到1000000000（大数据量计算）
    //对于这个任务，我们有三种解决方案：
	//1.直接for，很low的一种
   	//2.用ForkJoin
    //3.用Stream并行流
    
    int sum = 0;
    for(int i = 1; i < 100000000;i++){
        sum+=i;
    }//这样写效率非常低，就非常的low
    
    ForkJoinPool fjp = new ForkJoinPool();
    ForkJoinTask<Long> task = new Fork(0L,100000000L);
    ForkJoinTask<Long> exeTask = fjp.execute(task);//提交执行任务
    sum = exeTask.get();//获取结果
    
    //上面我们说过，计算就该交给Stream
    sum = LongStream.rangeClosed(0L,100000000L).parallel().reduce(0,Long::sum);//使用并行流计算（parallel表示开启并行计算）
}

class Fork() extends RecursiveTask<Long>{
    //使用ForkJoin
    //使用ForkJoin的流程：
    /*
    1.构建一个forkjoinpool，要通过它来执行任务
    2.就算任务forkjoinpool.execute(ForkJoinTask<?> task),对于这个ForkJoinTask接口，它有三个实现类，其中有RecursiveAction递归事件类，RecursiveTask递归任务类，事件没有返回值，而任务是有返回值的。而且他俩都是个抽象类
   	3.用作执行任务的类必须继承上面那俩类。
    */
    private long start;
    private long end;
    private long temp = 10000L;
    public Fork(long start,long end){
        this.start = start;
        this.end = end;
    }
    
    @Override
    protected Long compute(){
        if((end-start) > temp){
			Long sum = 0;
            for(Long i = start;i <= end; i++){
                sum += i;
            }
        }else{
            //如果值很大
            long mid = (start+end)/2;//分成两个任务
            Fork task1 = new Fork(start,mid);
            task1.fork();//把任务转载入线程队列
            Fork task2 = new Fork(mid,endl);
            task2.fork();
            return task1.join()+task2.join();//获取结果
            
        }
    }
}
```

ForkJoin只有在处理大数据量的时候会去考虑。



#### 异步回调

Future异步回调，它是对将来可能到来的任务进行建模，我们可以把它理解为服务器端线程之间的异步调用（也就是服务器端的Ajax）。

Future接口的使用：

首先它的实现类中有一个增强类：CompletableFuture<T>

它跟Ajax很像，整个过程就是异步回调，如果执行成功就执行成功回调，失败就执行失败回调。

```java
psvm{
    CompletableFuture<Void> cf = CompletableFuture.runAsync(这里就是要执行的异步任务，可以是Runnable类型的，也可以是Executor类型的);
    cf.get();//阻塞并且获取结果。
    //上面的是不带返回值的任务，如果需要有返回值的话，就需要使用supplyAsync方法，这个方法的参数是一个供给型接口类型的参数。
    /*
    对于成功回调，有这样一个方法
    whenComplete()，它有两个参数，是增强型的消费型接口的两个泛型参数。
    失败回调：
    exception()，它的参数是一个函数型的接口。
    */
}
```





#### JMM

关键字：volatile是Java虚拟机提供的一个轻量级的同步机制

它可以保证数据可见性，而不保证数据操作的原子性，它可以禁止指令重排序。

这个数据可见性又与JMM有关。

JMM：Java Memory Model Java内存模型，它是一个不存在的东西，只是一个概念性的东西。它的模型是这样的：线程执行的时候，想要操作主内存中的东西，它会去把主内存的那个变量拿到复制到自己的工作内存中，操作完成后再把这些变量写回主内存。

对于它，有很多的一些约定：

* JMM的同步的约定：
  * 线程解锁前，必须把共享遍历立刻写回主内存
  * 线程加锁前，必须读取主存中的最新的值到工作内存中
  * 加锁与解锁必须是同一把锁

对于工作内存与主存，它们之间的操作有8种：

* 从主存中读取数据的read操作
* 读取数据后转载到工作内存中的load操作
* 执行引擎使用数据的use操作
* 执行引擎操作完后返回值到工作内存中的assign操作
* 数据从工作内存中写入主内存中的write操作
* 数据真正存储到主存中的store操作
* 还有在操作数据时上锁的lock操作
* 操作数据后的解锁的unlock操作

对于这八个操作，有以下规则：

* 不允许read与load，store和write操作之一单独出现，用了read必须load，用了store必须write
* 不允许线程丢弃它最近的assign操作，也就是工作变量的数据变化后，必须通知主存
* 不允许一个线程间没有assign的数据同步回主存
* 一个新的变量必须在主存中诞生，不允许工作内存直接用一个未被初始化的变量。就算对变量的use，store操作之前，必须经过assign和load操作
* 一个变量同一时间只有一个线程能对其进行lock，多次lock后，必须经过相同次数的unlock才能解锁
* 如果对一个变量进行了lock操作，会清空所有工作内存中次变量的值，在执行引擎使用这个变量前，必须重新load或者assign操作初始化变量的值。
* 如果一个变量没有被lock，就不可以对它进行unlock操作，也不可以unlock一个被其他线程锁住的变量
* 对一个变量进行unlock之前，必须把该变量同步回主存

在并发环境下，比如说我们有两个线程，它们去操作主存中的同一个变量，当一个线程操作完后写入数据到主存中，而另一个线程因为它还在用之前拷贝到工作内存中的数据，就会导致一些可见性问题。

#### Volatile可见性与非原子性

volatile关键字用于保障数据的可见性，也就是主存中这个变量如果变了，就会通知使用了这个变量的线程去要现在这个变量最新的值。但它不保证原子性。

volatile关键字会在普通写操作与volatile写之间与volatile写后都加了一层内存屏障，以此来保证指令不会被重排序。

对于那些需要保证原子性的东西，我们可以使用JUC包下的各种原子类，也就是Atomic的各种类型。

这些原子类是如何保证原子性的呢？

这些类里面基本都是用了unsafe这个类去操作数据，而这个unsafe类里面使用的是一堆的本地方法（native），而它们的原理，就是使用了CPU级别的并发保证CAS（比较并替换）来保证原子性的。效率及其高。

Unsafe类是一个特殊的存在。而这个CAS，则是JUC的精髓所在。

#### 指令重排序

我们写的程序，计算机并不是按我们的程序的顺序来执行的，也就是说，计算机可能会对我们的程序进行指令的重排序。

我们的程序在交给CPU执行时，要经过编译器，编译器就会对我们的程序进行优化，这里可能就会导致指令重排；而且我们的指令如果是指令并行的话也可能会进行重排；此外，内存系统也会重排指令。

指令重排的时候，编译器是会分析数据间的依赖关系的。但是在多线程的情况下，指令重排序可能是会引起我们程序数据的错误的。

#### 单例模式超级详解

常见的单例写法:

* 饿汉式

  ```Java
  public class Hungry{
      private Hungry(){}
      private final static Hungry HUNGRY = new Hungry();
      public static Hungry getInstance(){
          return HUNGRY;
      }
  }
  ```

  

* 懒汉式

  ```Java
  public class Lazy{
      private Lazy(){
          synchronized(LAZY.class){
              if(!bz){
                  bz = true;
              }else{
                  throw new Exception();
              }
          }
      }
      private static Lazy LAZY;
      private static boolean bz;//标志位
      public volatile static Lazy getInstance(){
          if(LAZY == null){
              LAZY = new Lazy();
          }
          return LAZY;
      }
      //这样的懒汉式在并发情况下是线程不安全的.得加锁
      //双重锁模式(DCL模式):
      public static Lazy getInstanceLock(){
          if(LAZY == null){
              synchronized(LAZY.class){
                  if(LAZY == null){
                      LAZY = new Lazy();
                      //这里也不是一个原子操作,也就是说这里在并发情况下并不是绝对安全的.这里有三步操作:1.分配内存 2.执行构造,初始化对象 3.让这个对象指向该空间.如果在这三步中发生了指令重排,并且在并发情况下,可能会导致内存问题.所以在这个LAZY必须上一个volatile
                  }
              }
          }
          return LAZY;
      }
      //还有一点要注意,如果我们不在构造器里去做判断的话,使用反射可以破坏这个单例模式!
      //即使是在构造器做了判断,如果对象都是用反射来创建,那照样会被破坏,这时可以用一个标志位来上锁,但这样也可以通过反编译去找到这个标志位来破坏单例.
      //我们可以在反射的newInstance方法中可以看到,如果你给的参数是一个枚举类型,那么就不可以用反射去破坏单例
  }
  ```

  ```Java
  public enum EnumSingle{
      //枚举类本身也是一个类.
      INSTANCE;
      public EnumSingle getInstance(){
          return INSTANCE;
      }
      //如果我们用反射创建多个这个枚举对象,并且通过无参构造,会导致报错,并且错误原因是没有无参构造.实际上这个枚举类它的构造函数是一个有参构造,一个参数是string,一个是int.我们可以使用jab工具来反编译class文件才可能看见那个有参构造.正确使用了有参构造再通过反射去构造多个这个枚举对象的话,我们会得到一个异常,就是说不可以通过反射来构造多个枚举.也就是说,枚举类是一个比我们的单例更加安全的单例模式.
  }
  ```

  

#### CAS

CAS(compare and set 比较与交换,还有一个说法是compare and swap 比较与替换).CAS是CPU的并发原语.

在Java的原子类型中,大量运用了这个操作.

原子类型中,基本都有一个compareAndSet的方法,它的参数一个是期望值,一个是替换的值,功能就是该类型对象的值是期望值的话就替换成替换值.

这个还只是Java层面的CAS.

这里要说到一个类:Unsafe.我们知道Java是没法去操作内存的,真正操作内存的实际是Java调用的本地方法去操作的.而这个Unsafe类就相当于Java留的一个后门,可以通过该类去操作内存.在Unsafe类中的方法几乎全都是native的.其中有个这个方法:getAndAddInt,这个就是我们用的原子的++.原子类的getAndIncrement方法就说调用了这个方法.而getAndIncrement方法给它传入了这三个参数:this,valueOffset,1,这个valeuOffset是一个内存地址的偏移量.这个getAndAddInt方法的里面是这样的:

```java
int var5;
do{
    var5 = this.getIntVolatile(val1,var2);//var1就是this,var2就是valeuOffset,这里意思就是说var5=从内存里拿出来的值.
}while(!this.compareAndSwapInt(var1,var2,var5,var5+var));//如果当前对象的内存偏移值的值还是var5,也就是期望的值,那么就进行一次+1.这里是一个原子性的操作.
//而且这个do while操作,是一个标准的自旋锁操作.
return var5;
```

CAS的缺点:

* 它底层因为使用了自旋锁,所以有时候会有点耗时,但这耗时也远比java原生操作要少的多
* 一次性只可以保证一个共享变量的原子性
* 可能会导致ABA问题

#### 原子引用与ABA问题

ABA问题:比如有两个线程去同时操作一个值A = 1,第一个线程的操作是cas(1,2),第二个线程的操作是cas(1,3),cas(3,1),而第二个线程走的比较快,一下就走完了,而第一个线程是不知道的,虽然A还是1,但是其实A是被动过的.这就是ABA问题.

**ABA问题的根本在于cas在修改变量的时候，无法记录变量的状态，比如修改的次数，否修改过这个变量。这样就很容易在一个线程将A修改成B时，另一个线程又会把B修改成A,造成casd多次执行的问题。**

JUC的原子包下有这样一个类:AtomicStampedReference,这个类就是一个原子引用类.通过它,其他线程就可以知道共享的变量被其他线程动过了,就相当于一个乐观锁一样.它也有个类似版本号的东西.

这个原子应用它比较的都是对象.总之它就是通过一个类似乐观锁的机制(加入版本号并比较)来解决了ABA问题的

#### 公平锁与非公平锁

公平锁:很公平的锁,不可以去插队,也就是线程必须先来后到,就是先来的任务先执行

非公平锁:不公平的锁,可以插队,默认用这个.

参照Lock锁里面的内容

#### 可重入锁

也叫递归锁.它的意思就是拿到了外面的锁,也就可以拿到里面的锁,并且这是一个自动获得的过程.

```java
public class ChongRuLock{
    public static void main(String[] args){
        Phone p = new Phone();
        new Thread(()->{
            p.sms();
        },"A").start();
        new Thread(()->{
            p.sms();
        },"B").start();
    }
}
class Phone{
    public synchronized void sms(){
        sout(Thread.currentThread().getName());
        call();
    }
    public synchronized void call(){
        sout(Thread.currentThread().getName() + "CALL");
    }
}
//运行后我们会发现它总是先走A的,这里都是synchronized,看的不是很明显
public class ChongRuLock{
    public static void main(String[] args){
        Phone p = new Phone();
        new Thread(()->{
            p.sms();
        },"A").start();
        new Thread(()->{
            p.sms();
        },"B").start();
    }
}
class Phone{
    
   Lock lock = new ReentrantLock();
    public void sms(){
        lock.lock();
        try{
            sout(Thread.currentThread().getName());
       		call();
        }finally{
            lock.unlock();
        }
        
    }
    public void call(){
        lock.lock();
        try{
        	sout(Thread.currentThread().getName() + "CALL");
           }finally{
            lock.unlock();
        }
    }
}//用Lock跟明显点
```



#### 自旋锁

自旋锁()会不断尝试,直到成功为止.

由于在多处理器环境中某些资源的有限性，有时需要互斥访问(mutual exclusion)，这时候就需要引入锁的概念，只有获取了锁的线程才能够对资源进行访问，由于多线程的核心是CPU的时间分片，所以同一时刻只能有一个线程获取到锁。那么就面临一个问题，那么没有获取到锁的线程应该怎么办？

通常有两种处理方式：一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁，它不用将线程阻塞起来(NON-BLOCKING)；还有一种处理方式就是把自己阻塞起来，等待重新调度请求，这种叫做`互斥锁`。当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -> 等待的机制被称为`自旋锁(spinlock)`。

我们可以自己写一个自旋锁:

```java
public class MyLock{
    AtomicReference<Thread> atomic = new AtomicReference<>();
    public void myLock(){
        Thread thread = Thread.currentThread();
        while(!atomic.compareAndSet(null,thread)){
            
        }
    }
    public void myUnLock(){
		Thread thread = Thread.currentThread();
        atomic.compareAndSet(thread,null);
    }
}
```

自旋锁的优缺点:

自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！

但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁。

#### 死锁排查

死锁的四大必要条件:

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件： 进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

解决死锁的四个方式.

1）忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，（鸵鸟策略）

2）检测死锁并且恢复。（检测与解除策略）

3）仔细地对资源进行动态分配，以避免死锁。（避免策略）

4）通过破除死锁四个必要条件之一，来防止死锁产生。（预防策略）

### 枚举类

java1.5后提供了Enum类来创建枚举类，或者enum关键字来创建，我们也可也实现接口的枚举类

枚举类：类的对象只有有限个，当我们需要定义一组有限个的确定常量时，我们最好使用枚举类，即这种含有有限个对象的类就是一个枚举类，如果枚举类中只有一个对象，这也算是一种单例模式的实现

枚举类的创建：

* 枚举类中的变量应当属于常量，所以应该用finall修饰符来修饰
* 可以自定义枚举类
* 可以使用enum关键字来创建枚举类

```java
//自定义枚举类
class Season{
    private final String SeasonName;
    private final int SeasonDay;
    //枚举类中的属性不可被改变，我们顶多提供一个get方法

    public String getSeasonName() {
        return SeasonName;
    }

    public int getSeasonDay() {
        return SeasonDay;
    }

    @Override
    public String toString() {
        return "Season{" +
                "SeasonName='" + SeasonName + '\'' +
                ", SeasonDay=" + SeasonDay +
                '}';
    }

    //枚举类必须是有限个的对象，所以我们要私有化构造器
    private Season(String SeasonName,int SeasonDay){
        this.SeasonName=SeasonName;
        this.SeasonDay=SeasonDay;
    }
    //提供当前枚举类的多个对象
    public static final Season Spring = new Season("Spring",30);
    public static final Season Summer = new Season("Summer",30);
    public static final Season Autumn = new Season("Autumn",30);
    public static final Season Winner = new Season("Winter",30);
}
```

```java
//使用关键字定义枚举类
//当使用enum关键字来定义枚举类时，默认父类是Enum类
enum Person{
    //要先提供枚举的对象，多个对象之间要用逗号隔开
    Person1("A",30),
    Person2("B",24);

    private final String name;
    private final int age;

    private Person(String name, int age) {
        this.name=name;
        this.age=age;
    }
}
```

```
//Enum类中的常用方法：
valueOf:传递枚举类的Class对象和枚举常量名称给该静态方法，返回与参数匹配的枚举常量
toString:得到当前枚举常量的名称
equals:比较枚举常量是否相等，相当于==
hashCode:与equals一样
getDeclaringClass:得到枚举常量所属枚举类的Class对象
name:得到当前枚举常量的名称
ordinal:得到当前枚举常量的次序
compareTo:枚举类实现Comparable接口后可以进行枚举常量的大小(声明顺序的排序)
clone：枚举类型不能被Clone，为防止子类实现克隆方法，Enum实现了一个抽除CloneNotSupportedException异常的不变Clone
```

如果枚举类要实现接口，并且调用不同的对象时能实现不一样的效果时，可以直接在对象后加上{}并在其中重写接口方法

### 泛型

泛型相当于标签，集合容器类在设计/声明的阶段不能确定这个容器到底实际存的是什么类型的对象，在java1.5之前都是把元素认为是Object，在java1.5之后用泛型来解决，这时除了元素的类型不确定，其他部分是确定的，比如这个元素如何保存，如何管理等是确定的，此时把元素的类型声明成一个参数，这个类型参数叫做泛型，Collection<E>,List<E>,ArrayList<E>,这个<E>就是泛型，泛型可以限制这些容器存放的数据类型 

泛型就是允许在定义类，接口的时候通过一个表示表示类中的某个属性的类型或是某个方法的返回值及其参数类型，这个类型参数将在使用时确定，比如在实现接口或继承对象的时候用这个类型去声明变量，在实例化对象时传递的实际参数的时候确定变量类型

泛型的使用，可以解决元素存储的安全性问题，以及在获取数据元素的时候可以不用再进行类型的强制转换

很多地方都可以用泛型

自定义泛型类/接口：

```java
public class A<T>{
//在类上面有个泛型符后，类的内部就可以使用类的泛型，比如这样
	T a;
}
//在使用泛型类的时候，实例化的时候最好指定泛型类型，不然还是会把泛型类型认作Object类型，如果类的参数有多个参数的时候可以加上多个泛型<E1,E2,E3...>,
//注意：泛型不同的引用不可以不能相互赋值
//在静态方法中不能使用类的泛型
//异常类不可以是泛型的
```

泛型方法：

```java
//不是说方法中使用了泛型就是泛型方法，泛型方法是值在方法中出现泛型结构，并且泛型参数与类的泛型参数没有关系，泛型方法所在的类可以是随意的
public <E> list<E> copylist(E[] arr){
    ArrayList<W> list = new ArrayList<>();
    for(E e : arr){
        list.add(e);
    }
    return list;
} //这样就算是一个泛型方法，前面的<E>是指定这个E不是一个E，而是一个泛型
//这个泛型是在进行函数调用的时候才会指定具体类型的
//泛型方法可以是静态的
```

泛型可以当作一个新的数据类型，对我们来说它可以是一个不确定的数据类型，在我们想要指定的时候随时能变成我们想要的类型

通配符：?

```java
//通配符的使用：
public void test(){
	List<Object> list1 = null;
	List<String> list2 = null;
	List<?> list = null;
	list = list1;
	list = list2;
	//这个时候这个list就算是list1和list2的父类了
    //即原本list1与list2它们分别属于List<A>,List<B>这样的并列关系，我们可以给它俩指定一个共同的父类List<?>
}
```





### io流

这个东西解决的是输入输出数据的问题

#### File类

这个类可以作为一个文件，也可也作为一个文件目录，它们都属于File类

File类是文件和文件目录路径的抽象表示形式，与平台无关，File类可以新建，删除，重命名文件和目录，但File不能访问文件内容，访问文件的内容需要输入/输出流，想要在Java程序中表示一个真实存在的文件或目录，那必须要有一个File对象，但Java程序中的一个File对象可能没有对应一个真实存在的文件或目录，File对象可以作为参数传递给构造器

```java
//File类声明在java.io包下
    //File类的构造器：
    public File(String pathname);
    //以pathname为路径创建File对象，可以是绝对路径或相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储
    public File(String parent,String child);
    //以parent为父路径，child为子路径创建File对象
    public File(File parent,String child); 
    //根据一个父File对象和子文件路径创建File对象

//File类的常用方法：
    public String getAbsolutePath();//获取绝对路径
    public String getPath();//获取路径
    public String getName();//获取名称
    public String getParent();//获取上层文件目录路径，如果没有就返回null
    public long Length();//获取文件长度，即字节数
    public long LastModeified();//获取最后一次修改时间，毫秒值
	public Stirng[] list();//获取指定目录下的所有文件或者文件目录的名称数组
    public File[] listFIles();//获取指定目录下的所有文件或者文件目录的File类数组
    public boolean renameTo(File dest);//把文件重命名为指定的文件路径，要想保证返回true，这里要调用该方法的File对象得在硬盘中存在，参数中的File不能存在

```

File类的判断功能

```java
	public boolean isDirectory();//判断是否是文件目录
    public boolean isFile();//判断是否是文件
    public boolean exists();//判断是否存在
    public boolean canRead();//判断是否可读
    public boolean canWrite();//判断是否可写
    public boolean isHidden();//判断是否隐藏
```

File类的创建功能

```java
//File类的创建功能(创建真实存在于硬盘中的文件)
/*对于File类对应的对象，如果是硬盘中真实存在的，则它会有很多属性，如果是没有的，只是对象层面的，它的很多属性都是默认值*/
    public boolean createNewFile();//创建文件，若文件存在，则不创建并返回false
    public boolean mkdir();//创建文件目录(要用绝对路径)，若文件目录存在，就不创建并返回false，若该文件目录的上层目录也不存在，也不创建
    public boolean delete();//删除文件或文件夹，这里的删除不走回收站，且要删除的文件目录里不能包含文件或文件夹
```



#### IO流原理及流的分类

IO流是用来将数据从文件中读取或者写入的，File类对象常会作为参数传递到流的构造器中，指明读写的终点。

I/O即input/output,IO技术用于处理设备之间的数据传输，如文件读写和网络通讯，Java中，对于数据的输入输出操作以流(stream)的方式进行，java的io包下提供了各种流类和接口，用于获取不同种类的数据，并通过标准的方法输入或输出数据，输入输出是站在程序的角度看的

输入：读取外部数据到内存中

输出：将内存数据输出到磁盘中

IO流根据不同标准可以有多种区分，比如按操作数据单位不同可以分为字节流(8bit)和字符流(16bit)，前者常用于非文本数据，后者常用于文本数据

java提供的io流包含40多个类，都是4个抽象基类的子类

##### 流的体系结构

![IO流](C:\Users\CHIYODAMOMO\Pictures\Saved Pictures\IO流.PNG)

##### 节点流(文件流)

FileReader流的使用:

```java
 public static void File(){
        FileReader fileReader =null;
        try{
            File file0 = new File("hello.txt");
            if (!file0.exists()) {
                 boolean newFile = file0.createNewFile();
            }
        //实例化File对象，指明要操作的文件
        //提供具体流
        //FileWriter fileWriter = new FileWriter(file0);
        //数据写入
        //fileWriter.write("abcdefg");
            fileReader = new FileReader(file0);
        //数据读出
        //read()方法可以返回读入的一个字符，如果达到文件末尾，就会返回-1
            int read = fileReader.read();
            while(read!=-1){
                System.out.println((char)read);
                read=fileReader.read();
            }
        }catch (IOException e){
            e.printStackTrace();
        }finally {
            //流的关闭(必须要关闭流)
            //因为这个是必须执行的操作，所以我们尽量不要使用throw异常，得用trycatch，选中上面的所有内容，按住alt，shift，z选取trycatch
            try {
                fileReader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
 //read()的重载方法(里面传入一个字符数组)
    public void Read2(){
        FileReader reader = null;
        try {
            File file = new File("hello.txt");
            reader = new FileReader(file);
            char[] chars= new char[5];
            //当read()方法传入一个char数组时，返回每次读入数组中的字符串个数，到末尾的时候还是返回-1
            while((reader.read(chars))!=-1){
                //这里遍历的时候，后面读取的数据会覆盖之前的数据然后再进行写入，如果我们用reader.read(chars).length,就会导致多输出东西，我们只需要每次只遍历reader.read(chars)个就行了
                for (int i = 0; i < reader.read(chars); i++) {
                    System.out.println(chars[i]);
                }
            };
        }catch (IOException e){
            e.printStackTrace();
        }finally {
            if (reader!=null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }


    }

    public static void main(String[] args) throws IOException{
        File();
    }
```

FileWriter流：

```java
  public static void writedata(){
        FileWriter fileWriter=null;
        try{
            //数据写入,这个操作对应的文件可以不存在，如果没有会自己创建，如果原本存在这个文件，并且这个文件里面有东西，数据会将原文件内容覆盖
            File file = new File("hello.txt");
            fileWriter = new FileWriter(file);//可以在这里添加第二个参数，第二个参数是可以指定对原文件内容是否覆盖，默认是false，会覆盖原文件内容，设置成true可以不覆盖
            fileWriter.write("anthorworld");//直接写入字符串
        }catch (IOException e){
            e.printStackTrace();
        }finally {
            if(fileWriter!=null) {
                try {
                    fileWriter.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
```

FileReader和FileWriter只能对字符流进行操作，不能对类似图片这样的字节流进行操作

##### 缓冲流(处理流)

##### 转换流

##### 标准输入输出流

##### 打印流

##### 数据流

##### 随机存取文件流

##### NIO.2中Path、Paths、Files类的使用

### 反射

* 反射(Reflection)是动态语言的关键，反射机制允许程序在执行期间借助反射API取得任何类的内部信息，并能够直接操作任意对象的内部属性和方法

* 加载完类后，在堆内存的方法区中就产生了一个Class类型的对象，这个对象包含了完整的类的结构信息，我们可以通过这个对象看到类的结构，这个对象就像一面镜子，透过这个镜子看到类的结构，我们就将这以机制称作反射

* 反射图解：![CSDN_1604822420637](D:\qq下载\2905037705\FileRecv\MobileFile\CSDN_1604822420637.jpg)

* 静态语言和动态语言：
  * 静态语言：程序在运行的时候结构不可以变化的语言，比如C，C++,JAVA
  * 动态语言：程序在运行是可以改变结构，比如增加新的函数，对象，或者引进代码，删除已有的函数等，就算在运行时代码可以根据某些条件改变自身结构，比如C#，JS,PHP,Python等。
  * 但是JAVA拥有反射机制，它具有一定的动态性
* 反射机制提供的功能
  * 在运行时判断任意一个对象所属的类
  * 在运行时构造任意一个类的对象
  * 在运行时判断任意一个类所具有的成员变量和方法
  * 在运行时获取泛型信息
  * 在运行时调用任意一个对象的成员变量和方法
  * 在运行时处理注解
  * 生成动态代理
* 反射相关的API
  * java.lang.Class:表示一个类
  * java.lang.reflect.Method：表示类的方法
  * java.lang.reflect.Field：表示类的成员变量
  * java.lang.reflect.Constructor：表示类的构造器

例子：

```java
@Test
    public void Test1() throws Exception{
        //反射前对类的操作
        //创建Person类对象
        Person person = new Person("A",12);
        //通过对象获取属性值或者修改属性值
        String name = person.getName();
        int age = person.getAge();
        person.show();
        //在Person类外部，我们无法通过它的对象获取它内部的私有属性(包括私有属性，私有方法，私有构造器)
        //Person person1 = new Person("A");//无法使用它的私有构造方法
        //有了反射：
        Class clazz = Person.class;//通过反射创建了Person对象
        Constructor constructor = clazz.getConstructor(String.class, int.class);
        Object c = constructor.newInstance("C",15);
        Person person1 = (Person) c;
        System.out.println(c.toString());
        //通过反射调用对象指定的属性和方法
        Field age1 = clazz.getDeclaredField("age");
        age1.set(person1,10);
        Method show = clazz.getDeclaredMethod("show");
        show.invoke(person1);
        //反射调用类的私有结构：
        Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class);
        declaredConstructor.setAccessible(true);
        Person person2 = (Person) declaredConstructor.newInstance("X");
        System.out.println(person2);
        //反射调用私有属性：
        Field name1 = clazz.getDeclaredField("name");
        name1.setAccessible(true);
        name1.set(person2,"Y");
        System.out.println("person2:"+person2);
        //反射调用私有方法：
        Method showNetion = clazz.getDeclaredMethod("showNetion",String.class);
        showNetion.setAccessible(true);
        showNetion.invoke(person2,"china");

    }
```

* 反射与封装性

  * 反射机制的使用：当我们不知道要创建哪个类的对象的时候，我们可以使用反射来创建对象，平时还是用new或者Spring来构建对象
  * 反射与封装之间并不矛盾

* Class类(反射源)

  * 类的加载过程：程序写好后会被编译成一个.class这样的字节码文件，每一个类对应一个.class文件，然后这些文件就可以被解释运行了，相当于将某个字节码文件加载到内存中，这个加载过程就是类的加载过程，加载到内存中的类，就叫做运行时类，这些运行时类就作为Class类的一个实例对象(类本身也是对象)，即万事皆对象，类也是对象。
  * 获取Class类对象的方法：
    * 某一个类.class；通过调用运行时类的一个.class属性，这样就可以实例化一个Class类对象了(Class类本身是带了泛型的，类型对应这个运行时类)
    * 运行时类的对象.getClass();这样就通过了运行时类的对象获取了Class类对象
    * Class.forName("某个运行时类的全路径");这样就通过调用Class的静态方法获取了Class类对象，(该方法可能会有异常，因为这个路径可能不存在)
    * 当前代码所在的类.class.getClassLoader;这样就通过了类的加载器ClassLoader获取了ClassLoader类对象，然后我们可以通过这个ClassLoader类对象的.loadClass("其中的一个类名");来获取Class类对象
  * 拥有Class对象的一些东西：
    * 类：包括外部类，内部类，成员内部类，静态内部类，局部内部类，匿名内部类
    * 接口
    * 数组
    * 枚举类
    * 注解
    * 基本数据类型
    * void

* 类的加载过程：

  当某个类被程序使用时，如果这个类还没有被加载到内存中，则系统会通过这样的方式对类进行初始化

![类加载](C:\Users\CHIYODAMOMO\Pictures\Saved Pictures\类加载.PNG)

![类加载1](C:\Users\CHIYODAMOMO\Pictures\Saved Pictures\类加载1.PNG)

![类加载器](C:\Users\CHIYODAMOMO\Pictures\Saved Pictures\类加载器.PNG)

* 使用ClassLoader来读取配置文件

  * 之前用Properties类来读取配置文件(.properties文件)

    ```
    Properties pro = new Properties();
    FileInputStream file = new FileInputStream("某个在模块下的配置文件的名称");
    pro.load(file);
    pro.getProperty("配置文件里的项");
    ```

  * ClassLoader可以读取配置文件

    ```
    Properties pro = new Properties();
    ClassLoader c  = 当前所在的类.class.getClassLoader();
    InputStream file = c.getResourceAsStream("某个在当前模块下src文件下的配置文件的名称");
    pro.load(file);
    pro.getProperty("配置文件里的项");
    ```

* 通过反射创建运行时类的对象(这就是反射所体现出的动态性)

  ```java
    @Test
      public void test() throws Exception{
          //创建运行时类的对象
          //不知道会创建哪个具体的类，只有运行了才知道
          int num = new Random().nextInt(3);
          String str = "";
          switch (num){
              case 0:
                  str = "java.util.Date";break;
              case 1:
                  str = "java.lang.Object";break;
              case 2:
                  str = "com.qin.Class.FanShe.User";break;
          } 
          System.out.println(build(str));
          //newINstance()方法可以创建运行时类的对象,这还是相当于调用了空参构造器，原来类里的构造器不能是私有的
      }
  
  
      public  Object build(String str) throws Exception{
          Class cla = Class.forName(str);
          return cla;
      }
  ```

* 通过反射可以获取运行时类的所有信息(包括它自己的属性和方法，还有它实现的接口，继承的父类，使用的注解等)

  * 通过Class类对象的getFields()方法可以获取运行时类的所有属性结构,并返回一个Filed类型的数组，只会返回权限为public的东西

    ```java
    Class cla = 某个类.class;
    Field f = cla.getFields();
    ```

  * 通过getDeclaredFields()方法可以获取运行时类中的所有属性，并返回一个Field类型的数组，所有权限的都会获取

  * ...























### 网络编程

直接或间接的通过网络协议与其它计算机实现信息交换，实现通讯

这块很多东西跟计算机网络有关

网络编程中的主要问题：

1.如何准确定位到网络上一台或多台主机，并定位它们上面特定的应用

2.如何进行高效的数据传输

网络编程中的两个要素：

1.IP和端口号

2.网络通信协议

IP与端口号组合可以得到一个网络套接字：Socket

要素1：IP地址和端口号

java中有这样的一个类：InetAddress，它的一个对象就对应一个IP地址

这个类有一些方法：

```
getByName();//这个方法可以给它传入IP地址或者域名，可以解析出对应的IP，这个方法是一个实例化IP类的方法
InetAddress inet = new getByName("localhost");//实例化一个IP类，对应本机IP
InetAddress.getLOcalHost();//这个方法可以获取本机IP
inet.getHostName();//获取本机域名
inet.getHostAddress();//获取本机地址
```

InetAddress类
说到IP地址，就要引入一个类：InetAddress
此类表示互联网协议 (IP) 地址。

InetAddress类无构造方法

常用方法摘要

```
byte[] getAddress()
返回此 InetAddress 对象的原始 IP 地址。
static InetAddress getByName(String host)
在给定主机名的情况下确定主机的 IP 地址。
String getHostAddress()
返回 IP 地址字符串（以文本表现形式）。
String getHostName()
获取此 IP 地址的主机名。
static InetAddress getLocalHost()
返回本地主机。
127.0.0.1：本机地址，主要用于测试。别名：Localhost
```

案例

```
import java.net.InetAddress;
import java.net.UnknownHostException;

public class TestIP {
  public static void main(String[] args) throws UnknownHostException {
    //InetAdress类表示IP地址

    //获取本机IP
    InetAddress ip = InetAddress.getLocalHost();
    System.out.println(ip);
    //获得主机名
    System.out.println(ip.getHostName());
    //获得IP地址
    System.out.println(ip.getHostAddress());
  }
}
```

案例二

```
import java.net.InetAddress;
import java.net.UnknownHostException;

public class TestIP2 {
  public static void main(String[] args) throws UnknownHostException {
    InetAddress inetAddress = InetAddress.getByName("www.baidu.com");
    // 获取此 IP 地址的主机名。
    System.out.println(inetAddress.getHostName());
    //返回 IP 地址字符串（以文本表现形式）。
    System.out.println(inetAddress.getHostAddress());
  }
}
```

运行
在这里插入图片描述

2、端口
IP地址用来标识一台计算机，但是一台计算机上可能提供多种网络应用程序，如何来区分这些不同的程序呢？这就要用到端口。
端口是虚拟的概念，并不是说在主机上真的有若干个端口。
通过端口，可以在一个主机上运行多个网络应用程序。端口的表示是一个16位的二进制整数，2个字节，对应十进制的0~65535。
MySQL（3306），Oracle（1521），Tomcat（8080）等等程序都有自己的端口

查看端口

用命令提示符cmd查看所有端口：netstat -ano
查看具体程序：使用任务管理器查看PID
InetSocketAddress类
说到端口，则要引入一个类：InetSocketAddress

此类实现 IP 套接字地址（IP 地址 + 端口号）。

构造方法摘要

```
InetSocketAddress(InetAddress addr, int port)
//根据 IP 地址和端口号创建套接字地址。
InetSocketAddress(int port)
//创建套接字地址，其中 IP 地址为通配符地址，端口号为指定值。
InetSocketAddress(String hostname, int port)
//根据主机名和端口号创建套接字地址。
常用方法摘要
InetAddress getAddress()
//获取 InetAddress。
String getHostName()
//获取 hostname。
int getPort()
//获取端口号。
```

案例

```
import java.net.InetAddress;
import java.net.InetSocketAddress;

public class TestPort {
  public static void main(String[] args) {
    InetSocketAddress inetSocketAddress = new InetSocketAddress("127.0.0.1",8082);
    System.out.println(inetSocketAddress.getHostName());
    //获得InetSocketAddress的端口
    System.out.println(inetSocketAddress.getPort());
    System.out.println(inetSocketAddress.getHostString());
    //返回一个InetAddress对象（IP对象）
    InetAddress address = inetSocketAddress.getAddress();
  }
}
```

3、URL
URI=URL+URN

URI：Uniform Resource Identifier ，统一资源标志符。
URL：Uniform Resource Locator，统一资源定位符。
URN：Uniform Resource Name，统一资源命名。

网络三大基石：HTML，HTTP，URL

URL
在www上，每一信息资源都有统一且唯一的地址，即统一资源定位符。Uniform Resource Locator。
如：https：//localhost：8080/index.html ，有4部分组成。（协议，主机域名或IP，端口号，资源文件名）
URL类
构造方法摘要
URL(String spec)
根据 String 表示形式创建 URL 对象。
URL(String protocol, String host, int port, String file)
根据指定 protocol、host、port 号和 file 创建 URL 对象。
URL(String protocol, String host, String file)
根据指定的 protocol 名称、host 名称和 file 名称创建 URL。

常用方法摘要

```
String getAuthority()
获取此 URL 的授权部分。
int getDefaultPort()
获取与此 URL 关联协议的默认端口号。
String getFile()
获取此 URL 的文件名。
String getHost()
获取此 URL 的主机名（如果适用）。
String getPath()
获取此 URL 的路径部分。
int getPort()
获取此 URL 的端口号。
String getUserInfo()
获取此 URL 的 userInfo 部分。
```

案例

```
import java.net.MalformedURLException;
import java.net.URL;

public class TestURL {
  public static void main(String[] args) throws MalformedURLException {

    URL url2 = new URL("https://www.bilibili.com/");
    
    //获取此的授权部分 URL 。
    System.out.println(url2.getAuthority());

    //获取此 URL的文件名。
    System.out.println(url2.getFile());

    //获取端口
    System.out.println(url2.getPort());

    //获取主机
    System.out.println(url2.getHost());

    //获得默认端口
    System.out.println(url2.getDefaultPort());

    //获得路径
     System.out.println(url2.getPath());

    //获取该 URL的userInfo部分。
    System.out.println(url2.getUserInfo());
  }
}
```

4、TCP协议和UDP协议
TCP和UDP位于同一层，都是建立在IP层的基础之上。由于两台电脑之间有不同的IP地址，因此两台电脑就可以区分开来，也就可以互相通话了。
通话一般有两种通话方式：第一种是TCP，第二种是UDP。
TCP是可靠的连接，TCP就像打电话，需要先打通对方电话，等待对方有回应后才会跟对方继续说话，也就是一定要确认可以发信息以后才会把信息发出去。TCP上传任何东西都是可靠的，只要两台机器上建立起了连接，在本机上发送的数据就一定能传到对方的机器上。
UDP就好比发电报，发出去就完事了，对方有没有接收到它都不管，所以UDP是不可靠的。
TCP传送数据虽然可靠，但传送得比较慢；UDP传送数据不可靠，但是传送得快。
UDP编程：
需求：完成在线咨询功能，学生和老师在线一对一交流
分析：

使用基于UDP协议的Socket网络编程实现
不需要利用IO流实现数据的传输
每个数据发送单元被统一封装成数据包的方式，发送方将数据包发送到网络中，数据包在网络中去寻找他的目的地，一切以包为中心。
UDP基本概念：

DatagramSocket：用于发送或接收数据包的套接字
DatagramPacket：数据包
实现

```
接收方

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;

public class PeopleOne {
  public static void main(String[] args) throws IOException {
    //1.开放一个端口
    DatagramSocket socket = new DatagramSocket(5051);
    //2.准备容器接收
    byte[] receiveBuf = new byte[100];
    //3.等待包裹容器封包
    DatagramPacket packet = new DatagramPacket(receiveBuf,receiveBuf.length);
    System.out.println("等你包裹来。。。。");
    while (true){
      //4.接收包裹
      socket.receive(packet);
      //5.解析包裹
      String receStr = new String(packet.getData(),0,packet.getLength());
      System.out.println("我收到了："+receStr);
      if (receStr.equals("exit")){
        break;
      }
    }
    //6.释放资源
    socket.close();
  }
}
```

```
发送方

import java.io.IOException;
import java.net.*;
import java.util.Scanner;

public class PeopleTwo {
  public static void main(String[] args) throws IOException {
    //1.指定一个端口进行发送
    DatagramSocket socket = new DatagramSocket();
    //2.指定一个IP
    InetAddress addr = InetAddress.getByName("127.0.0.1");
    int port = 5051;
    //3.准备一个小容器
    byte[] sendBuf;
    while (true){
      Scanner scanner = new Scanner(System.in);
      System.out.println("你要发什么东西：");
      String s = scanner.nextLine();
      //4.加入要放的数据
      sendBuf = s.getBytes();
      //5.数据打包
      DatagramPacket packet = new DatagramPacket(sendBuf,sendBuf.length,addr,port);
      //6.发送包
      socket.send(packet);
      if (s.equals("exit")){
        break;
      }
    }
    //7.释放资源
    socket.close();
  }
}
```

TCP编程：
需求：完成网络登录功能

用户输入用户名密码，服务器给出登录成功或失败的提示
分析：

使用基于TCP协议的Socket网络编程实现
TCP协议基于请求响应模式
在网络通讯中，第一次主动发起通讯的程序被作为客户端程序
第一次通讯中等待连接的程序被称作服务器程序
利用IO流实现数据的传输
实现

```
服务器

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class TestServer {

  public static void main(String[] args) throws IOException {
    //服务器开启了一个监听端口
    ServerSocket serverSocket = new ServerSocket(6666);
    System.out.println("开启了服务器");
    while (true){
      //等待客户端连接
      Socket accept = serverSocket.accept();
      System.out.println("有一个人连接过来了");
      //获得客户端输入的东西
      InputStream inputStream = accept.getInputStream();
      //包装成DataInputStream流
      DataInputStream dataInputStream = new DataInputStream(inputStream);
      //通过流流读取消息
      String s = dataInputStream.readUTF();
      System.out.println(s);
    }
  }
}
```

```
客户端

import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;

public class TestClient {
  public static void main(String[] args) throws IOException {
    //创建同一连接
    Socket s = new Socket("127.0.0.1",6666);
    DataOutputStream dos = new DataOutputStream(s.getOutputStream());
    dos.writeUTF("hello,world！");
  }
```

5、Socket编程
一般的网络编程都称为Socket编程，Socket的英文意思是“插座”。

两台电脑都安装上一个插座，然后使用一根线的两端插到两台电脑的插座上，这样两台电脑就建立好了连接。这个插座就是Socket。

因为互相之间都能互相通信，我说你是我的Server只是从逻辑意义上来讲，我应该把东西先发到你那里去，然后由你来处理，转发。所以你叫Server。但从技术意义上来讲，只有TCP才会分Server和Client。对于UDP来说，从严格意义上来讲，并没有所谓的Server和Client。TCP的Server的插座就叫ServerSocket，Client的插座就叫Socket。

两台计算机互相连接，那么首先必须得知道它们的IP地址，但是只提供IP地址是不够的，还必须要有连接的端口号，也就是要连接到哪个应用程序上。

端口号是用来区分一台机器上不同的应用程序的。端口号在计算机内部是占2个字节。一台机器上最多有65536个端口号。一个应用程序可以占用多个端口号。端口号如果被一个应用程序占用了，那么其他的应用程序就无法再使用这个端口号了。记住一点，我们编写的程序要占用端口号的话占用1024以上的端口号，1024以下的端口号不要去占用，因为系统有可能会随时征用。端口号本身又分为TCP端口和UDP端口，TCP的8888端口和UDP的8888端口是完全不同的两个端口。TCP端口和UDP端口都有65536个。

![CSDN_1604820820698](D:\qq下载\2905037705\FileRecv\MobileFile\CSDN_1604820820698.jpg)



















 

## JAVA技术栈

![img](https://img-blog.csdn.net/201806050044031)

 

 ![img](https://img-blog.csdn.net/2018060500432351)

 

 

 

 ![img](https://img-blog.csdn.net/20180605004254482)

 

 

 ![img](https://img-blog.csdn.net/20180605004214816)

 

###  1.JAVA基础

| 关键字与保留字   | ★★★★★ |      |
| ---------------- | ----- | ---- |
| 标识符与命名规则 | ★★★★★ |      |
| 常量与变量       | ★★★★★ |      |
| 运算符           | ★★★★★ |      |
| 分支与逻辑       | ★★★★★ |      |
| 方法重载         | ★★★★★ |      |
| 面向对象         | ★★★★★ |      |
| 继承、封装、多态 | ★★★★★ |      |
| 集合             | ★★★★★ |      |
| io               | ★★★★★ |      |
| 多线程           | ★★★★★ |      |
| 网编             | ★★★★★ |      |
| 注解             | ★★★★★ |      |
| 枚举             | ★★★★★ |      |
| 反射与代理       | ★★★★★ |      |

### 2.性能优化

| JVM内存模型   | ★★★★★ |      |
| ------------- | ----- | ---- |
| JVM垃圾回收器 | ★★★★★ |      |
| JVM内存配置   | ★★★★★ |      |
| 线程锁优化    | ★★★★★ |      |
| tomcat优化    | ★★★★★ |      |
| NIO/netty     | ★★★★★ |      |

### 3.应用框架

| Spring    | ★★★★★ |      |
| --------- | ----- | ---- |
| SpringMVC | ★★★★★ |      |
| Mybatis   | ★★★★★ |      |
| log       | ★★★★★ |      |
| exception | ★★★★★ |      |
| shiro     | ★★★★★ |      |
| drools    | ★★★   |      |
| activiti  | ★★★★  |      |

### 4.分布式

| zookeeper     | ★★★★ |      |
| ------------- | ---- | ---- |
| dubbo         | ★★★★ |      |
| redis         | ★★★★ |      |
| RocketMq      | ★★★  |      |
| sharding-jdbc | ★★★  |      |

### 5.微服务

| springboot  | ★★★★ |      |
| ----------- | ---- | ---- |
| Eureka      | ★★★★ |      |
| rest+ribbon | ★★★  |      |
| feign       | ★★★  |      |
| Hystrix     | ★★★★ |      |
| zuul        | ★★★  |      |
| config      | ★★★  |      |
| bus         | ★★   |      |
| docker      | ★★★★ |      |

### 6.数据库

| sql与优化 | ★★★★★ |      |
| --------- | ----- | ---- |
| 索引      | ★★★★  |      |
| 分区      | ★★★   |      |
| 存储引擎  | ★★★   |      |
| 分库分表  | ★★    |      |
| JDBC      | ★★★★★ |      |

### 7.框架编写

| AOP      | ★★★★ |      |
| -------- | ---- | ---- |
| 设计原则 | ★★★  |      |
| 设计模式 | ★★★  |      |

### 8.计算机基础

| 计算机组成原理 | ★★★★★ |      |
| -------------- | ----- | ---- |
| 总线           | ★★★★★ |      |
| 内存           | ★★★★★ |      |
| cpu            | ★★★★★ |      |
| 汇编           | ★★    |      |
| 操作系统       | ★★★★  |      |
| 数据结构       | ★★★★★ |      |
| 算法           | ★★★★★ |      |
| 计算机网络     | ★★★★★ |      |

### 9.Linux

| Linux操作系统         |       |      |
| --------------------- | ----- | ---- |
| Linux操作系统常用命令 | ★★★★★ |      |
| shell脚本开发         | ★★★★★ |      |



 

 

 